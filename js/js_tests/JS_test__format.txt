Переменные

1. Какие символы может включать имя переменной в JS?
строчные латинские символы (+)
прописные латинские символы (+)
& (+)
_ (+)
?
-
&
()
{}
%
*
/
---EXT
В названии переменных можно использовать и русские буквы. Технически, ошибки здесь нет, но на практике сложилась традиция использовать в именах только английские буквы.

----------------------

2. Какие имена переменных верны?
test (+)
$const (+)
_inner (+)
limons2 (+)
5appels
tic-tak
---EXT
Имя может состоять из: букв, цифр, символов $ и _
Первый символ не должен быть цифрой



Шесть типов данных

1. Что вернёт typeof null?
"object" (+)
---EXT
Это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле null – это не объект, а отдельный тип данных.

Какой синтаксис верный: typeof x или typeof(x)?
Оба верны (+)



Основные операторы

1. Чему будет равна переменная a: var a = 2 + "2";
"22" (+)
---EXT
Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке.
Это приведение к строке – особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

----------------------

2. Чему будет равна переменная a: var a = 2 - "1";
1 (+)
---EXT
Арифметические операторы работают только с числами и всегда приводят аргументы к числу.
Исключение представляет бинарный оператор "+", который преобразовывает аргументы к строке.

----------------------

3. Корректен ли код? Чему будет равна переменная с?
var a = 1;
var b = 2;
var c = 3 - (a = b + 1);
alert( c );
Корректен 0 (+)
---EXT
Все операторы возвращают значение. Вызов x = выражение не является исключением.
Он записывает выражение в x, а затем возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения.
В примере выше результатом (a = b + 1) является значение, которое записывается в a (т.е. 3). Оно используется для вычисления c.

----------------------

4. Чему будет равна переменная a: var a = (1, 2);?
2 (+)
---EXT
Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.
Запятая – единственный оператор, приоритет которого ниже присваивания. В выражении a = (5,6) для явного задания приоритета использованы скобки, иначе оператор '=' выполнился бы до запятой ',', получилось бы (a=5), 6.

----------------------



Операторы сравнения и логические значения

1. Каков будет результат операции: 'Б' > 'А';?
true (+)
---EXT
Аналогом «алфавита» во внутреннем представлении строк служит кодировка, у каждого символа – свой номер (код). JavaScript использует кодировку Unicode.
При этом сравниваются численные коды символов. В частности, код у символа Б больше, чем у А, поэтому и результат сравнения такой.
В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.
Поэтому регистр имеет значение:
 alert( 'а' > 'Я' ); // true, строчные буквы больше прописных
Для корректного сравнения символы должны быть в одинаковом регистре.

----------------------

2. Каков будет результат операции: '01' == 1;?
true (+)
---EXT
При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.

----------------------

3. Каков будет результат сравнения: '01' === 1;?
false (+)
---EXT
Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.

----------------------

4. Чем становится null при преобразовании в число?
0 (+)
---EXT

----------------------

5. Чем становится undefined при преобразовании в число?
NaN (+)
---EXT

----------------------

6. Каков будет результат сравнения: null == undefined?
true (+)
---EXT
Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.

----------------------

7. Каков будет результат сравнений: 
undefined > 0,
undefined < 0,
undefined == 0.
false (+)
---EXT

----------------------



Условные операторы: if, '?'

1. Что из перечисленного является false в логическом контексте? 
0, 
пустая строка "", 
null,
undefined,
NaN
0 (+) 
пустая строка "" (+)
null (+)
undefined (+)
NaN (+)
---EXT

----------------------



Логические операторы
1. Что выведет alert()?
var x;
true || (x = 1);
alert(x);
undefined (+)
---EXT
JavaScript использует «короткий цикл вычисления».
Допустим, вычисляются несколько ИЛИ подряд: a || b || c || .... Если первый аргумент – true, то результат заведомо будет true (хотя бы одно из значений – true), и остальные значения игнорируются.

----------------------

2. Что выведет alert() в примерах ниже?
alert( 1 || 0 );
alert( true || 'неважно что' );
alert( null || 1 );
alert( undefined || 0 );
1, true, 1, 0 (+)
---EXT
Оператор ИЛИ возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу.

----------------------

3. Что выведет alert() в примерах ниже?
alert( 1 && 0 );
alert( 1 && 5 );
alert( null && 5 );
alert( 0 && "не важно" );
0, 5, null, 0 (+)
---EXT
JavaScript использует «короткий цикл вычисления».
Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент.

----------------------

4. Что выведет alert()?
alert( 5 || 1 && 0 );
5 (+)
---EXT
Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
Поэтому в следующем коде сначала будет вычислено правое И: 1 && 0 = 0, а уже потом – ИЛИ.

----------------------

5. Что выведет alert()?
alert( !!"строка" );
true (+)
---EXT
Действия !:
Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.
В частности, двойное НЕ используют для преобразования значений к логическому типу

----------------------



Преобразование типов для примитивов
1. Что выведет alert()?
alert( String(null) === "null" );
true (+)
---EXT
Преобразование явным вызовом String(val)
Как видно из примеров выше, преобразование происходит наиболее очевидным способом, «как есть»: false становится "false", null – "null", undefined – "undefined" и т.п.

----------------------

2. Что выведет alert()?
alert( Number(null) );
0 (+)
---EXT
Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс "+"
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

----------------------

3. Что выведет alert()?
alert( +"   \n  123   \n  \n" );
123 (+)
---EXT
Строка	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

----------------------

4. Что выведет alert()?
alert( Boolean(null) );
false (+)
---EXT
Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).
undefined, null	false
Числа	Все true, кроме 0, NaN -- false.
Строки	Все true, кроме пустой строки "" -- false
Объекты	Всегда true

----------------------

5. Что выведет alert()?
alert( 4 + 5 + "px" );
"9px" (+)
---EXT



Циклы
1. Сколько раз выполняется данная конструкция i=0 в цикле 
var i;
for (i = 0; i < 3; i++) {
  alert( i );
}
Один раз, при заходе в цикл. (+)
---EXT
Начало: i=0 выполняется один-единственный раз, при заходе в цикл.
Условие: i<3 проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.
Тело: alert(i).
Шаг: i++ выполняется после тела на каждой итерации, но перед проверкой условия.
Идти на шаг 2.

----------------------

2. Что делает директива continue?
Прекращает выполнение текущей итерации цикла (+)
---EXT
Начало: i=0 выполняется один-единственный раз, при заходе в цикл.
Условие: i<3 проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.
Тело: alert(i).
Шаг: i++ выполняется после тела на каждой итерации, но перед проверкой условия.
Идти на шаг 2.

----------------------

3. Что будет в результате выполнения данного кода  
for(var i = 0; i < 3; i++){
	(i > 1) ? alert(i) : continue;
} ?
Такой код приведёт к ошибке (+)
---EXT
Оператор вопросительный знак '?', использованный во второй записи, возвращает значение.
Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'.
К таким относятся большинство конструкций и, в частности, break/continue.

----------------------

4. Что будет в результате выполнения данного кода  
outer:
for (var i = 0; i < 3; i++) { ... } ?
Такой код приведёт к ошибке (+)
---EXT
Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.
Директива continue также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.




Конструкция switch
1. Что будет в результате выполнения данного кода  
var a = 1+2;

switch (a) {
  case 4:
    alert('Верно!');
    break;

  case 3:
  case 5:
    alert('Неверно!');
    alert('Немного ошиблись, бывает.');
    break;

  default:
    alert('Странный результат, очень странный');
}
Выполнится условие case 5 (+)
---EXT
Несколько значений case можно группировать.
При a = 3 и a = 5 выполнится один и тот же код

----------------------

2. Что будет если пользователь введёт 3?
var arg = prompt("Введите arg?")
switch (arg) {
  case 3:
    alert( 3 );
    break;

  default:
    alert('Неизвестное значение: ' + arg)
}
Выполнится условие default (+)
---EXT
При вводе 3, switch перейдет на default. Потому, что prompt возвращает строку '3', а не число. Типы разные. Оператор switch предполагает строгое равенство ===, так что совпадения не будет.

----------------------



Функции
1. Какой называется данный вызов функции:
var f = function(параметры) {
  // тело функции
};
Function Expression (+)
---EXT

2. Каков будет результат выполнения функции в строке (1):
sayHi("Вася");
var sayHi = function(name) {
  alert( "Привет, " + name );
}
Вызовет ошибку (+)
---EXT
Основное отличие между Function Declaration и Function Expression, Function Declaration создаются интерпретатором до выполнения кода, даёт больше свободы в том, как организовать свой код.
Можно расположить функции внизу, а их вызов – сверху или наоборот.

3. Как называется функция, которая объявляется в месте использования и не получает уникального идентификатора для доступа к ней:
Анонимная функция(+)
---EXT

4. Сработает ли вызов в строке 2?
var sum = new Function('a,b', ' return a+b; ');
sum(1, 2); // 2
Да (+)
---EXT
То есть, функция создаётся вызовом new Function(params, code):
params — параметры функции через запятую в виде строки.
code — код функции в виде строки.
Таким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

----------------------



Рекурсия
1. Что такое рекурсия в программировании?
Частный случай подвызова – когда функция вызывает сама себя (+)
---EXT

----------------------



11--Именованные функциональные выражения
1. Как называется данная конструкция?
var f = function sayHi(...) { /* тело функции */ }; 
Named Function Expression (Именованные функциональные выражения)(+)
---EXT

----------------------

2. Каков будет результат вызова alert?
var f = function sayHi() { return 1) }; 
sayHi() // 2
Ошибка: undefined variable 'sayHi' (+)
---EXT
Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции (f).
Это ограничение видимости входит в стандарт JavaScript и поддерживается всеми браузерами, кроме IE8-.

----------------------

3. Каков будет результат выполнения данного кода?
(function g() { return 1; }); 
alert(g);
Ошибка, "undefined variable".(+)
---EXT
В коде скобки есть, значит функция внутри является не Function Declaration, 
а частью выражения, то есть Named Function Expression. Его имя видно только внутри, снаружи переменная g не определена.

----------------------



12--Введение в методы и свойства
1. Какой метод округляет число num до n знаков после запятой?
num.toFixed(n)(+)
---EXT
num.toFixed(n) округляет число num до n знаков после запятой, 
при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода).
Округление идёт до ближайшего значения

----------------------

2. Каков будет результат выполнения данного кода?
alert(12.toFixed(1));
ошибка(+)
---EXT
Ошибка произойдёт потому, что JavaScript ожидает десятичную дробь после точки.
Вот так – будет работать:
alert( 12..toFixed(1) ); // 12.0

----------------------

3. Каков будет результат выполнения данного кода?
NaN == NaN
false(+)
---EXT
Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.

----------------------

4. Каков будет результат выполнения функции isFinite(n)?
Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinitye(+)
---EXT

----------------------

5. Каков будет результат выполнения функции parseInt('12px')?
12(+)
---EXT
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления

----------------------

6. С помощью какой функции можно получить предаставление числа в нужной системе счисления?
n.toString(основание системы)(+)
---EXT

----------------------

7. Как округляет функция Math.floor?
Округляет вниз(+)
---EXT

----------------------

8. Как округляет функция Math.ceil?
Округляет вверх(+)
---EXT

----------------------

9. Как округляет функция Math.round?
Округляет до ближайшего целого(+)
---EXT

----------------------

10. Каков будет результат выполнения данного кода?
~~12.3
12(+)
---EXT
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его.
Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем 12.3 ^ 0 ); // 12.

----------------------

11. Результаты выполнения данного кода будут одинаковы?
var price = 6.35;
alert( price.toFixed(1) );
alert( Math.round(price * 10) / 10 );
Нет(+)
---EXT
var price = 6.35;
alert( price.toFixed(1) ); // 6.3
alert( Math.round(price * 10) / 10 ); // 6.4
Как видно результат разный! Вариант округления через Math.round получился более корректным,
так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.

----------------------

12. Каков будет результат выполнения данного кода?
0.1 + 0.2 == 0.3
false(+)
---EXT
Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3.
alert( 0.1 + 0.2 > 0.3 ); // true
Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.

Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10).

Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:

alert( 0.1.toFixed(20) ); // 0.10000000000000000555
Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.

Например, есть два способа сложить 0.1 и 0.2:

Сделать их целыми, сложить, а потом поделить:

alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
Это работает, так как числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.

Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:

var result = 0.1 + 0.2;
alert( +result.toFixed(10) ); // 0.3

----------------------



13--Строки
1. Каков будет результат выполнения данного кода?
var str = "Widget with id";
alert( str.indexOf("widget") );
-1(+)
---EXT
Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Возвращает индекс первого вхождения указанного значения в строковый объект String или -1, если ничего не найдено. 
-1, не найдено, так как поиск учитывает регистр

----------------------

2. В чём отличие lastIndexOf от indexOf?
lastIndexOf возвращает индекс последнего вхождения указанного значения в строковый объект String(+)
---EXT
Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Возвращает индекс первого вхождения указанного значения в строковый объект String или -1, если ничего не найдено,
а lastIndexOf — индекс последнего вхождения.

----------------------

3. Каков будет результат выполнения данного кода?
var str = "stringify";
alert( str.substring(2) );
ringify(+)
---EXT
Метод substring(start [, end]) возвращает подстроку с позиции start до, но не включая end.
Если аргумент end отсутствует, то идет до конца строки

----------------------

4. Каков будет результат выполнения данного кода?
var str = "stringify";
str = str.substr(2,4); // ring, со 2-й позиции 4 символа
alert(str)
ring(+)
---EXT
Метод substr(start [, length]) возвращает указанное количество символов (length) из строки, начиная с позиции start.
Если аргумент length отсутствует, то идет до конца строки.

----------------------


5. Каков будет результат выполнения данного кода?
alert( "testme".substring(-2) );
testme(+)
---EXT
Отрицательные аргументы интерпретируются как равные нулю.
-2 становится 0

----------------------

6. Каков будет результат выполнения данного кода?
alert( "testme".substring(4, -1) );
test(+)
---EXT
Если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end

----------------------

7. Каков будет результат выполнения данного кода?
alert( "testme".slice(-2) );
me(+)
---EXT
Отрицательные значения отсчитываются от конца строки

----------------------

8. Каков будет результат выполнения данного кода?
alert( "testme".slice(1, -1) );
estm(+)
---EXT
От 1 позиции до первой (но не включая её) с конца.

----------------------

9. С помощью какого метода можно получить символ по его коду в Юникод кодировке
String.fromCharCode( code )(+)
---EXT

----------------------

10. С помощью какого метода можно получить Юникод кодировку из символа
str.charCodeAt(pos)(+)
---EXT
"абрикос".charCodeAt(0) // 1072, код 'а'

Зная код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.

----------------------

11. Каков будет результат выполнения данного кода?
"2" > "14"
true(+)
---EXT
Сравнение строк s1 и s2 обрабатывается по следующему алгоритму:
Сравниваются первые символы: s1[0] и s2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить true или false. Если же они одинаковые, то…
Сравниваются вторые символы s1[1] и s2[1]
Затем третьи s1[2] и s2[2] и так далее, пока символы не будут наконец разными, и тогда какой символ больше – та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих – они равны.

Если хотя бы один аргумент – не строка, то другой будет преобразован к числу

----------------------



14--Объекты
1. В каком порядке будут выведены свойства?
var codes = {
  // телефонные коды в формате "код страны": "название"
  "7": "Россия",
  "38": "Украина",
  "1": "США"
};

for (var code in codes) alert( code );
1, 7, 38(+)
---EXT
Если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались,
если имя свойства – число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.




15--Массивы 
1. Каков будет результат выполнения данного кода?
var fruits = ["Яблоко", "Апельсин", "Груша"];
fruits.pop();
alert( fruits );
Яблоко,Апельсин(+)
---EXT
pop удаляет последний элемент из массива и возвращает его.

----------------------

2. Каков будет результат выполнения данного кода?
var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); 
Яблоко,Апельсин,Груша(+)
---EXT
push добавляет элемент в конец массива.

----------------------

3. Каков будет результат выполнения данного кода?
var fruits = ["Яблоко", "Апельсин", "Груша"];
fruits.shift();
alert( fruits );
Апельсин,Груша(+)
---EXT
shift удаляет из массива первый элемент и возвращает этот массив.

----------------------

4. Каков будет результат выполнения данного кода?
var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits );
 Яблоко,Апельсин,Груша(+)
---EXT
unshift добавляет элемент в начало массива.

----------------------

5. Можно ли добавить несколько элементов с помощью методов push и unshift?
 Да(+)
---EXT
unshift добавляет элемент в начало массива.

----------------------

6. Какой из методов работает быстрее push или unshift?
 push(+)
---EXT
Методы push/pop выполняются быстро, а shift/unshift – медленно.
Чтобы понять, почему работать с концом массива – быстрее, чем с его началом, разберём подробнее происходящее при операции:
fruits.shift(); // убрать 1 элемент с начала
Операция shift должна выполнить целых три действия:
Удалить нулевой элемент.
Переместить все свойства влево, с индекса 1 на 0, с 2 на 1 и так далее.
Обновить свойство length.
А что же с push/pop? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод pop очищает ячейку и уменьшает значение length.

----------------------

7. Какой из методов работает быстрее pop или shift?
 pop(+)
---EXT
Методы push/pop выполняются быстро, а shift/unshift – медленно.
Чтобы понять, почему работать с концом массива – быстрее, чем с его началом, разберём подробнее происходящее при операции:
fruits.shift(); // убрать 1 элемент с начала
Операция shift должна выполнить целых три действия:
Удалить нулевой элемент.
Переместить все свойства влево, с индекса 1 на 0, с 2 на 1 и так далее.
Обновить свойство length.
А что же с push/pop? Им как раз перемещать ничего не надо. Для того, чтобы удалить элемент, метод pop очищает ячейку и уменьшает значение length.

--------------------

8. Каков будет результат выполнения данного кода?
var arr = [1, 2, 3, 4, 5];
arr.length = 2;
alert( arr );
1,2(+)
---EXT
При уменьшении length массив укорачивается.
Причем этот процесс необратимый, т.е. даже если потом вернуть length обратно – значения не восстановятся

--------------------

9. Каков будет результат выполнения данного кода?
var arr = new Array(2);
Массив без элементов, длины 2(+)
---EXT
new Array(элементы, ...) создаёт массив из данных элементов, но если у него один аргумент-число new Array(число),
то он создает массив без элементов, но с заданной длиной.

--------------------



16--Массивы: методы
1. Каков будет результат выполнения данного кода?
alert( "a,b,c,d".split(',', 2) );
a,b(+)
---EXT
Метод split(s) позволяет превратить строку в массив, разбив ее по разделителю s.
У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. 
Если их больше, чем указано – остаток массива будет отброшен

--------------------

2. Каков будет результат выполнения данного кода?
alert( new Array(4).join("ля") );
ляляля(+)
---EXT
Вызов arr.join(str) берет массив и склеивает его в строку, используя str как разделитель.
new Array(4) делает массив без элементов длины 4, который join объединяет в строку, вставляя между его элементами строку "ля".
В результате, так как элементы пусты, получается повторение строки

--------------------

3. Как будет выглядеть массив после выполнения данного кода?
var arr = ["Я", "иду", "домой"];
delete arr[1];
["Я", undefined, "домой"](+);
---EXT
Оператор delete удаляет пару «ключ-значение». 
Это – все, что он делает. Обычно же при удалении из массива мы хотим, чтобы оставшиеся элементы 
сдвинулись и заполнили образовавшийся промежуток.

--------------------

4. Каков будет результат выполнения данного кода?
var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1);
alert( arr );
Я,JavaScript(+);
---EXT
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов

--------------------

5. Каков будет результат выполнения данного кода?
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
arr.splice(0, 3, "Мы", "изучаем");
alert( arr );
Мы,изучаем,JavaScript(+);
---EXT
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов

--------------------

6. Что возвращает метод splice?
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
var spliceReturn = arr.splice(0, 2);
alert( spliceReturn );
Я,сейчас(+);
---EXT
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов

--------------------

7. Каков будет результат выполнения данного кода?
var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(2, 0, "сложный", "язык");
alert( arr );
Я,изучаю,сложный,язык,JavaScript(+);
---EXT
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0

--------------------

8. Каков будет результат выполнения данного кода?
var arr = [1, 2, 5]
arr.splice(-1, 0, 3, 4);
1,2,3,4,5(+);
---EXT
arr.splice(index[, deleteCount, elem1, ..., elemN])
Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0
Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца

--------------------

9. Каков будет результат выполнения данного кода?
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3);
alert( arr2 );
надо,учить(+);
---EXT
Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
Аргументы ведут себя так же, как и в строковом slice:
Если не указать end – копирование будет до конца массива
Можно использовать отрицательные индексы, они отсчитываются с конца
Если вообще не указать аргументов – скопируется весь массив

--------------------

10. Каков будет результат выполнения данного кода?
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
1,15,2(+);
---EXT
По умолчанию sort сортирует, преобразуя элементы к строке.
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
arr.sort(compareNumeric);
function compareNumeric(a, b) {
  return a - b;
}
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.

--------------------

11. Как изменить порядок элементов массива на обратный?
arr.reverse()(+);
---EXT

--------------------

12. Каков будет результат выполнения данного кода?
var arr = [1, 2];
var newArr = arr.concat(3, 4);
alert( newArr );
1,2,3,4(+);
---EXT
Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
Если аргумент concat – одномерный массив, то concat добавляет элементы из него.
var arr = [1, 2];
var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
alert( newArr ); // 1,2,3,4,5
--------------------

13. Как найти индекс элемента в массиве, осуществляя поиск с конца массива?
arr.lastIndexOf()(+);
---EXT
Метод «arr.indexOf(searchElement[, fromIndex])» / «arr.lastIndexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.

--------------------

14. Как вывести ключи объекта в виде массива строк?
Object.keys(yourObject)(+);
---EXT
Не поддерживается IE8-

--------------------

15. Какие аргументы передаёт метод forEach в callback-функцию?
item – очередной элемент массива.(+);
i – его номер.(+);
arr – массив, который перебирается.(+);
---EXT
Метод «arr.forEach(callback[, thisArg])» используется для перебора массива.
Он для каждого элемента массива вызывает функцию callback.
Второй, необязательный аргумент forEach позволяет указать контекст this для callback.
Метод forEach ничего не возвращает.

--------------------

16. С помощью какого метода можно получить из массива arr массив arr1, состоящий из отфильтрованных элементов массива arr?
«arr.filter(callback[, thisArg])» (+);
---EXT
filter создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.
item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.

--------------------

17. С помощью какого метода можно создать новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr?
«arr.map(callback[, thisArg])»(+);
---EXT
Метод «arr.map(callback[, thisArg])» используется для трансформации массива.
Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.

--------------------

18. В каком случае метод «arr.every(callback[, thisArg])» вернёт true?
Если вызов callback вернёт true для каждого элемента arr(+);
---EXT
var arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные

Аргументы callback-функции:
number – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.

--------------------

19. В каком случае метод «arr.some(callback[, thisArg])» вернёт true?
Если вызов callback вернёт true для какого-нибудь элемента arr(+);
---EXT
var arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}
alert( arr.some(isPositive) ); // true, есть хоть одно положительное

Аргументы callback-функции:
number – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.

--------------------

20. Какой метод используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
«arr.reduce(callback[, initialValue])»(+);
---EXT
Аргументы функции callback(previousValue, currentItem, index, arr):
previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
index – номер текущего элемента.
arr – обрабатываемый массив.

Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

Пример:
var arr = [1, 2, 3, 4, 5]
// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);
alert( result ); // 15

При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.

Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.

--------------------



17--Псевдомассив аргументов "arguments"
1. Как получить доступ к третьему аргументу?
function log(a, b) {
  ...
}

log(a, b, c);
Через «псевдо-массив» arguments(+)
---EXT
«Псевдо-массив» arguments содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length.

В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.

В современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных
function f(x) {
  "use strict"; // для браузеров с поддержкой строгого режима

  arguments[0] = 5;
  alert( x ); // не 5, а 1! Переменная "отвязана" от arguments
}

f(1);

--------------------



Дата и Время
1. Что вернёт вызов new Date()?
Объект Date с текущей датой и временем(+)
---EXT

--------------------

2. Что вернёт вызов new Date(milliseconds)?
Создает объект Date, значение которого равно количеству миллисекунд, прошедших с 1 января 1970 года GMT+0(+)
---EXT

--------------------

3. Какую дату вернёт вызов new Date(2018, 6, 8, 7, 6, 5, 4)?
8 июля 2018, 07:06:05.004(+)
---EXT
new Date(year, month, date, hours, minutes, seconds, ms)
Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице.

Заметим:
Год year должен быть из 4 цифр.
Отсчет месяцев month начинается с нуля 0.

--------------------

4. Как получить год из объекта Date?
getFullYear()(+)
---EXT
Для доступа к компонентам даты-времени объекта Date используются следующие методы:

getFullYear() - Получить год (из 4 цифр).
getMonth() - Получить месяц, от 0 до 11.
getDate() - Получить число месяца, от 1 до 31.
getHours(), getMinutes(), getSeconds(), getMilliseconds() - Получить соответствующие компоненты.

--------------------

5. new Date().getDay() вернул 0. Какой это день недели?
Воскресенье(+)
---EXT
Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).

--------------------

6. Как получить часы для временной зоны зоны GMT+0?
new Date().getUTCHours()(+)
---EXT
Существуют также UTC-варианты методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC):
getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после "get" вставляется "UTC".

--------------------

7. Что вернёт вызов new Date().getTime()?
Число миллисекунд, прошедших с 1 января 1970 года GMT+0(+)
---EXT

--------------------

8. Какие методы, из перечисленных ниже, принимают больше одного аргумента?
setFullYear()(+)
setMonth()(+)
setHours()(+)
setMinutes()(+)
setSeconds()(+)
---EXT
Следующие методы позволяют устанавливать компоненты даты и времени:
setFullYear(year [, month, date])
setMonth(month [, date])
setDate(date)
setHours(hour [, min, sec, ms])
setMinutes(min [, sec, ms])
setSeconds(sec [, ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)

Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours().
Как видно, некоторые методы могут устанавливать несколько компонентов даты одновременно,
в частности, setHours. При этом если какая-то компонента не указана, она не меняется

--------------------

9. Какая дата будет выведена?
var d = new Date(2013, 0, 32);
1 февраля 2013(+)
---EXT
Автоисправление – очень удобное свойство объектов Date. Оно заключается в том, что можно устанавливать
заведомо некорректные компоненты (например 32 января), а объект сам себя поправит.
Неправильные компоненты даты автоматически распределяются по остальным.
Например, нужно увеличить на 2 дня дату «28 февраля 2011». Может быть так, что это будет 2 марта, а может быть и 1 марта, если год високосный. 

--------------------

10. Какая число месяца будет выведено?
var d = new Date;
d.setDate(-1);
alert( d );
Предпоследнее число предыдущего месяца(+)
---EXT
Можно установить и нулевые, и даже отрицательные компоненты

--------------------

11. Каков будет результат вычитания объектов Date?
Временная разница в миллисекундах(+)
---EXT
Когда объект Date используется в числовом контексте, он преобразуется в количество миллисекунд.

--------------------

12. Как вывести дату с русским форматированием?
var date = new Date(2014, 11, 31, 12, 30, 0);
var options = {
  era: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  weekday: 'long',
  timezone: 'UTC',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric'
};

date.toLocaleString("ru", options)(+)
---EXT

--------------------

13. Как вывести текущее время?
new Date().toTimeString()(+)
---EXT
Методы  toString(), toDateString(), toTimeString() возвращают стандартное строчное представление,
не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком.
Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно.

--------------------

14. Что выведет данный метод Date.parse(str)?
Количество милисекунд, соответствующее данной строке(+)
---EXT
Метод Date.parse(str) разбирает строку str в упрощённом формате ISO 8601 Extended.

Этот формат выглядит так: YYYY-MM-DDTHH:mm:ss.sssZ, где:
YYYY-MM-DD – дата в формате год-месяц-день.
Обычный символ T используется как разделитель.
HH:mm:ss.sss – время: часы-минуты-секунды-миллисекунды.
Часть 'Z' обозначает временную зону – в формате +-hh:mm, либо символ Z, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.
Также возможны укороченные варианты, например YYYY-MM-DD или YYYY-MM или даже только YYYY.
Date.parse('2012-01-26T13:51:50.417Z'); // таймзона UTC
Date.parse('2012-01-26T13:51:50.417-07:00'); // таймзона -07:00 GMT:

Метод Date.parse(str) разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, Date.parse возвращает NaN.

--------------------

15. Какой способ получение текущей даты в милисекундах быстрее Date.now() или +new Date()?
Date.now()(+)
---EXT
Технически, он аналогичен вызову +new Date(), но в отличие от него не создаёт промежуточный объект даты, а поэтому – во много раз быстрее.

--------------------



Замыкания, функции изнутри
1. Когда создаётся объект LexicalEnvironment?
При вызове функции, до выполнения первой строчки её кода(+)
---EXT
I. До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет его.
В данном случае туда попадает аргумент name и единственная переменная phrase:
function sayHi(name) {
  // LexicalEnvironment = { name: 'Вася', phrase: undefined }
  var phrase = "Привет, " + name;
  alert( phrase );
}
sayHi('Вася');
II. Функция выполняется.
Во время выполнения происходит присвоение локальной переменной phrase, то есть, другими словами, присвоение свойству LexicalEnvironment.phrase нового значения:
function sayHi(name) {
  // LexicalEnvironment = { name: 'Вася', phrase: undefined }
  var phrase = "Привет, " + name;

  // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}
  alert( phrase );
}
sayHi('Вася');
III.В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит
Каждый запуск функции создает новый такой объект.

*******
При входе в контекст исполнения (но до построчного выполнения его кода), VO наполняется следующими свойствами (они уже были описаны в начале статьи):

для каждого формального параметра функции (если мы находимся в контексте исполнения функции)
– создаётся свойство VO с именем и значением формального параметра; для непереданных параметров – создаётся свойство VO с именем формального параметра и значением undefined;

для каждой декларации функции (FunctionDeclaration, FD)
– создаётся свойство VO, с именем функции и значением, являющимся ссылкой на объект-функцию; если в VO уже присутствовало свойство с таким именем, оно его значение и атрибуты заменяются значением функции;

для каждой переменной (var)
– создаётся свойство VO с именем переменной, и значением undefined; если в VO уже присутствовало свойство с таким именем, оно остаётся нетронутым.

--------------------

2. Когда функция получает ссылку [[Scope]] на объект с переменными, в контексте которого была создана?
При создании(+)
---EXT
При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.
Это свойство никогда не меняется. Оно всюду следует за функцией, привязывая её, таким образом, к месту своего рождения.
При запуске функции её объект переменных LexicalEnvironment получает ссылку на «внешнее лексическое окружение» со значением из [[Scope]].

--------------------

3. Каков будет результат выполнения данного кода?
var a = 1;
function getFunc() {
  var a = 2;
  var func = new Function('', 'alert(a)');
  return func;
}
getFunc()();
1(+)
---EXT
При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.

Эта особенность new Function, хоть и выглядит странно, на самом деле весьма полезна.

Представьте себе, что нам действительно нужно создать функцию из строки кода. Текст кода этой функции неизвестен на момент написания скрипта (иначе зачем new Function), но станет известен позже, например получен с сервера или из других источников данных.

Предположим, что этому коду надо будет взаимодействовать с внешними переменными основного скрипта.

Но проблема в том, что JavaScript при выкладывании на «боевой сервер» предварительно сжимается минификатором – специальной программой, которая уменьшает размер кода, убирая из него лишние комментарии, пробелы, что очень важно – переименовывает локальные переменные на более короткие.

То есть, если внутри функции есть var userName, то минификатор заменит её на var a (или другую букву, чтобы не было конфликта), предполагая, что так как переменная видна только внутри функции, то этого всё равно никто не заметит, а код станет короче. И обычно проблем нет.

…Но если бы new Function могла обращаться к внешним переменным, то при попытке доступа к userName в сжатом коде была бы ошибка, так как минификатор переименовал её.

Получается, что даже если бы мы захотели использовать локальные переменные в new Function, то после сжатия были бы проблемы, так как минификатор переименовывает локальные переменные.

Описанная особенность new Function просто-таки спасает нас от ошибок.

Ну а если внутри функции, создаваемой через new Function, всё же нужно использовать какие-то данные – без проблем, нужно всего лишь предусмотреть соответствующие параметры и передавать их явным образом, например так:

var sum = new Function('a, b', ' return a + b; ');

var a = 1, b = 2;

alert( sum(a, b) ); // 3

--------------------

4. Как сделать, чтобы вызов счётчика был таким counter()?
function makeCounter() {
  var currentCount = 1;

  return { // возвратим объект вместо функции
    getNext: function() {
      return currentCount++;
    },

    set: function(value) {
      currentCount = value;
    },

    reset: function() {
      currentCount = 1;
    }
  };
}

var counter = makeCounter();

alert( counter.getNext() ); // 1
alert( counter.getNext() ); // 2

counter.set(5);
alert( counter.getNext() ); // 5
Записать методы в объект функции(+)
---EXT
function makeCounter() {
  var currentCount = 1;

  // возвращаемся к функции
  function counter() {
    return currentCount++;
  }

  // ...и добавляем ей методы!
  counter.set = function(value) {
    currentCount = value;
  };

  counter.reset = function() {
    currentCount = 1;
  };

  return counter;
}

var counter = makeCounter();

alert( counter() ); // 1
alert( counter() ); // 2

counter.set(5);
alert( counter() ); // 5

--------------------

5. Глобальные переменные считаются достижимыми?
Да(+)
---EXT
Главной концепцией управления памятью в JavaScript является принцип достижимости (англ. reachability).
Определённое множество значений считается достижимым изначально, в частности:
I. Значения, ссылки на которые содержатся в стеке вызова, то есть – все локальные переменные и параметры функций, которые в настоящий момент выполняются или находятся в ожидании окончания вложенного вызова.
 - Все глобальные переменные.
 - Эти значения гарантированно хранятся в памяти. Мы будем называть их корнями.
II. Любое другое значение сохраняется в памяти лишь до тех пор, пока доступно из корня по ссылке или цепочке ссылок.

--------------------

6. Сборщик мусора удалит объект father?
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}
var family = marry({
  name: "Василий"
}, {
  name: "Мария"
});
delete family.father;
Нет(+)
---EXT
Функция marry принимает два объекта, даёт им ссылки друг на друга и возвращает третий, содержащий ссылки на оба.
Получившийся объект family можно изобразить так:https://learn.javascript.ru/article/memory-management/family@2x.png

Чтобы запустить сборщик мусора, удалим две ссылки:

delete family.father;
delete family.mother.husband;
Обратим внимание, удаление только одной из этих ссылок ни к чему бы не привело. Пока до объекта можно добраться из корня window, объект остаётся жив.

А если две, то получается, что от бывшего family.father ссылки выходят, но в него – ни одна не идёт:
https://learn.javascript.ru/article/memory-management/family-no-father@2x.png

Совершенно неважно, что из объекта выходят какие-то ссылки, они не влияют на достижимость этого объекта.

--------------------

7. Сборщик мусора удалит объект family?
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}
var family = marry({
  name: "Василий"
}, {
  name: "Мария"
});
window.family = null;
Да(+)
---EXT
https://learn.javascript.ru/article/memory-management/family-no-family@2x.png
Как видим, объекты в конструкции всё ещё связаны между собой. Однако, поиск от корня их не находит, они не достижимы, и значит сборщик мусора удалит их из памяти.

--------------------

8. Если запустить пример ниже с открытой консолью Chrome и, когда он остановится, в консоли набрать alert(value), какое значение будет выведено?
var value = "Сюрприз";
function f() {
  var value = "самое близкое значение";
  function g() {
    debugger;
  }
  return g;
}
var g = f();
g();
Сюрприз(+)
---EXT
Современные JS-движки делают оптимизации замыканий по памяти. Они анализируют использование переменных и в случае, когда переменная из замыкания абсолютно точно не используется, удаляют её.
В коде выше переменная value никак не используется. Поэтому она будет удалена из памяти.
Важный побочный эффект в V8 (Chrome, Opera) состоит в том, что удалённая переменная станет недоступна и при отладке!
Это может привести к забавным казусам при отладке, вплоть до того что вместо этой переменной будет другая, внешняя.

--------------------

9. Что буддет выведено в перовм и втором alert`е?
var obj = {
  weight: 10
};
with(obj) {
  weight = 20; // (1)
  size = 35; // (2)
}
alert( obj.size );
alert( window.size );
1: undefined, 2: 35(+)
---EXT
Конструкция with позволяет использовать в качестве области видимости для переменных произвольный объект.
С use strict конструкция не работает.
Почему отказались от with?
I.Проблемы возникают в том случае, когда в with(obj) присваивается переменная, которая по замыслу должна быть в свойствах obj, но ее там нет.
Если присваивается свойство, отсутствующее в obj. В результате интерпретатор, не найдя его, создает новую глобальную переменную window.size.

II. Еще одна причина – алгоритмы сжатия JavaScript не любят with. Перед выкладкой на сервер JavaScript сжимают. Для этого есть много инструментов, например Closure Compiler и UglifyJS. Обычно они переименовывают локальные переменные в более короткие имена, но не свойства объектов. С конструкцией with до запуска кода непонятно – откуда будет взята переменная. Поэтому выходит, что, на всякий случай (если это свойство), лучше её не переименовывать. Таким образом, качество сжатия кода страдает.

III. Ну и, наконец, производительность – усложнение поиска переменной из-за with влечет дополнительные накладные расходы.
Современные движки применяют много внутренних оптимизаций, ряд которых не может быть применен к коду, в котором есть with.



20--This
1. На что ссылается this?
function foo() {
  alert(this);
} 
foo();
window (global)(+)
---EXT
При обычном вызове функции, this определяется вызывающей стороной, которая активирует код контекста функции,
— так называемый, caller, т.е. родительский контекст, который вызывает функцию.

--------------------

2. Что выведет alert?
var c = 30;
alert(this.c);
30(+)
---EXT
В коде глобального контекста, значением this всегда является сам глобальный объект (global); таким образом, можно косвенно к нему обратиться:
// явное объявление свойства
// глобального объекта
this.a = 10; // global.a = 10
alert(a); // 10
 
// косвенное, посредством присваивания
// неопределённому до этого идентификатору
b = 20;
alert(this.b); // 20
 
// также косвенное, посредством объявления
// переменной, поскольку объектом переменных
// в глобальном контексте является сам глобальный объект
var c = 30;
alert(this.c); // 30

--------------------

3. Каким будет Reference у идентификатора?
var foo = 10;
Псевдокод:
var fooReference = {
  base: global,
  propertyName: 'foo'
};(+)
---EXT
Внутренний тип реализации Reference можно представить в виде обычного объекта с двумя свойствами: база (base) (т.е. объект, которому принадлежит свойство) и имя свойства (property name) внутри базы:
Псевдокод:
var valueOfReferenceType = {
  base: <base object>,
  propertyName: <property name>  
};

Значение типа Reference может быть получено только в двух случаях:
когда мы имеем дело с идентификатором (identifier);
либо же с выражением доступа к свойству (property accessor);
Процесс разрешения имён идентификаторов (identifier resolution) подробно рассматривается в четвёртой части (Цепь областей видимости, Scope chain). Здесь же отметим, что на выходе данного алгоритма всегда будет значение типа Reference (это важно для значения this).

Идентификаторами являются имена переменных, функций, формальных параметров функций и неявные свойства глобального объекта.

--------------------

4. На что ссылается this в первом случае и во втором?
I. 
var foo = {
  bar: function () {
    return this;
  }
};
foo.bar();

II. 
var foo = {
  bar: function () {
    return this;
  }
};
var test = foo.bar;
test(); 
foo.bar();
I. foo
II. global(+)
---EXT
I.
Значение типа Reference, где базой является объект foo, который и будет использован в качестве значения this при активации функции bar:
var fooBarReference = {
  base: foo,
  propertyName: 'bar
};

II.
Однако, активируя ту же самую функцию, но с другой формой вызова, мы имеем уже другое значение this:
var test = foo.bar;
test(); // global
поскольку test, являясь идентификатором, порождает другое значение типа Reference, то именно база этого нового значения типа Reference и будет использована в качестве значения this — т.е. глобальный объект:
var testReference = {
  base: global,
  propertyName: 'test'
};

--------------------

5. На что ссылается this в первом случае и во втором?
function foo() {
  alert(this);
} 
foo(); // 1
foo.prototype.constructor(); // 2
I. window (global)(+)
II. foo.prototype(+)
---EXT
I.
var fooReference = {
  base: global,
  propertyName: 'foo'
};

II.
var fooPrototypeConstructorReference = {
  base: foo.prototype,
  propertyName: 'constructor'
};

--------------------

6. На что ссылается this в этих случаях?
var foo = {
  bar: function () {
    alert(this);
  }
}; 
foo.bar();  // 1
(foo.bar)();   // 2
(foo.bar = foo.bar)();  // 3
(false || foo.bar)();  // 4
(foo.bar, foo.bar)();  // 5
I. foo(+)
II. foo(+)
III. window (global)(+)
IV. window (global)(+)
V. window (global)(+)
---EXT
I.
С первым случаем всё понятно – там однозначно тип Reference и, как следствие, this — это база, т.е. foo.

II.
Во втором случае применяется оператор группировки, который не вызывает, рассмотренный выше, метод получения реального значения объекта из значения типа Reference, т.е. GetValue (см. примечание к 11.1.6). Соответственно, на выходе оператора группировки — всё ещё значение типа Reference, а потому, значение this снова определено, как база, т.е. foo.

III.
В третьем случае, оператор присваивания, в отличие от оператора группировки, вызывает метод GetValue (см. шаг 3 11.13.1). В итоге на выходе уже будет значения типа Function, означающее, что в качестве this будет использован null и, как следствие, global

IV, V
Аналогично с четвертым и пятым случаями — оператор запятая и логическое ИЛИ вызывают GetValue, соответственно, мы теряем значение типа Reference и получаем значение типа Function; вновь, this определён как global.

Идентификаторами являются имена переменных, функций, формальных параметров функций и неявные свойства глобального объекта. К примеру, для значений по следующим идентификаторам:
var foo = 10;
function bar() {}
в промежуточных операциях, будут получены соответствующие значения типа Reference:
var fooReference = {
  base: global,
  propertyName: 'foo'
}; 
var barReference = {
  base: global
  propertyName: 'bar'
};
Для получения реального значения объекта из значения типа Reference предусмотрен метод GetValue, который псевдокодом можно описать следующим образом:
function GetValue(value) { 
  if (Type(value) != Reference) {
    return value;
  } 
  var base = GetBase(value); 
  if (base === null) {
    throw new ReferenceError;
  } 
  return base.[[Get]](GetPropertyName(value)); 
}
где внутренний метод [[Get]] получает значение свойства объекта, учитывая также и наследуемые свойства из цепи прототипов:
GetValue(fooReference); // 10
GetValue(barReference); // function object "bar"
Выражение доступа к свойству (property accessor), так же многим известно. Осуществляется оно либо через точечную нотацию (когда имя свойства является правильным идентификатором и заранее известно), либо же — через скобочную:
foo.bar();
foo['bar']();
На выходе промежуточного вычисления также будет получено значение типа Reference:
var fooBarReference = {
  base: foo,
  propertyName: 'bar'
}; 
GetValue(fooBarReference); // function object "bar"

--------------------

7. На что ссылается this?
(function foo(bar) { 
  alert(this); 
  !bar && foo(1); 
})();
window (global)(+)
---EXT
При  рекурсивном вызове именованной функции-выражения, при первой активации функции, базой является родительский объект активации (или глобальный объект), при последующих — базой должен быть специальный объект хранящий имя функции-выражения. Однако, в данном случае в качестве this также всегда используется global

--------------------

8. Что вернёт alert?
function A() {
  alert(this);
  this.x = 10;
} 
var a = new A();
[object Object](+)
---EXT
Будет возвращён вновь созданный пустой объект

--------------------

9. Что вернёт alert?
function foo() {
  function bar() {
    alert(this); 
  }
  bar();
}
window (global)(+)
---EXT
Существует ситуация, когда выражение вызова определит слева от скобок вызова значение типа Reference, однако значение this будет определено как null и, как следствие, global.
Это относится к случаю, когда базовым объектом значения типа Reference, является объект активации.
Данную ситуацию можно показать на примере с вложенной функцией, вызванной из родительской.
Как нам известно из второй части, локальные переменные, локальные функции и параметры функции хранятся в объекте активации данной функции.
Объект активации всегда возвращает в качестве значения this — null (т.е. схематичная запись AO.b() равносильна null.b()). И здесь мы снова возвращаемся к вышеописанному случаю, и снова в качестве this подставляется глобальный объект.

Глобальный объект (Global object) — объект, который создаётся до входа в любой из контекстов исполнения. Данный объект существует в единственном экземпляре, свойства его доступны из любого места программы, жизненный цикл объекта завершается с завершением программы.

Объект активации (Activation object, сокращённо AO) — специальный объект, который создаётся при входе в контекст функции и инициализируется свойством arguments — Объект аргументов (Arguments object):

В ES5 понятие объекта активации (activation object) заменено единой моделью лексических окружений (lexical environments).

--------------------



21--Преобразование объектов: toString и valueOf
1. Какой метод отвечает за строковое преобразование объекта?
toString(+)
---EXT
Метод toString не обязан возвращать именно строку.
Его результат может быть любого примитивного типа. Поэтому мы и называем его здесь «строковое преобразование», а не «преобразование к строке».

--------------------

2. Какой метод отвечает за численное преобразование объекта?
valueOf(+)
---EXT
Для численного преобразования объекта используется метод valueOf, а если его нет – то toString
Метод valueOf обязан возвращать примитивное значение, иначе его результат будет проигнорирован. При этом – не обязательно числовое.
Если посмотреть в стандарт, то в пункте 15.2.4.4 говорится о том, что valueOf есть у любых объектов. Но он ничего не делает, просто возвращает сам объект (не-примитивное значение!), а потому игнорируется.

--------------------

3. Что вернёт alert?
alert( new Date + "" );
"строка даты"(+)
---EXT
Объект Date, по историческим причинам, является исключением.
Бинарный оператор плюс + обычно использует численное преобразование и метод valueOf. Как мы уже знаем, если подходящего valueOf нет (а его нет у большинства объектов), то используется toString, так что в итоге преобразование происходит к строке. Но если есть valueOf, то используется valueOf. Выше в примере как раз a + b это демонстрируют.
У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.
…Но оператор + для Date использует именно toString (хотя должен бы valueOf).
Это и есть исключение:
 // бинарный плюс для даты toString, для остальных объектов valueOf
alert( new Date + "" ); // "строка даты"
Других подобных исключений нет.

--------------------

4. Чему равны выражения?
{}[0] // 1
{} + {} // 2
I. [0](+)
II. + {}(+)
---EXT
Если вы запустите эти выражения в консоли, то результат может показаться странным. Подвох здесь в том, что если фигурные скобки {...} идут не в выражении, а в основном потоке кода, то JavaScript считает, что это не объект, а «блок кода» (как if, for, но без оператора, просто группировка команд вместе, используется редко).
Вот блок кода с командой:
 {
  alert("Блок")
}
А если команду изъять, то будет пустой блок {}, который ничего не делает. Два примера выше как раз содержат пустой блок в начале, который ничего не делает. Иначе говоря:
{}[0]   // то же что и: [0]
{} + {} // то же что и: + {}
То есть, такие вопросы – не на преобразование типов, а на понимание, что если { ... } находится вне выражений, то это не объект, а блок.

--------------------

5. Будет ли выведен alert?
var value = new Boolean(false);
if (value) {
  alert( true ); // сработает!
}
Да(+)
---EXT
В языке Java (это не JavaScript, другой язык, здесь приведён для примера) логические значения можно создавать, используя синтаксис new Boolean(true/false), например new Boolean(true).
В JavaScript тоже есть подобная возможность, которая возвращает «объектную обёртку» для логического значения.
Эта возможность давно существует лишь для совместимости, она и не используется на практике, поскольку приводит к странным результатам. Некоторые из них могут сильно удивить человека, не привыкшего к JavaScript, например:
 var value = new Boolean(false);
if (value) {
  alert( true ); // сработает!
}
Почему запустился alert? Ведь в if находится false… Проверим:
var value = new Boolean(false);
alert( value ); // выводит false, все ок..
if (value) {
  alert( true ); // ..но тогда почему выполняется alert в if ?!?
}
Дело в том, что new Boolean – это не примитивное значение, а объект. Поэтому в логическом контексте он преобразуется к true, в результате работает первый пример.
А второй пример вызывает alert, который преобразует объект к строке, и он становится "false"
В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val.

--------------------



22--Создание объектов через "new"
1. Что вернёт alert?
function BigAnimal() {
  this.name = "Мышь";
  return { name: "Годзилла" };
}
alert( new BigAnimal().name );
Годзилла(+)
---EXT
Если есть явный вызов return, то применяется простое правило:
- При вызове return с объектом, будет возвращён он, а не this.
- При вызове return с примитивным значением, оно будет отброшено.

--------------------

2. Что вернёт alert?
function BigAnimal() {
  this.name = "Мышь";
  return "Годзилла";
}
alert( new BigAnimal().name );
Мышь(+)
---EXT
Если есть явный вызов return, то применяется простое правило:
- При вызове return с объектом, будет возвращён он, а не this.
- При вызове return с примитивным значением, оно будет отброшено.

--------------------

3. Есть ли отличия у данных вызовов?
var animal = new BigAnimal;
var animal = new BigAnimal();
Нет(+)
---EXT

--------------------



23--Дескрипторы, геттеры и сеттеры свойств
1. Какой метод позволяет объявить свойство объекта и настроить его дескрипторы?
Object.defineProperty(obj, prop, descriptor)(+)
---EXT
Аргументы:
obj - Объект, в котором объявляется свойство.
prop - Имя свойства, которое нужно объявить или модифицировать.
descriptor - Дескриптор – объект, который описывает поведение свойства.

В нём могут быть следующие поля:
value – значение свойства, по умолчанию undefined
writable – значение свойства можно менять, если true. По умолчанию false.
configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
get – функция, которая возвращает значение свойства. По умолчанию undefined.
set – функция, которая записывает значение свойства. По умолчанию undefined.
Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.

--------------------

2. Каким будет результат выполнения кода?
"use strict";
var user = {};
Object.defineProperty(user, "name", {
  value: "Вася",
  writable: false,
  configurable: false
});
user.name = "Петя";
Ошибка(+)
---EXT
Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable.
Заметим, что без use strict операция записи «молча» не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.

--------------------

3. Как исключить свойство toString из перечисления в for...in?
var user = {
  name: "Вася",
  toString: function() { return this.name; }
};
for(var key in user) alert(key);  // name, toString
Object.defineProperty(user, "toString", {enumerable: false});(+)
---EXT
Обратим внимание, вызов defineProperty не перезаписал свойство, а просто модифицировал настройки у существующего toString.

--------------------

4. Этот код вызовет ошибку?
var user = {
  firstName: "Вася",
  surname: "Петров"
}
Object.defineProperty(user, "fullName", {
  get: function() {
    return this.firstName + ' ' + this.surname;
  }
});
alert(user.fullName);
Нет(+)
---EXT
Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в get.
Обратим внимание, снаружи fullName – это обычное свойство user.fullName. Но дескриптор указывает, что на самом деле его значение возвращается функцией.

Казалось бы, зачем нам назначать get/set для свойства через всякие хитрые вызовы, когда можно сделать просто функции с самого начала? Например, getFullName, setFullName…
Конечно, в ряде случаев свойства выглядят короче, такое решение просто может быть красивым. Но основной бонус – это гибкость, возможность получить контроль над свойством в любой момент!
Например, в начале разработки мы используем обычные свойства, например у User будет имя name и возраст age:
function User(name, age) {
  this.name = name;
  this.age = age;
}
var pete = new User("Петя", 25);
alert( pete.age ); // 25
С обычными свойствами в коде меньше букв, они удобны, причины использовать функции пока нет.

…Но рано или поздно могут произойти изменения. Например, в User может стать более целесообразно вместо возраста age хранить дату рождения birthday:
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}
var pete = new User("Петя", new Date(1987, 6, 1));
Что теперь делать со старым кодом, который выводит свойство age?
Можно, конечно, найти все места и поправить их, но это долго, а иногда и невозможно, скажем, если вы взаимодействуете со сторонней библиотекой, код в которой – чужой и влезать в него нежелательно.
Добавление get-функции age позволяет обойти проблему легко и непринуждённо:
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // age будет высчитывать возраст по birthday
  Object.defineProperty(this, "age", {
    get: function() {
      var todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}
var pete = new User("Петя", new Date(1987, 6, 1));
alert( pete.birthday ); // и дата рождения доступна
alert( pete.age );      // и возраст
Заметим, что pete.age снаружи как было свойством, так и осталось. То есть, переписывать внешний код на вызов функции pete.age() не нужно.
Таким образом, defineProperty позволяет нам начать с обычных свойств, а в будущем, при необходимости, можно в любой момент заменить их на функции, реализующие более сложную логику.

--------------------

5. Можно ли указывать get/set в литералах?
var user = {
  firstName: "Вася",
  surname: "Петров",
  get fullName() {
    return this.firstName + ' ' + this.surname;
  },
  set fullName(value) {
    var split = value.split(' ');
    this.firstName = split[0];
    this.surname = split[1];
  }
};
alert( user.fullName ); // Вася Петров (из геттера)

user.fullName = "Петя Иванов";
alert( user.firstName ); // Петя  (поставил сеттер)
alert( user.surname ); // Иванов (поставил сеттер)
Да(+)
---EXT
Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в get.
Обратим внимание, снаружи fullName – это обычное свойство user.fullName. Но дескриптор указывает, что на самом деле его значение возвращается функцией.

--------------------

6. С помощью какого свойства можно определить несколько свойсвт сразу?
Object.defineProperties(obj, descriptors)(+)
---EXT
var user = {}
Object.defineProperties(user, {
  firstName: {
    value: "Петя"
  },
  surname: {
    value: "Иванов"
  },
  fullName: {
    get: function() {
      return this.firstName + ' ' + this.surname;
    }
  }
});
alert( user.fullName ); // Петя Иванов

--------------------

7. Чем отличается Object.keys от Object.getOwnPropertyNames?
Object.keys возвращает только enumerable-свойства(+)
Object.getOwnPropertyNames – возвращает все(+)
---EXT

--------------------

7. Как получиь дескриптор свойства?
Object.getOwnPropertyDescriptor(obj, prop)(+)
---EXT
Object.getOwnPropertyDescriptor возвращает дескриптор для свойства obj[prop].
Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений, например:
var obj = {
  test: 5
};
var descriptor = Object.getOwnPropertyDescriptor(obj, 'test');

// заменим value на геттер, для этого...
delete descriptor.value; // ..нужно убрать value/writable
delete descriptor.writable;
descriptor.get = function() { // и поставить get
  alert( "Preved :)" );
};

// поставим новое свойство вместо старого

// если не удалить - defineProperty объединит старый дескриптор с новым
delete obj.test;

Object.defineProperty(obj, 'test', descriptor);

obj.test; // Preved :)

…И несколько методов, которые используются очень редко:
Object.preventExtensions(obj) - Запрещает добавление свойств в объект.
Object.seal(obj) - Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.
Object.freeze(obj) - Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.
Object.isExtensible(obj) - Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.
Object.isSealed(obj) - Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.
Object.isFrozen(obj) - Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.

--------------------



24--Статические методы
1. Является ли метод Article.showCount статическим?
function Article() {
  Article.count++;

  //...
}
Article.count = 0;

Article.showCount = function() {
  alert( this.count );
}
new Article();
new Article();
Article.showCount();
Да(+)
---EXT
Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют «статическими». Их записывают прямо в саму функцию-конструктор.
Здесь Article.count – статическое свойство, а Article.showCount – статический метод.

--------------------

2. Является ли метод User.createAnonymous фабричным?
function User() {
  this.sayHi = function() {
    alert(this.name)
  };
}
User.createAnonymous = function() {
  var user = new User;
  user.name = 'Аноним';
  return user;
}
User.createFromData = function(userData) {
  var user = new User;
  user.name = userData.name;
  user.age = userData.age;
  return user;
}
var guest = User.createAnonymous();
guest.sayHi();
var knownUser = User.createFromData({
  name: 'Вася',
  age: 25
});
knownUser.sayHi();
Да(+)
---EXT
"Фабричный статический метод" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).

Полиморфная функция-конструктор User:
 function User(userData) {
  if (userData) { // если указаны данные -- одна ветка if
    this.name = userData.name;
    this.age = userData.age;
  } else { // если не указаны -- другая
    this.name = 'Аноним';
  }
  this.sayHi = function() {
    alert(this.name)
  };
 }
var guest = new User();
guest.sayHi();
var knownUser = new User({
  name: 'Вася',
  age: 25
});
knownUser.sayHi();

Преимущества использования фабричных методов:
- Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.
- Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.
- Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.

--------------------



25--Явное указание this: "call", "apply"
1. Что запишется в переменную args?
function printArgs()
  var args = [].slice.call(arguments);
  alert( args.join(', ') );
}
printArgs('Привет', 'мой', 'мир');
Массив из аргументов(+)
---EXT
При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть».
По стандарту вызов arr.slice(start, end) создаёт новый массив и копирует в него элементы массива arr от start до end.
А если start и end не указаны, то копирует весь массив.

--------------------

2. Чем отличается call от apply?
Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.(+)
---EXT

--------------------



26--Привязка контекста и карринг: "bind"
1. Какой метод позволяет привязать контекст к функции?
func.bind(context[, arg1, arg2...])(+)
---EXT
func - Произвольная функция
context - Контекст, который привязывается к func
arg1, arg2 - аргументы 

Результат вызова func.bind(context) – это обёртка, фиксирующая контекст и передающая вызовы в func.
bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.

--------------------

2. Что вернёт alert?
function mul(a, b) {
  return a * b;
};
var double = mul.bind(null, 2);
alert( double(3) );
6(+)
---EXT
Карринг (currying) или каррирование – термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей.
При помощи bind создадим функцию double, удваивающую значения. Это будет вариант функции mul с фиксированным первым аргументом.
При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2.
Говорят, что double является «частичной функцией» (partial function) от mul.



27--Декораторы
1. Является ли встроенная функция bind функцией декокатором?
Да (+)
---EXT
Декоратор – приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.
Декоратор получает функцию и возвращает обертку, которая делает что-то своё «вокруг» вызова основной функции.
Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.

function checkPermissionDecorator(f) {
  return function() {
    if (isAdmin()) {
      return f.apply(this, arguments);
    }
    alert( 'Недостаточно прав' );
  }
}
function save() { ... }

save = checkPermissionDecorator(save);
// Теперь вызов функции save() проверяет права

--------------------



28--Типы данных 
1. Какой toString нужно использовать в вызове toString.call(arr), чтобы получить спец. свойство [[Class]]?
toString стандартного объекта Object (+)
---EXT
Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта Object, другая не подойдёт.
Свойство [[Class]] есть и доступно для чтения указанным способом – у всех встроенных объектов.
Но его нет у объектов, которые создают наши функции. Точнее, оно есть, но равно всегда "Object".

Для большего удобства можно сделать функцию getClass, которая будет возвращать только сам [[Class]]:
function getClass(obj) {
  return {}.toString.call(obj).slice(8, -1);
}

2. Что вернёт alert?
alert( Array.isArray("String"));
false (+)
---EXT
Для проверки типа на массив есть специальный метод: Array.isArray(arr).
Он возвращает true только если arr – массив

--------------------



29--Формат JSON, метод toJSON
1. В каких свойствах JSON-объекта допущена ошибка?
{
  name: "Вася",  // 1
  "surname": 'Петров', // 2
  "age": 35, // 3
  "isAdmin": false // 4
}
1, 2 (+)
---EXT
Данные в формате JSON (RFC 4627) представляют собой:
JavaScript-объекты { ... } или
Массивы [ ... ] или
Значения одного из типов:
строки в двойных кавычках,
число,
логическое значение true/false,
null.

Объекты в формате JSON похожи на обычные JavaScript-объекты,
но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках.
Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.

--------------------

2. Чем является параметр reviver функции JSON.parse(str, reviver)?
Является функцией function(key, value) (+)
---EXT
Если указана функция reviver, то в процессе чтения объекта из строки JSON.parse передаёт ей по очереди
все создаваемые пары ключ-значение и может возвратить либо преобразованное значение,
либо undefined, если его нужно пропустить.
В данном случае мы можем создать правило, что ключ date всегда означает дату:
// дата в строке - в формате UTC
var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';
var event = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});
alert( event.date.getDate() ); // теперь сработает!

Эта возможность работает и для вложенных объектов тоже.

--------------------

3. Какие свойства будут сериализованы?
var room = {
  number: 23,
  occupy: function() {
    alert( this.number );
  }
};
number (+)
---EXT
Метод JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.
При сериализации объекта вызывается его метод toJSON.
Если такого метода нет – перечисляются его свойства, кроме функций.
{"number":23}

Пример метода toJSON
var room = {
  number: 23,
  toJSON: function() {
      return this.number;
    }
};
alert( JSON.stringify(room) ); // 23

--------------------

4. Как явно указать, что нужно сериализовать только свойства name и age?
var user = {
  name: "Вася",
  age: 25,
  window: window
};
JSON.stringify(user, ["name", "age"]) (+)
---EXT
Во втором параметре JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации.
Для более сложных ситуаций вторым параметром можно передать функцию function(key, value),
которая возвращает сериализованное value либо undefined, если его не нужно включать в результа.
var user = {
  name: "Вася",
  age: 25,
  window: window
};
var str = JSON.stringify(user, function(key, value) {
  if (key == 'window') return undefined;
  return value;
});
alert( str ); // {"name":"Вася","age":25}

Функция replacer работает рекурсивно
То есть, если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через replacer.

--------------------

5. Что означает третий параметр метода JSON.stringify в данном коде?
var user = {
  name: "Вася",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};
var str = JSON.stringify(user, "", 4);
Количество пробелов, которыми будет оформлен уровень вложенности (+)
---EXT
В методе JSON.stringify(value, replacer, space) есть ещё третий параметр space.
Если он является числом – то уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой – вставляется эта строка.

--------------------



30--setTimeout и setInterval
1. Как отменить исполнение таймера setTimout?
clearTimeout(timerId) (+)
---EXT
Функции setTimeout и setInterval возвращают числовой идентификатор таймера timerId, который можно использовать для отмены действия.
clearTimeout(timerId)
clearInterval(timerId)

В браузере идентификатор таймера является обычным числом. Другие JavaScript-окружения, 
например Node.JS, могут возвращать объект таймера, с дополнительными методами.

--------------------

2. Как запустить функцию через 1 секунду?
setTimeout(function(){}, 1000); (+)
---EXT
var timerId = setTimeout(func / code, delay[, arg1, arg2...]))

Параметры:
func/code - Функция или строка кода для исполнения. Строка поддерживается для совместимости, использовать её не рекомендуется.
delay - Задержка в миллисекундах, 1000 миллисекунд равны 1 секунде.
arg1, arg2 - Аргументы, которые нужно передать функции. Не поддерживаются в IE9-.

--------------------

3. Как запускать функцию через определённые интервалы исполюзуя setTimeout?
Запускать setTimeout рекурсивно(+)
---EXT
setTimeout запускает выполнение функции регулярно повторяя её через указанный интервал времени.
Остановить исполнение можно вызовом clearInterval(timerId).

Модальные окна замораживают время в Chrome/Opera/Safari
Что будет, если долго не жать OK на появившемся alert? Это зависит от браузера.
В браузерах Chrome, Opera и Safari внутренний таймер «заморожен» во время показа alert/confirm/prompt.
А вот в IE и Firefox внутренний таймер продолжит идти.
Поэтому, если закрыть alert после небольшой паузы, то в Firefox/IE следующий alert будет
показан сразу же (время подошло), а в Chrome/Opera/Safari – только через 2 секунды после закрытия.

Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval,
так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего.
Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.

var i = 1;
setInterval(function() {
  func(i);
}, 100);

var i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);


Реальная пауза между вызовами func при setInterval меньше, чем указана в коде!
Это естественно, ведь время работы функции никак не учитывается, оно «съедает» часть интервала.
Возможно и такое что func оказалась сложнее, чем мы рассчитывали и выполнялась дольше, чем 100 мс.
В этом случае интерпретатор будет ждать, пока функция завершится, затем проверит таймер и, если время
вызова setInterval уже подошло (или прошло), то следующий вызов произойдёт сразу же.
Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.

Так как функция также тянет за собой всё замыкание, то ставшие неактуальными, но не отменённые setInterval могут приводить к излишним тратам памяти.

--------------------

4. Чему равна минимальная задержка в таймера?
~4с(+)
---EXT
В ряде ситуаций таймер будет срабатывать реже, чем обычно. Задержка между вызовами setInterval(..., 4) может быть не 4 мс, а 30 мс или даже 1000 мс.
- Большинство браузеров (десктопных в первую очередь) продолжают выполнять setTimeout/setInterval, даже если вкладка неактивна.
- При этом ряд из них (Chrome, FF, IE10) снижают минимальную частоту таймера, до 1 раза в секунду. Получается, что в «фоновой» вкладке будет срабатывать таймер, но редко.
- При работе от батареи, в ноутбуке – браузеры тоже могут снижать частоту, чтобы реже выполнять код и экономить заряд батареи. Особенно этим известен IE. Снижение может достигать нескольких раз, в зависимости от настроек.
- При слишком большой загрузке процессора JavaScript может не успевать обрабатывать таймеры вовремя. При этом некоторые запуски setInterval будут пропущены.
Вывод: на частоту 4 мс стоит ориентироваться, но не стоит рассчитывать.

--------------------



31--eval
1. Каков результат выполнения кода?
"use strict";
eval("var a = 5;");
alert( a );
Ошибка (+)
---EXT
При вызове eval имеет полный доступ к локальным переменным.
Это означает, что текущие переменные могут быть изменены или дополнены

При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу.
Иными словами, в новом стандарте eval имеет свою область видимости, а к внешним переменным обращается через замыкание, аналогично тому, как работают обычные функции.

--------------------

2. Почему данный код потенциально уязвим?
function sayHi() {
  var phrase = "Привет";
  eval("alert(phrase)");
}
Переменная phrase может быть переименована пользователем или средства сжатия JavaScript (+)
---EXT
Современные средства сжатия JavaScript переименовывают локальные переменные автоматически. 
Это считается безопасным, так как локальная переменная видна лишь внутри функции и если в ней везде поменять phrase на p, то никто этого не заметит.
Итак, если где-то в функции есть eval, то его взаимодействие с локальными переменными будет нарушено с непредсказуемыми побочными эффектами.
Некоторые инструменты сжатия предупреждают, когда видят eval или стараются вообще
не сжимать такой код вместе с его внешними функциями, но всё это борьба с последствиями кривого кода.

--------------------

3. В чём отличие window.eval от eval?
window.eval выполняется глобально (+)
---EXT

--------------------

4. Данный код выдает ошибку. Как её исправить?
var user = eval('{  "name": "Вася",  "age": 25  }');
Добавить в строку круглые скобки var user = eval('({  "name": "Вася",  "age": 25  })');(+)
---EXT
Вызов eval(code) выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.
Зачем здесь нужны скобки eval( '(' + str + ')' ), почему не просто eval(str)?
…Всё дело в том, что в JavaScript с фигурной скобки { начинаются не только объекты, а в том числе и «блоки кода». Что имеется в виду в данном случае – интерпретатор определяет по контексту. Если в основном потоке кода – то блок, если в контексте выражения, то объект.
Поэтому если передать в eval объект напрямую, то интерпретатор подумает, что это на самом деле блок кода, а там внутри какие-то двоеточия…

--------------------



32--try..catch
1. Какие из alert`ов сработают?
try {
  alert('Начало блока try'); // (1)
  lalala;
  alert('Конец блока try'); // (2)
} catch(e) {
  alert('Ошибка ' + e.name + ":" + e.message + "\n" + e.stack); // (3)
}
alert("Внешний код..."); // 4
1, 3 (+)
---EXT
Конструкция try..catch состоит из двух основных блоков: try, и затем catch.

Работает она так:
Выполняется код внутри блока try.
Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение доходит до конца try и потом прыгает через catch.
Если в нём возникнет ошибка, то выполнение try на ней прерывается, и управление прыгает в начало блока catch(err).
При этом переменная err (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем.
Таким образом, при ошибке в try скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.

try..catch подразумевает, что код синтаксически верен
Если грубо нарушена структура кода, например не закрыта фигурная скобка или где-то стоит лишняя запятая, то никакой try..catch здесь не поможет. Такие ошибки называются синтаксическими, интерпретатор не может понять такой код.
Здесь же мы рассматриваем ошибки семантические, то есть происходящие в корректном коде, в процессе выполнения.

try..catch работает только в синхронном коде
Ошибку, которая произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:

 try {
  setTimeout(function() {
    throw new Error(); // вылетит в консоль
  }, 1000);
} catch (e) {
  alert( "не сработает" );
}
На момент запуска функции, назначенной через setTimeout, этот код уже завершится, интерпретатор выйдет из блока try..catch.

Чтобы поймать ошибку внутри функции из setTimeout, и try..catch должен быть в той же функции.

--------------------

2. Основные свойства объекта ошибки?
name, message, stack (+)
---EXT
name - Тип ошибки. Например, при обращении к несуществующей переменной: "ReferenceError".
message - Текстовое сообщение о деталях ошибки.
stack - Везде, кроме IE8-, есть также свойство stack, которое содержит строку с информацией о последовательности вызовов, которая привела к ошибке.

В зависимости от браузера у него могут быть и дополнительные свойства, см. Error в MDN и Error в MSDN.

--------------------

3. Какой оператор генерирует ошибку?
throw (+)
---EXT
Синтаксис: throw <объект ошибки>.
Технически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно – совместимый со стандартным, то есть чтобы у него были как минимум свойства name и message.

В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой.

var data = '{ "age": 30 }'; // данные неполны
try {
  var user = JSON.parse(data); // <-- выполнится без ошибок
  if (!user.name) {
    throw new SyntaxError("Данные некорректны");
  }
  alert( user.name );
} catch (e) {
  alert( "Извините, в данных ошибка" );
}

Ошибку, о которой catch не знает, он не должен обрабатывать.
Такая техника называется «проброс исключения»: в catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e.
При этом ошибка «выпадает» из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо «повалит» скрипт.

Заметим, что ошибка, которая возникла внутри блока catch, «выпадает» наружу, как если бы была в обычном коде.
В следующем примере такие ошибки обрабатываются ещё одним, «более внешним» try..catch:
function readData() {
  var data = '{ "name": "Вася", "age": 30 }';
  try {
    // ...
    blabla(); // ошибка!
  } catch (e) {
    // ...
    if (e.name != 'SyntaxError') {
      throw e; // пробрасываем
    }
  }
}
try {
  readData();
} catch (e) {
  alert( "Поймал во внешнем catch: " + e ); // ловим
}
В примере выше try..catch внутри readData умеет обрабатывать только SyntaxError, а внешний – все ошибки.

---
Оборачивание исключений
И, для полноты картины – последняя, самая продвинутая техника по работе с ошибками. Она, впрочем, является стандартной практикой во многих объектно-ориентированных языках.

Цель функции readData в примере выше – прочитать данные. При чтении могут возникать разные ошибки, не только SyntaxError, но и, возможно, к примеру URIError (неправильное применение функций работы с URI) да и другие.

Код, который вызвал readData, хотел бы иметь либо результат, либо информацию об ошибке.

При этом очень важным является вопрос: обязан ли этот внешний код знать о всевозможных типах ошибок, которые могут возникать при чтении данных, и уметь перехватывать их?

Обычно внешний код хотел бы работать «на уровень выше», и получать либо результат, либо «ошибку чтения данных», при этом какая именно ошибка произошла – ему неважно. Ну, или, если будет важно, то хотелось бы иметь возможность это узнать, но обычно не требуется.

Это важнейший общий подход к проектированию – каждый участок функционала должен получать информацию на том уровне, который ему необходим.

Мы его видим везде в грамотно построенном коде, но не всегда отдаём себе в этом отчёт.

В данном случае, если при чтении данных происходит ошибка, то мы будем генерировать её в виде объекта ReadError, с соответствующим сообщением. А «исходную» ошибку на всякий случай тоже сохраним, присвоим в свойство cause (англ. – причина).

Выглядит это так:
function ReadError(message, cause) {
  this.message = message;
  this.cause = cause;
  this.name = 'ReadError';
  this.stack = cause.stack;
}

function readData() {
  var data = '{ bad data }';

  try {
    // ...
    JSON.parse(data);
    // ...
  } catch (e) {
    // ...
    if (e.name == 'URIError') {
      throw new ReadError("Ошибка в URI", e);
    } else if (e.name == 'SyntaxError') {
      throw new ReadError("Синтаксическая ошибка в данных", e);
    } else {
      throw e; // пробрасываем
    }
  }
}

try {
  readData();
} catch (e) {
  if (e.name == 'ReadError') {
    alert( e.message );
    alert( e.cause ); // оригинальная ошибка-причина
  } else {
    throw e;
  }
}
Этот подход называют «оборачиванием» исключения, поскольку мы берём ошибки «более низкого уровня» и «заворачиваем» их в ReadError, которая соответствует текущей задаче.

--------------------

4. В какой последоватеьлности выполнится код?
try {
  alert( 'try' );
  BAD_CODE();
} catch (e) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}
try -> catch -> finally (+)
---EXT
Секция finally не обязательна, но если она есть, то она выполняется всегда:
- после блока try, если ошибок не было,
- после catch, если они были.

--------------------

5. Что выведет alert?
function func() {
  try {
    return 1;

  } catch (e) {
  } finally {
    alert( 'finally' );
  }
}
alert( func() );
сначала finally, потом 1 (+)
---EXT
Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

В примере ниже из try происходит return, но finally получает управление до того, как контроль возвращается во внешний код.
Если внутри try были начаты какие-то процессы, которые нужно завершить по окончании работы, то в finally это обязательно будет сделано.

Кстати, для таких случаев иногда используют try..finally вообще без catch.
function func() {
  try {
    return 1;
  } finally {
    alert( 'Вызов завершён' );
  }
}
alert( func() ); // сначала finally, потом 1
В примере выше try..finally вообще не обрабатывает ошибки. Задача в другом: выполнить код при любом выходе из try – с ошибкой ли, без ошибок или через return.

--------------------

6. Как "поймать" ошибку, "выпавшую" во внешний код?
С помощью свойства window.onerror (+)

Допустим, ошибка произошла вне блока try..catch или выпала из try..catch наружу, во внешний код. Скрипт упал.
Можно ли как-то узнать о том, что произошло? Да, конечно.
В браузере существует специальное свойство window.onerror, если в него записать функцию, то она выполнится и получит в аргументах сообщение ошибки, текущий URL и номер строки, откуда «выпала» ошибка.
Необходимо лишь позаботиться, чтобы функция была назначена заранее.
---EXT
<script>
  window.onerror = function(message, url, lineNumber) {
    alert("Поймана ошибка, выпавшая в глобальную область!\n" +
      "Сообщение: " + message + "\n(" + url + ":" + lineNumber + ")");
  };
  function readData() {
    error(); // ой, что-то не так
  }
  readData();

  Как правило, роль window.onerror заключается в том, чтобы не оживить скрипт – скорее всего, это уже невозможно,
  а в том, чтобы отослать сообщение об ошибке на сервер, где разработчики о ней узнают.
</script>

--------------------



33--ООП в функциональном стиле
1. Как передать this функции в строке с ошибкой?
function Foo(){
  this.val = 3;
  this.meth = function(){
    me();  // ошибка 
  }
  function me(){
    console.log( this, this.val );
  }
}
var bar = new Foo;
bar.meth();
call/apply(+)
bind(+)
присвоить this локальной переменной и хранить в замыкании(+)
---EXT
call/apply
function Foo(){
  this.val = 3;
  this.meth = function(){
    me.call(this);
  }
  function me(){
    console.log( this, this.val );
  }
}
var bar = new Foo;
bar.meth();

bind
function Foo(){
  this.val = 3;
  this.meth = function(){
    me();
  }
  var me = function(){
    console.log( this, this.val );
  }.bind(this);
}
var bar = new Foo;
bar.meth();

присвоить this локальной переменной и хранить в замыкании
function Foo(){
  var it = this;
  it.val = 3;
  it.meth = function(){
    me();
  }
  function me(){
    console.log( it, it.val );
  }
}
var bar = new Foo;
bar.meth();

--------------------



34--Геттер и сеттер
1. Как сделать доступ к публичному свойству объекта управляемым?
function CoffeeMachine(power) {
  this.waterAmount = 0;
  ...
}
Сделать свойство приватным, а чтение/запись значения осуществлять через специальные методы — геттеры и сеттеры(+)
---EXT
function CoffeeMachine(power, capacity) {
  //...
  this.setWaterAmount = function(amount) {
    if (amount < 0) {
      throw new Error("Значение должно быть положительным");
    }
    if (amount > capacity) {
      throw new Error("Нельзя залить воды больше, чем " + capacity);
    }

    waterAmount = amount;
  };

  this.getWaterAmount = function() {
    return waterAmount;
  };
}

var coffeeMachine = new CoffeeMachine(1000, 500);
coffeeMachine.setWaterAmount(450);
alert( coffeeMachine.getWaterAmount() ); // 450



35--Функциональное наследование
1. Есть две функции. Какой код нужно добаввить вместо *** в функции CoffeeMachine, чтобы она наследовала от Machine?
function Machine(power) {
  this._power = power; // (1)

  this._enabled = false;

  this.enable = function() {
    this._enabled = true;
  };
}
function CoffeeMachine(power) {
  ***
  alert( this._enabled );
  alert( this._power );
}

Machine.apply(this, arguments);(+)
---EXT
Общая схема функционального наследования:
Объявляется конструктор родителя Machine. В нём могут быть приватные (private), публичные (public) и защищённые (protected) свойства:
function Machine(params) {
  // локальные переменные и функции доступны только внутри Machine
  var privateProperty;

  // публичные доступны снаружи
  this.publicProperty = ...;

  // защищённые доступны внутри Machine и для потомков
  // мы договариваемся не трогать их снаружи
  // чтобы обозначить, что свойство является внутренним, его имя начинают с подчёркивания _.
  this._protectedProperty = ...
}

var machine = new Machine(...)
machine.public();

Для наследования конструктор потомка вызывает родителя в своём контексте через apply. После чего может добавить свои переменные и методы:
function CoffeeMachine(params) {
  // универсальный вызов с передачей любых аргументов
  Machine.apply(this, arguments);

  this.coffeePublicProperty = ...
}

var coffeeMachine = new CoffeeMachine(...);
coffeeMachine.publicProperty();
coffeeMachine.coffeePublicProperty();

В CoffeeMachine свойства, полученные от родителя, можно перезаписать своими. Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную:
function CoffeeMachine(params) {
  Machine.apply(this, arguments);

  var parentProtected = this._protectedProperty;
  this._protectedProperty = function(args) {
    parentProtected.apply(this, args); // (*)
    // ...
  };
}

--------------------



Прототип объекта
1. Сработает ли данный код в IE9
var animal = {
  eats: true
};
var rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;
alert( rabbit.jumps ); // true
Нет(+)
---EXT
специального свойства __proto__ доступно во всех браузерах, кроме IE10-

--------------------

2. Изменится ли значение eats в animal?
var animal = {
  eats: true
};
var rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;
rabbit.eats = false;
Нет(+)
---EXT
Прототип используется исключительно при чтении. Запись значения, например, rabbit.eats = value
или удаление delete rabbit.eats – работает напрямую с объектом.
В примере выше мы записываем свойство в сам rabbit

3. С помощью какого метода можно получить собственные свойства и методы объекта
obj.hasOwnProperty(prop)(+)
---EXT

--------------------

4. Что вернет alert?
var data = Object.create(null);
alert(data.toString);
undefined (+)
---EXT
Объект, создаваемый при помощи Object.create(null) не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо.

--------------------

4. С помощью какого свойства можно создать пустой объект с указынным прототипом?
Object.create(proto, descriptors) (+)
---EXT
Чтение: Object.getPrototypeOf(obj)
Возвращает obj.__proto__ (кроме IE8-)

Запись: Object.setPrototypeOf(obj, proto)
Устанавливает obj.__proto__ = proto (кроме IE10-).

Создание объекта с прототипом: Object.create(proto, descriptors)
Создаёт пустой объект с __proto__, равным первому аргументу (кроме IE8-), второй необязательный аргумент может содержать дескрипторы свойств.

--------------------



37--Свойство F.prototype и создание объектов через new
1. Как в IE9 указать в конструкторе, что rabbit наследует от animal?
var animal = {
  eats: true
};
function Rabbit(name) {
  this.name = name;
}
var rabbit = new Rabbit("Кроль");
alert( rabbit.eats );
Rabbit.prototype = animal;(+)
---EXT
Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

Свойство prototype имеет смысл только у конструктора
Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.
Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать __proto__ для новых объектов.

Значением prototype может быть только объект
Технически, в это свойство можно записать что угодно.
Однако, при работе new, свойство prototype будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано.

--------------------

2. Чему равен Rabbit.prototype.constructor
Rabbit(+)
---EXT
У каждой функции по умолчанию уже есть свойство prototype.
Оно содержит объект такого вида:
function Rabbit() {}
Rabbit.prototype = {
  constructor: Rabbit
};

Можно его использовать для создания объекта с тем же конструктором, что и данный:
 function Rabbit(name) {
  this.name = name;
  alert( name );
}
var rabbit = new Rabbit("Кроль");
var rabbit2 = new rabbit.constructor("Крольчиха");

Эта возможность бывает полезна, когда, получив объект, мы не знаем в точности, какой у него был конструктор (например, сделан вне нашего кода), а нужно создать такой же.

Свойство constructor легко потерять
JavaScript никак не использует свойство constructor. То есть, оно создаётся автоматически, а что с ним происходит дальше – это уже наша забота. В стандарте прописано только его создание.
В частности, при перезаписи Rabbit.prototype = { jumps: true } свойства constructor больше не будет.
Сам интерпретатор JavaScript его в служебных целях не требует, поэтому в работе объектов ничего не «сломается». Но если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие constructor вручную:
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};
Либо можно поступить аккуратно и добавить свойства к встроенному prototype без его замены:

// сохранится встроенный constructor
Rabbit.prototype.jumps = true

--------------------



28--Встроенные "классы" в JavaScript
1. Что вернёт Object.prototype.__proto__
null(+)
---EXT
Откуда новый объект obj получает такой __proto__?
- Запись obj = {} является краткой формой obj = new Object, где Object – встроенная функция-конструктор для объектов.
- При выполнении new Object, создаваемому объекту ставится __proto__ по prototype конструктора, который в данном случае равен встроенному Object.prototype.
- В дальнейшем при обращении к obj.toString() – функция будет взята из Object.prototype.
Объект Object.prototype – вершина иерархии, единственный, у которого __proto__ равно null.

--------------------

2. Что называют «классом» в «прототипном ООП»? 
Функцию-конструктор вместе с её prototype (+)
---EXT

--------------------

3. Какой метод эффективнее?
function showList() {
  alert( [].join.call(arguments, " - ") );              // 1
  alert( Array.prototype.join.call(arguments, " - ") ); // 2
}
showList("Вася", "Паша", "Маша"); // Вася - Паша - Маша
Второй (+)
---EXT
Второй, потому что не создаётся лишний объект массива []

--------------------

4. Сработает ли alert()?
var zero = new Number(0);
if (zero) {
  alert( "число ноль" );
}
Да (+)
---EXT
Примитивы не являются объектами, но методы берут из соответствующих прототипов: Number.prototype, Boolean.prototype, String.prototype.
По стандарту, если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например new String для строки, new Number для чисел, new Boolean – для логических выражений.
Далее будет произведена операция со свойством или вызов метода по обычным правилам, с поиском в прототипе, а затем этот объект будет уничтожен.
Технически, можно создавать объекты для примитивов и вручную, например new Number. Но в ряде случаев получится откровенно бредовое поведение. Например:
 alert( typeof 1 ); // "number"
alert( typeof new Number(1) ); // "object" ?!?
Или, ещё страннее:
 var zero = new Number(0);
if (zero) { // объект - true, так что alert выполнится
  alert( "число ноль -- true?!?" );
}
Поэтому в явном виде new String, new Number и new Boolean никогда не вызываются.

--------------------



39--Свои классы на прототипах
1. Где хранятся методы и свойства, нужные всем объектам класса в "прототипмном ООП"?
В prototype.(+)
---EXT
Чтобы объявить свой класс, нужно:
Объявить функцию-конструктор.
Записать методы и свойства, нужные всем объектам класса, в prototype.
Опишем класс Animal:
 // конструктор
function Animal(name) {
  this.name = name;
  this.speed = 0;
}
// методы в прототипе
Animal.prototype.run = function(speed) {
  this.speed += speed;
  alert( this.name + ' бежит, скорость ' + this.speed );
};
Animal.prototype.stop = function() {
  this.speed = 0;
  alert( this.name + ' стоит' );
};
var animal = new Animal('Зверь');
alert( animal.speed ); // 0, свойство взято из прототипа
animal.run(5); // Зверь бежит, скорость 5
animal.run(5); // Зверь бежит, скорость 10
animal.stop(); // Зверь стоит
В объекте animal будут храниться свойства конкретного экземпляра: name и speed, а общие методы – в прототипе.
При задании методов в прототипе мы не сможем её так оставить, ведь методы находятся вне конструктора, у них нет общей области видимости, поэтому приходится записывать name в сам объект, обозначив его как защищённое:
function Animal(name) {
  this._name = name;
}

Animal.prototype.sayHi = function() {
  alert( this._name );
}

var animal = new Animal("Зверь");
animal.sayHi(); // Зверь
Впрочем, недостаток этот – довольно условный. Ведь при наследовании в функциональном стиле также пришлось бы писать this._name, чтобы потомок получил доступ к этому значению.

--------------------



40--Наследование классов в JavaScript
1. Как кроссбраузерно указать, что Rabbit наследует от Animal?
function Animal(name) {
  this.name = name;
  this.speed = 0;
}
Animal.prototype.run = function(speed) {
  this.speed += speed;
  alert( this.name + ' бежит, скорость ' + this.speed );
};
function Rabbit(name) {
  this.name = name;
  this.speed = 0;
}
Rabbit.prototype = Object.create(Animal.prototype); (+)
Rabbit.prototype.__proto__ = Animal.prototype; (не работает в IE10-)
---EXT
Для наследования нужно, чтобы «склад методов потомка» (Child.prototype) наследовал от «склада метода родителей» (Parent.prototype).

Это можно сделать при помощи Object.create:

Код:

Rabbit.prototype = Object.create(Animal.prototype);
Для того, чтобы наследник создавался так же, как и родитель, он вызывает конструктор родителя в своём контексте, используя apply(this, arguments), вот так:

function Rabbit(...) {
  Animal.apply(this, arguments);
}
При переопределении метода родителя в потомке, к исходному методу можно обратиться, взяв его напрямую из прототипа:

Rabbit.prototype.run = function() {
  var result = Animal.prototype.run.apply(this, ...);
  // result -- результат вызова метода родителя
}
Структура наследования полностью:
// --------- Класс-Родитель ------------
// Конструктор родителя пишет свойства конкретного объекта
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

// Методы хранятся в прототипе
Animal.prototype.run = function() {
  alert(this.name + " бежит!")
}

// --------- Класс-потомок -----------
// Конструктор потомка
function Rabbit(name) {
  Animal.apply(this, arguments);
}

// Унаследовать
Rabbit.prototype = Object.create(Animal.prototype);

// Желательно и constructor сохранить
Rabbit.prototype.constructor = Rabbit;

// Методы потомка
Rabbit.prototype.run = function() {
  // Вызов метода родителя внутри своего
  Animal.prototype.run.apply(this);
  alert( this.name + " подпрыгивает!" );
};

// Готово, можно создавать объекты
var rabbit = new Rabbit('Кроль');
rabbit.run();
Такое наследование лучше функционального стиля, так как не дублирует методы в каждом объекте.

Кроме того, есть ещё неявное, но очень важное архитектурное отличие.

Зачастую вызов конструктора имеет какие-то побочные эффекты, например влияет на документ. Если конструктор родителя имеет какое-то поведение, которое нужно переопределить в потомке, то в функциональном стиле это невозможно.

Иначе говоря, в функциональном стиле в процессе создания Rabbit нужно обязательно вызывать Animal.apply(this, arguments), чтобы получить методы родителя – и если этот Animal.apply кроме добавления методов говорит: «Му-у-у!», то это проблема:

function Animal() {
  this.walk = function() {
    alert('walk')
  };
  alert( 'Му-у-у!' );
}

function Rabbit() {
  Animal.apply(this, arguments); // как избавиться от мычания, но получить walk?
}
…Которой нет в прототипном подходе, потому что в процессе создания new Rabbit мы вовсе не обязаны вызывать конструктор родителя. Ведь методы находятся в прототипе.

--------------------

2. Какой constructor будет у Rabbit?
function Animal(name) {
  this.name = name;
  this.speed = 0;
}
Animal.prototype.run = function(speed) {
  this.speed += speed;
  alert( this.name + ' бежит, скорость ' + this.speed );
};
function Rabbit(name) {
  this.name = name;
  this.speed = 0;
}
Rabbit.prototype = Object.create(Animal.prototype);
Animal(+)
---EXT
В prototype по умолчанию всегда находится свойство constructor, указывающее на функцию-конструктор. В частности, Rabbit.prototype.constructor == Rabbit. Если мы рассчитываем использовать это свойство, то при замене prototype через Object.create нужно его явно сохранить:
Rabbit.prototype = Object.create(Animal.prototype);
Rabbit.prototype.constructor = Rabbit;

--------------------



41--Проверка класса: "instanceof"
1. Что вернёт alert?
function Rabbit() {}
var rabbit = new Rabbit();
Rabbit.prototype = {};
alert( rabbit instanceof Rabbit );
false (+)
---EXT
Вызов obj instanceof Constructor возвращает true, если объект принадлежит классу Constructor или классу, наследующему от него.
function Rabbit() {}
// создаём объект
var rabbit = new Rabbit();
// проверяем -- этот объект создан Rabbit?
alert( rabbit instanceof Rabbit ); // true, верно

Массив arr принадлежит классу Array, но также и является объектом Object. Это верно, так как массивы наследуют от объектов:

 var arr = [];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
Как это часто бывает в JavaScript, здесь есть ряд тонкостей. Проверка происходит через сравнение прототипов, поэтому в некоторых ситуациях может даже ошибаться!

Алгоритм проверки obj instanceof Constructor:

Получить obj.__proto__
Сравнить obj.__proto__ с Constructor.prototype
Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false).
В проверке rabbit instanceof Rabbit совпадение происходит на первом же шаге этого алгоритма, так как: rabbit.__proto__ == Rabbit.prototype.

А если рассмотреть arr instanceof Object, то совпадение будет найдено на следующем шаге, так как arr.__proto__.__proto__ == Object.prototype.

Забавно, что сама функция-конструктор не участвует в процессе проверки! Важна только цепочка прототипов для проверяемого объекта.
Это может приводить к забавному результату и даже ошибкам в проверке при изменении prototype

--------------------

2. Если массив arr пришёл из iframe, что вернёт проверка arr instanceof Array?
false (+)
---EXT
Оператор instanceof не срабатывает, когда значение приходит из другого окна или фрейма.
Например, массив, который создан в ифрейме и передан родительскому окну – будет массивом в том ифрейме, но не в родительском окне. Проверка instanceof Array в родительском окне вернёт false.
Вообще, у каждого окна и фрейма – своя иерархия объектов и свой window .
Как правило, эта проблема возникает со встроенными объектами, в этом случае используется проверка внутреннего свойства [[Class]]

--------------------



42--Свои ошибки, наследование от Error
1. Что означает запись Error.captureStackTrace(this, PropertyError) в строке 1
function PropertyError(property) {
  Error.call(this, property) ;
  this.name = "PropertyError";

  this.property = property;
  this.message = "Ошибка в свойстве " + property;

  if (Error.captureStackTrace) { 
    Error.captureStackTrace(this, PropertyError); // 1
  } else {
    this.stack = (new Error()).stack;
  }
}
PropertyError.prototype = Object.create(Error.prototype);
Нестандартное расширение V8 (Chrome, Opera, Node.JS), которое позволяет получить стек (+)
---EXT
Реализуем класс PropertyError:

function PropertyError(property) {
  Error.call(this, property) ;
  this.name = "PropertyError";

  this.property = property;
  this.message = "Ошибка в свойстве " + property;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, PropertyError);
  } else {
    this.stack = (new Error()).stack;
  }

}

PropertyError.prototype = Object.create(Error.prototype);
В этом коде вы можете видеть ряд важных деталей, важных именно для ошибок:

name – имя ошибки.
Должно совпадать с именем функции.

message – сообщение об ошибке.
Несмотря на то, что PropertyError наследует от Error (последняя строка), конструктор у неё немного другой. Он принимает не сообщение об ошибке, а название свойства property, ну а сообщение генерируется из него.

В результате в объекте ошибки есть как стандартное свойство message, так и более точное property.

Это частая практика – добавлять в объект ошибки свойства, которых нет в базовых объектах Error, более подробно описывающие ситуацию для данного класса ошибок.

stack – стек вызовов, которые в итоге привели к ошибке.
У встроенных объектов Error это свойство есть автоматически, вот к примеру:

 function f() {
  alert( new Error().stack );
}

f(); // выведет список вложенных вызовов, с номерами строк, где они были сделаны
Если же объект ошибки делаем мы, то «по умолчанию» такого свойства у него не будет. Нам нужно как-то самим узнавать последовательность вложенных вызовов на текущий момент. Однако удобного способа сделать это в JavaScript нет, поэтому мы поступаем хитро и копируем его из нового объекта new Error, который генерируем тут же.

В V8 (Chrome, Opera, Node.JS) есть нестандартное расширение Error.captureStackTrace, которое позволяет получить стек.

Это делает строка из кода выше:

Error.captureStackTrace(this, PropertyError);
Такой вызов записывает в объект this (текущий объект ошибки) стек вызовов, ну а второй аргумент – вообще не обязателен, но если есть, то говорит, что при генерации стека нужно на этой функции остановиться. В результате в стеке будет информация о цепочке вложенных вызовов вплоть до вызова PropertyError.

То есть, будет последовательность вызовов до генерации ошибки, но не включая код самого конструктора ошибки, который, как правило, не интересен. Такое поведение максимально соответствует встроенным ошибкам JavaScript.

Конструктор родителя здесь не обязателен
Обычно, когда мы наследуем, то вызываем конструктор родителя. В данном случае вызов выглядит как Error.call(this, message).

Строго говоря, этот вызов здесь не обязателен. Встроенный конструктор Error ничего полезного не делает, даже свойство this.message (не говоря уже о name и stack) не назначает. Единственный возможный смысл его вызова – он ставит специальное внутреннее свойство [[ErrorData]], которое выводится в toString и позволяет увидеть, что это ошибка. Поэтому по стандарту вызывать конструктор Error при наследовании в таких случаях рекомендовано.

--------------------

2. Что вернёт this.name в PropertyRequiredError
function PropertyError(property) {
  this.name = "PropertyError";
  this.property = property;
  this.message = "Ошибка в свойстве " + property;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, PropertyError);
  } else {
    this.stack = (new Error()).stack;
  }
}
function PropertyRequiredError(property) {
  // вызываем конструктор родителя и передаём текущие аргументы
  PropertyError.apply(this, arguments);
  ...
}
PropertyError(+)
---EXT
Достаточно ли в наследнике просто вызвать конструктор родителя? Увы, нет.

Если так поступить, то свойство this.name будет некорректным, да и Error.captureStackTrace тоже получит неправильную функцию вторым параметром.

Можно ли как-то поправить конструктор родителя, чтобы от него было проще наследовать?

Для этого нужно убрать из него упоминания о конкретном классе PropertyError, чтобы сделать код универсальным. Частично – это возможно. Как мы помним, существует свойство constructor, которое есть в prototype по умолчанию, и которое мы можем намеренно сохранить при наследовании.

Исправим родителя PropertyError для более удобного наследования от него:
function PropertyError(property) {
  this.name = "PropertyError";

  this.property = property;
  this.message = "Ошибка в свойстве " + property;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor); // (*)
  } else {
    this.stack = (new Error()).stack;
  }

}

PropertyError.prototype = Object.create(Error.prototype);
PropertyError.prototype.constructor = PropertyError;
В строке (*) вместо ссылки на PropertyError используем constructor чтобы получить именно конструктор для текущего объекта. В наследнике там будет PropertyRequiredError, как и задумано.

Мы убрали одну жёсткую привязку к PropertyError, но со второй (this.name), увы, сложности. Оно должно содержать имя ошибки, то есть, имя её функции-конструктора. Его можно получить через this.name = this.constructor.name, но в IE11- это работать не будет.

Если поддерживать IE11-, то тут уж придётся в наследнике его записывать вручную.

Полный код для наследника:

function PropertyRequiredError(property) {
  PropertyError.apply(this, arguments);
  this.name = 'PropertyRequiredError';
  this.message = 'Отсутствует свойство ' + property;
}

PropertyRequiredError.prototype = Object.create(PropertyError.prototype);
PropertyRequiredError.prototype.constructor = PropertyRequiredError;

var err = new PropertyRequiredError("age");
// пройдёт проверку
alert( err instanceof PropertyError ); // true
Здесь заодно и message в наследнике было перезаписано на более точное. Если хочется избежать записи и перезаписи, то можно оформить его в виде геттера через Object.defineProperty.

--------------------



@@!BLOCK
43--ES-2015 Примеси
BLOCK!@@

@@!QWESTION
Что такое mixin в js?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Самый простой вариант примеси – это объект с полезными методами, которые мы просто копируем в нужный прототип.
// примесь
var sayHiMixin = {
  sayHi: function() {
    alert("Привет " + this.name);
  },
  sayBye: function() {
    alert("Пока " + this.name);
  }
};

// использование:
function User(name) {
  this.name = name;
}

// передать методы примеси
for(var key in sayHiMixin) User.prototype[key] = sayHiMixin[key];

// User "умеет" sayHi
new User("Вася").sayHi(); // Привет Вася
Как видно из примера, методы примеси активно используют this и предназначены именно для запуска в контексте «объекта-носителя примеси».

Если какие-то из методов примеси не нужны – их можно перезаписать своими после копирования.
EXTENSION!@@



@@!BLOCK
44--ES-2015 Переменные: let и const
BLOCK!@@

@@!QWESTION
Что выдаст alert в строке 1?
if (true) {
  let apples = 10;
  alert(apples);
}
alert(apples); // 1
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ошибка, такой переменной нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Область видимости переменной let – блок {...}.
Как мы помним, переменная, объявленная через var, видна везде в функции.
Переменная, объявленная через let, видна только в рамках блока {...}, в котором объявлена.
Это, в частности, влияет на объявления внутри if, while или for.
EXTENSION!@@



@@!BLOCK
ES-2015 Переменные: let и const
BLOCK!@@

@@!QWESTION
Что выдаст alert?
alert(a);
let a = 5;
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ошибка, нет такой переменной
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Переменная let видна только после объявления. До объявления их вообще нет.
EXTENSION!@@



@@!BLOCK
ES-2015 Переменные: let и const
BLOCK!@@

@@!QWESTION
Что вернёт функция в строке 1?
function makeArmy() {
  let shooters = [];
  for (let i = 0; i < 10; i++) {
    shooters.push(function() {
      alert( i );
    });
  }
  return shooters;
}
var army = makeArmy();
army[5](); // 1
QWESTION!@@

@@!ANSWERS

@@!CORRECT
5
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При использовании в цикле, для каждой итерации создаётся своя переменная.
Каждому повторению цикла соответствует своя независимая переменная let. Если внутри цикла есть вложенные объявления функций, то в замыкании каждой будет та переменная, которая была при соответствующей итерации.
EXTENSION!@@



@@!BLOCK
ES-2015 Переменные: let и const
BLOCK!@@

@@!QWESTION
Чему равна переменная apple?
const apple = 5;
apple = 10;
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ошибка, попытка переназначить константу
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Объявление const задаёт константу, то есть переменную, которую нельзя менять.
EXTENSION!@@



@@!BLOCK
ES-2015 Переменные: let и const
BLOCK!@@

@@!QWESTION
Чему равно свойство user.name?
const user = {
  name: "Вася"
};
user.name = "Петя";
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"Петя"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
EXTENSION!@@



@@!BLOCK
45--ES-2015 Деструктуризация
BLOCK!@@

@@!QWESTION
Что выведет alert?
'use strict';
let [firstName, lastName] = ["Илья", "Кантор"];
alert(lastName);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Кантор
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.
'use strict';
let [firstName, lastName] = ["Илья", "Кантор"];
alert(firstName); // Илья
alert(lastName);  // Кантор
При таком присвоении первое значение массива пойдёт в переменную firstName, второе – в lastName, а последующие (если есть) – будут отброшены.

Ненужные элементы массива также можно отбросить, поставив лишнюю запятую:
'use strict';
// первый и второй элементы не нужны
let [, , title] = "Юлий Цезарь Император Рима".split(" ");
alert(title); // Император
В коде выше первый и второй элементы массива никуда не записались, они были отброшены. Как, впрочем, и все элементы после третьего.
EXTENSION!@@


@@!BLOCK
ES-2015 Деструктуризация
BLOCK!@@

@@!QWESTION
Что выведет alert?
'use strict';
let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
alert(rest): 
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Император,Рима (массив из 2х элементов)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора "..." («spread», троеточие).
Значением rest будет массив из оставшихся элементов массива. Вместо rest можно использовать и другое имя переменной, оператор здесь – троеточие. Оно должно стоять только последним элементом в списке слева.
EXTENSION!@@



@@!BLOCK
ES-2015 Деструктуризация
BLOCK!@@

@@!QWESTION
Как указать значения по умолчанию для переменных?
'use strict';
let [firstName, lastName] = [];
QWESTION!@@

@@!ANSWERS

@@!CORRECT
let [firstName="Гость", lastName="Анонимный"] = [];
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если значений в массиве меньше, чем переменных – ошибки не будет, просто присвоится undefined.
Впрочем, как правило, в таких случаях задают значение по умолчанию. Для этого нужно после переменной использовать символ = со значением, например.
В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций:
'use strict';
function defaultLastName() {
  return Date.now() + '-visitor';
}
// lastName получит значение, соответствующее текущей дате:
let [firstName, lastName=defaultLastName()] = ["Вася"];
alert(firstName); // Вася
alert(lastName);  // 1436...-visitor

Заметим, что вызов функции defaultLastName() для генерации значения по умолчанию будет осуществлён только при необходимости, то есть если значения нет в массиве.
EXTENSION!@@



@@!BLOCK
ES-2015 Деструктуризация
BLOCK!@@

@@!QWESTION
Что означает запись двоеточие в строке 1
'use strict';
let options = {
  title: "Меню",
  width: 100,
  height: 200
};
let {width: w, height: h, title} = options; // 1
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Присвоение свойства объекта в переменную с другим именем
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны «идти».
Базовый синтаксис:
let {var1, var2} = {var1: …, var2: …};
Объект справа – уже существующий, который мы хотим разбить на переменные. А слева – список переменных, в которые нужно соответствующие свойства записать.
'use strict';
let options = {
  title: "Меню",
  width: 100,
  height: 200
};
let {title, width, height} = options;

alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

Как видно, свойства options.title, options.width и options.height автоматически присвоились соответствующим переменным.
Если хочется присвоить свойство объекта в переменную с другим именем, например, чтобы свойство options.width пошло в переменную w, то можно указать соответствие через двоеточие, вот так:
'use strict';
let options = {
  title: "Меню",
  width: 100,
  height: 200
};
let {width: w, height: h, title} = options;
alert(title);  // Меню
alert(w);      // 100
alert(h);      // 200

В примере выше свойство width отправилось в переменную w, свойство height – в переменную h, а title – в переменную с тем же названием.
Если каких-то свойств в объекте нет, можно указать значение по умолчанию через знак равенства =, вот так;
'use strict';
let options = {
  title: "Меню"
};
let {width=100, height=200, title} = options;
alert(title);  // Меню
alert(width);  // 100
alert(height); // 200

Можно и сочетать одновременно двоеточие и равенство:

'use strict';
let options = {
  title: "Меню"
};

let {width:w=100, height:h=200, title} = options;
alert(title);  // Меню
alert(w);      // 100
alert(h);      // 200

А что, если в объекте больше значений, чем переменных? Можно ли куда-то присвоить «остаток», аналогично массивам?
Такой возможности в текущем стандарте нет
EXTENSION!@@




@@!BLOCK
ES-2015 Деструктуризация
BLOCK!@@

@@!QWESTION
Можно ли разбить на переменные объекты или массивы, содержащие вложенные объекты или массивы?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В коде ниже options содержит подобъект и подмассив. В деструктуризации ниже сохраняется та же структура:
 'use strict';
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}
let { title="Меню", size: {width, height}, items: [item1, item2] } = options;
// Меню 100 200 Пончик Пирожное
alert(title);  // Меню
alert(width);  // 100
alert(height); // 200
alert(item1);  // Пончик
alert(item2);  // Пирожное
EXTENSION!@@



@@!BLOCK
46--ES-2015 Функции
BLOCK!@@

@@!QWESTION
Чему равен параметр width?
function showMenu(title = "Заголовок", width = 100, height = 200) {
  alert('title=' + title + ' width=' + width + ' height=' + height);
}
showMenu(undefined, null);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Можно указывать параметры по умолчанию через равенство =.
При передаче любого значения, кроме undefined, включая пустую строку, ноль или null, параметр считается переданным, и значение по умолчанию не используется.
Параметры по умолчанию могут быть не только значениями, но и выражениями.
Заметим, что значение выражений будет вычислено, и соответствующие функции вызваны – лишь в том случае, если это необходимо, то есть когда функция вызвана без параметра.
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Что будет содержать параметр rest?
function showName(firstName, lastName, ...rest) {
  alert(firstName + ' ' + lastName + ' - ' + rest);
}
showName("Юлий", "Цезарь", "Император", "Рима");
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Массив с элементами: "Император", "Рима"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Чтобы получить массив аргументов, можно использовать оператор …
function showName(firstName, lastName, ...rest) {
  alert(firstName + ' ' + lastName + ' - ' + rest);
}
// выведет: Юлий Цезарь - Император,Рима
showName("Юлий", "Цезарь", "Император", "Рима");
В rest попадёт массив всех аргументов, начиная с третьего.
Заметим, что rest – настоящий массив, с методами map, forEach и другими, в отличие от arguments.

Выше мы увидели использование ... для чтения параметров в объявлении функции. Но этот же оператор можно использовать и при вызове функции, для передачи массива параметров как списка, например:
'use strict';
let numbers = [2, 3, 15];
// Оператор ... в вызове передаст массив как список аргументов
// Этот вызов аналогичен Math.max(2, 3, 15)
let max = Math.max(...numbers);
alert( max ); // 15

Формально говоря, эти два вызова делают одно и то же:
Math.max(...numbers);
Math.max.apply(Math, numbers);
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Как исправить строку 1, чтобы параметры по умолчанию применились?
"use strict";
function showMenu({title="Заголовок", width:w=100, height:h=200}) { // 1
  alert(title + ' ' + w + ' ' + h);
}
showMenu(); // Заголовок 100 200
QWESTION!@@

@@!ANSWERS

@@!CORRECT
function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если функция получает объект, то она может его тут же разбить в переменные:
"use strict";
let options = {
  title: "Меню",
  width: 100,
  height: 200
};
function showMenu({title, width, height}) {
  alert(title + ' ' + width + ' ' + height); // Меню 100 200
}
showMenu(options);
Можно использовать и более сложную деструктуризацию, с соответствиями и значениями по умолчанию:
'use strict';
let options = {
  title: "Меню"
};
function showMenu({title="Заголовок", width:w=100, height:h=200}) {
  alert(title + ' ' + w + ' ' + h);
}
// объект options будет разбит на переменные
showMenu(options); // Меню 100 200
Заметим, что в примере выше какой-то аргумент у showMenu() обязательно должен быть, чтобы разбить его на переменные.

Если хочется, чтобы функция могла быть вызвана вообще без аргументов – нужно добавить ей параметр по умолчанию – уже не внутрь деструктуризации, а в самом списке аргументов:
'use strict';
function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) {
  alert(title + ' ' + w + ' ' + h);
}
showMenu(); // Заголовок 100 200
В коде выше весь объект аргументов по умолчанию равен пустому объекту {}, поэтому всегда есть что деструктурировать.
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Какое значение содержит user.sayHi.name?
let user = {
  sayHi: function() {}
};
QWESTION!@@

@@!ANSWERS

@@!CORRECT
sayHi
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В свойстве name у функции находится её имя.
Современный JavaScript старается даже анонимным функциям дать разумные имена.
Например, при создании анонимной функции с одновременной записью в переменную или свойство – её имя равно названию переменной (или свойства).
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Что вернёт вызов в строке 1?
'use strict';
if (true) {
  sayHi();
  function sayHi() {
    alert("Привет!");
  }
}
sayHi(); // 1
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ошибку. Функции не существует
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Что нужно добавить в код функции, чтобы она возвращала строку: hours + ':' + minutes;?
let getTime = () => {
  let date = new Date();
  let hours = date.getHours();
  let minutes = date.getMinutes();
  hours + ':' + minutes;
};
alert( getTime() ); // текущее время
QWESTION!@@

@@!ANSWERS

@@!CORRECT
return hours + ':' + minutes;
CORRECT!@@

@@!WRONG
Ничего. Стрелочные функции и так возвращают результат выполнения выражения.
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Появился новый синтаксис для задания функций через «стрелку» =>.
Его простейший вариант выглядит так:
'use strict';
let inc = x => x+1;
alert( inc(1) ); // 2
Эти две записи – примерно аналогичны:
let inc = x => x+1;
let inc = function(x) { return x + 1; };
Как видно, "x => x+1" – это уже готовая функция. Слева от => находится аргумент, а справа – выражение, которое нужно вернуть.
Если аргументов несколько, то нужно обернуть их в скобки, вот так:
'use strict';
let sum = (a,b) => a + b;
// аналог с function
// let sum = function(a, b) { return a + b; };
alert( sum(1, 2) ); // 3
Если нужно задать функцию без аргументов, то также используются скобки, в этом случае – пустые:
'use strict';
// вызов getTime() будет возвращать текущее время
let getTime = () => new Date().getHours() + ':' + new Date().getMinutes();
alert( getTime() ); // текущее время
Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки {…}:
'use strict';
let getTime = () => {
  let date = new Date();
  let hours = date.getHours();
  let minutes = date.getMinutes();
  return hours + ':' + minutes;
};
alert( getTime() ); // текущее время
Заметим, что как только тело функции оборачивается в {…}, то её результат уже не возвращается автоматически. Такая функция должна делать явный return, как в примере выше, если конечно хочет что-либо возвратить.
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Чему равен this в строке 1
'use strict';
let group = {
  title: "Наш курс",
  students: ["Вася", "Петя", "Даша"],
  showList: function() {
    this.students.forEach(
      student => alert(this.title + ': ' + student) // 1
    )
  }
}
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Внутри функций-стрелок – тот же this, что и снаружи
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Внутри функций-стрелок – тот же this, что и снаружи.
Здесь в forEach была использована функция-стрелка, поэтому this.title в коллбэке – тот же, что и во внешней функции showList. То есть, в данном случае – group.title.

Функции стрелки нельзя запускать с new
Отсутствие у функции-стрелки "своего this" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора, то есть нельзя вызывать через new.

=> это не то же самое, что .bind(this)
Есть тонкое различие между функцией стрелкой => и обычной функцией, у которой вызван .bind(this):

Вызовом .bind(this) мы передаём текущий this, привязывая его к функции.
При => привязки не происходит, так как функция стрелка вообще не имеет контекста this. Поиск this в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.
EXTENSION!@@



@@!BLOCK
ES-2015 Функции
BLOCK!@@

@@!QWESTION
Чему равен результат вызова?
'use strict';

function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
1
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В качестве arguments используются аргументы внешней «обычной» функции.
Вызов showArg() выведет 1, получив его из аргументов функции f. Функция-стрелка здесь вызвана без параметров, но это не важно: arguments всегда берутся из внешней «обычной» функции.
EXTENSION!@@



@@!BLOCK
47--ES-2015 Строки
BLOCK!@@

@@!QWESTION
Что выведет alert?
'use strict';
let apples = 2;
let oranges = 3;
alert(`${apples} + ${oranges} = ${apples + oranges}`);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
2 + 3 = 5
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Строки-шаблоны
Добавлен новый вид кавычек для строк:
let str = `обратные кавычки`;
Основные отличия от двойных "…" и одинарных '…' кавычек:
В них разрешён перевод строки.
Например:
 alert(`моя
  многострочная
  строка`);
Заметим, что пробелы и, собственно, перевод строки также входят в строку, и будут выведены.
Можно вставлять выражения при помощи ${…}.
Например:
 'use strict';
let apples = 2;
let oranges = 3;
alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5
Как видно, при помощи ${…} можно вставлять как и значение переменной ${apples}, так и более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют «интерполяцией».
EXTENSION!@@



@@!BLOCK
ES-2015 Строки
BLOCK!@@

@@!QWESTION
Что хранится в values?
'use strict';
function f(strings, ...values) {
  alert(JSON.stringify(strings));
  alert(JSON.stringify(strings.raw));
  alert(JSON.stringify(values));
}
let apples = 3;
let oranges = 5;
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
QWESTION!@@

@@!ANSWERS

@@!CORRECT
[3,5,8]
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Можно использовать свою функцию шаблонизации для строк.
Название этой функции ставится перед первой обратной кавычкой:
let str = func`моя строка`;
Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров ${…} и сами эти параметры.
Например:
 'use strict';

function f(strings, ...values) {
  alert(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
  alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
  alert(JSON.stringify(values));      // [3,5,8]
}

let apples = 3;
let oranges = 5;

//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
В примере выше видно, что строка разбивается по очереди на части: «кусок строки» – «параметр» – «кусок строки» – «параметр».

Участки строки идут в первый аргумент-массив strings.
У этого массива есть дополнительное свойство strings.raw. В нём находятся строки в точности как в оригинале. Это влияет на спец-символы, например в strings символ \n – это перевод строки, а в strings.raw – это именно два символа \n.
Дальнейший список аргументов функции шаблонизации – это значения выражений в ${...}, в данном случае их три.
Зачем strings.raw?
В отличие от strings, в strings.raw содержатся участки строки в «изначально введённом» виде.

То есть, если в строке находится \n или \u1234 или другое особое сочетание символов, то оно таким и останется.

Это нужно в тех случаях, когда функция шаблонизации хочет произвести обработку полностью самостоятельно (свои спец. символы?). Или же когда обработка спец. символов не нужна – например, строка содержит «обычный текст», набранный непрограммистом без учёта спец. символов.

Как видно, функция имеет доступ ко всему: к выражениям, к участкам текста и даже, через strings.raw – к оригинально введённому тексту без учёта стандартных спец. символов.

Функция шаблонизации может как-то преобразовать строку и вернуть новый результат.
EXTENSION!@@



@@!BLOCK
ES-2015 Строки
BLOCK!@@

@@!QWESTION
В чём отличие методов  String.fromCodePoint и str.codePointAt от String.fromCharCode и str.charCodeAt?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
String.fromCodePoint и str.codePointAt корректно работающие с суррогатными парами
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Внутренняя кодировка строк в JavaScript – это UTF-16, то есть под каждый символ отводится ровно два байта.

Но под всевозможные символы всех языков мира 2 байт не хватает. Поэтому бывает так, что одному символу языка соответствует два юникодных символа (итого 4 байта). Такое сочетание называют «суррогатной парой».

Самый частый пример суррогатной пары, который можно встретить в литературе – это китайские иероглифы.

Заметим, однако, что не всякий китайский иероглиф – суррогатная пара. Существенная часть «основного» юникод-диапазона как раз отдана под китайский язык, поэтому некоторые иероглифы – которые в неё «влезли» – представляются одним юникод-символом, а те, которые не поместились (реже используемые) – двумя.

Например:

 alert( '我'.length ); // 1
alert( '𩷶'.length ); // 2
В тексте выше для первого иероглифа есть отдельный юникод-символ, и поэтому длина строки 1, а для второго используется суррогатная пара. Соответственно, длина – 2.
В современный JavaScript добавлены методы String.fromCodePoint и str.codePointAt – аналоги String.fromCharCode и str.charCodeAt, корректно работающие с суррогатными парами.

Например, charCodeAt считает суррогатную пару двумя разными символами и возвращает код каждой:

 // как будто в строке два разных символа (на самом деле один)
alert( '𝒳'.charCodeAt(0) + ' ' + '𝒳'.charCodeAt(1) ); // 55349 56499
…В то время как codePointAt возвращает его Unicode-код суррогатной пары правильно:

 // один символ с "длинным" (более 2 байт) unicode-кодом
alert( '𝒳'.codePointAt(0) ); // 119987
EXTENSION!@@



@@!BLOCK
ES-2015 Строки
BLOCK!@@

@@!QWESTION
Как записать Unicode-код более 4-х символов?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"\u{NNNNN}"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Есть и ещё синтаксическое улучшение для больших Unicode-кодов.

В JavaScript-строках давно можно вставлять символы по Unicode-коду, вот так:

 alert( "\u2033" ); // ″, символ двойного штриха
Синтаксис: \uNNNN, где NNNN – четырёхзначный шестнадцатиричный код, причём он должен быть ровно четырёхзначным.

«Лишние» цифры уже не войдут в код, например:

 alert( "\u20331" ); // Два символа: символ двойного штриха ″, а затем 1
Чтобы вводить более длинные коды символов, добавили запись \u{NNNNNNNN}, где NNNNNNNN – максимально восьмизначный (но можно и меньше цифр) код.

Например:

 alert( "\u{20331}" ); // 𠌱, китайский иероглиф с этим кодом
EXTENSION!@@



@@!BLOCK
ES-2015 Строки
BLOCK!@@

@@!QWESTION
Символ Ṩ  можно представить как "S\u0307\u0323" и как "S\u0323\u0307". Такое выражение даст false "S\u0307\u0323" == "S\u0323\u0307",
хотя визуально символ один и тот же. Как провести правильное сравнение?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"S\u0307\u0323".normalize() == "S\u0323\u0307".normalize()
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
alert("S\u0307\u0323"); // Ṩ
alert("S\u0323\u0307"); // Ṩ

alert( "S\u0307\u0323" == "S\u0323\u0307" ); // false
В первой строке после основы S идёт сначала значок «верхняя точка», а потом – нижняя, во второй – наоборот. По кодам строки не равны друг другу. Но символ задают один и тот же.

С целью разрешить эту ситуацию, существует юникодная нормализация, при которой строки приводятся к единому, «нормальному», виду.

В современном JavaScript это делает метод str.normalize().

 alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true
Забавно, что в данной конкретной ситуации normalize() приведёт последовательность из трёх символов к одному: \u1e68 (S с двумя точками).

 alert( "S\u0307\u0323".normalize().length ); // 1, нормализовало в один символ
alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
Это, конечно, не всегда так, просто в данном случае оказалось, что именно такой символ в юникоде уже есть. Если добавить значков, то нормализация уже даст несколько символов.

Добавлен ряд полезных методов общего назначения:

str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
str.startsWith(s) – возвращает true, если строка str начинается со строки s.
str.repeat(times) – повторяет строку str times раз.
EXTENSION!@@



@@!BLOCK
48--ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Будет ли работать такая запись?
'use strict';
let name = "Вася";
let isAdmin = true;
let user = {
  name,
  isAdmin
};
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Зачастую у нас есть переменные, например, name и isAdmin, и мы хотим использовать их в объекте.
При объявлении объекта в этом случае достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Будет ли работать такая запись?
'use strict';
let propName = "firstName";
let user = {
  [propName]: "Вася"
};
alert( user.firstName ); // Вася
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В качестве имени свойства можно использовать выражение
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Можно ли с помощью этого сеттера установить прототип Object.setPrototypeOf(obj, newProto)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да, но только если есть поддержка ES-2015
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Как слить объект obj1{} c объектом obj2{}?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Object.assign(obj1, obj2)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Функция Object.assign получает список объектов и копирует в первый target свойства из остальных.
При этом последующие свойства перезаписывают предыдущие.
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Сравниния датут одинаковые результаты?
Object.is(+0, -0);
+0 === -0; 
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Новая функция для проверки равенства значений.

Возвращает true, если значения value1 и value2 равны, иначе false.

Она похожа на обычное строгое равенство ===, но есть отличия:

 // Сравнение +0 и -0
alert( Object.is(+0, -0)); // false
alert( +0 === -0 );        // true

// Сравнение с NaN
alert( Object.is(NaN, NaN) ); // true
alert( NaN === NaN );         // false
Отличия эти в большинстве ситуаций некритичны, так что непохоже, чтобы эта функция вытеснила обычную проверку ===. Что интересно – этот алгоритм сравнения, который называется SameValue, применяется во внутренних реализациях различных методов современного стандарта.
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Что выведет Alert?
'use strict';
let methodName = "getFirstName";
let user = {
  [methodName]() {  // вместо [methodName]: function() {
    return "Вася";
  }
};
alert( user.getFirstName() );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Вася
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Долгое время в JavaScript термин «метод объекта» был просто альтернативным названием для свойства-функции.
Теперь это уже не так. Добавлены именно «методы объекта», которые, по сути, являются свойствами-функциями, привязанными к объекту.
Их особенности:
Более короткий синтаксис объявления.
Наличие в методах специального внутреннего свойства [[HomeObject]] («домашний объект»), ссылающегося на объект, которому метод принадлежит. Мы посмотрим его использование чуть дальше.
Для объявления метода вместо записи "prop: function() {…}" нужно написать просто "prop() { … }".
'use strict';
let name = "Вася";
let user = {
  name,
  // вместо "sayHi: function() {...}" пишем "sayHi() {...}"
  sayHi() {
    alert(this.name);
  }
};
user.sayHi(); // Вася
Как видно, для создания метода нужно писать меньше букв. Что же касается вызова – он ничем не отличается от обычной функции. На данном этапе можно считать, что «метод» – это просто сокращённый синтаксис для свойства-функции. Дополнительные возможности, которые даёт такое объявление, мы рассмотрим позже.
Также методами станут объявления геттеров get prop() и сеттеров set prop():
 'use strict';
let name = "Вася", surname="Петров";
let user = {
  name,
  surname,
  get fullName() {
    return `${name} ${surname}`;
  }
};
alert( user.fullName ); // Вася Петров
EXTENSION!@@



@@!BLOCK
ES-2015 Объекты и прототипы
BLOCK!@@

@@!QWESTION
Почему первый код работает, а второй — нет?
// 1
'use strict';
let animal = {
  walk() {
    alert("I'm walking");
  }
};
let rabbit = {
  __proto__: animal,
  walk() {
    alert(super.walk);
    super.walk();
  }
};
rabbit.walk();

// 2
'use strict';
let animal = {
  walk() {
    alert("I'm walking");
  }
};
let rabbit = {
  __proto__: animal,
  walk: function() {
    super.walk();
  }
};
rabbit.walk();
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Во втором коде обычная функция не имеет [[HomeObject]]
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В ES-2015 появилось новое ключевое слово super. Оно предназначено только для использования в методах объекта.

Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа.

Например, в коде ниже rabbit наследует от animal.

Вызов super.walk() из метода объекта rabbit обращается к animal.walk():

 












'use strict';

let animal = {
  walk() {
    alert("I'm walking");
  }
};

let rabbit = {
  __proto__: animal,
  walk() {
    alert(super.walk); // walk() { … }
    super.walk(); // I'm walking
  }
};

rabbit.walk();
Как правило, это используется в классах, которые мы рассмотрим в следующем разделе, но важно понимать, что «классы» здесь на самом деле ни при чём. Свойство super работает через прототип, на уровне методов объекта.

При обращении через super используется [[HomeObject]] текущего метода, и от него берётся __proto__. Поэтому super работает только внутри методов.

В частности, если переписать этот код, оформив rabbit.walk как обычное свойство-функцию, то будет ошибка:

 












'use strict';

let animal = {
  walk() {
    alert("I'm walking");
  }
};

let rabbit = {
  __proto__: animal,
  walk: function() { // Надо: walk() {
    super.walk(); // Будет ошибка!
  }
};

rabbit.walk();
Ошибка возникнет, так как rabbit.walk теперь обычная функция и не имеет [[HomeObject]]. Поэтому в ней не работает super.
Исключением из этого правила являются функции-стрелки. В них используется super внешней функции. Например, здесь функция-стрелка в setTimeout берёт внешний super:
'use strict';
let animal = {
  walk() {
    alert("I'm walking");
  }
};
let rabbit = {
  __proto__: animal,
  walk() {
    setTimeout(() => super.walk()); // I'm walking
  }
};
rabbit.walk();
Ранее мы говорили о том, что у функций-стрелок нет своего this, arguments: они используют те, которые во внешней функции. Теперь к этому списку добавился ещё и super.
Свойство [[HomeObject]] – не изменяемое
При создании метода – он привязан к своему объекту навсегда. Технически можно даже скопировать его и запустить отдельно, и super продолжит работать:
'use strict';
let animal = {
  walk() { alert("I'm walking"); }
};
let rabbit = {
  __proto__: animal,
  walk() {
    super.walk();
  }
};
let walk = rabbit.walk; // скопируем метод в переменную
walk(); // вызовет animal.walk()
// I'm walking
В примере выше метод walk() запускается отдельно от объекта, но всё равно, благодаря [[HomeObject]], сохраняется доступ к его прототипу через super.

Это – скорее технический момент, так как методы объекта, всё же, предназначены для вызова в контексте этого объекта. В частности, правила для this в методах – те же, что и для обычных функций. В примере выше при вызове walk() без объекта this будет undefined.
EXTENSION!@@



@@!BLOCK
49--ES-2015 Классы
BLOCK!@@

@@!QWESTION
Будет ли виден class за пределами блока, в котором объявлен?
'use strict';
{
  class User {
    constructor(name) {
      this.name = name;
    }
    sayHi() {
      alert(this.name);
    }
  }
}
let user = new User("Вася");
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синтаксис для классов выглядит так:
class Название [extends Родитель]  {
  constructor
  методы
}
Например:
 'use strict';
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

let user = new User("Вася");
user.sayHi(); // Вася
Функция constructor запускается при создании new User, остальные методы записываются в User.prototype.

Это объявление примерно аналогично такому:

function User(name) {
  this.name = name;
}

User.prototype.sayHi = function() {
  alert(this.name);
};
В обоих случаях new User будет создавать объекты. Метод sayHi также в обоих случаях находится в прототипе.

Но при объявлении через class есть и ряд отличий:

User нельзя вызывать без new, будет ошибка.
Объявление класса с точки зрения области видимости ведёт себя как let. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).
Методы, объявленные внутри class, также имеют ряд особенностей:

Метод sayHi является именно методом, то есть имеет доступ к super.
Все методы класса работают в строгом режиме use strict, даже если он не указан.
Все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет.

- Классы можно объявлять как в основном потоке кода, так и «инлайн», по аналогии с Function Declaration и Expression.
- В объявлении классов можно использовать методы, геттеры/сеттеры и вычислимые названия методов.
- При наследовании вызов конструктора родителя осуществляется через super(...args), вызов родительских методов – через super.method(...args).
EXTENSION!@@



@@!BLOCK
ES-2015 Классы
BLOCK!@@

@@!QWESTION
Позволяет ли class задавать свойства-значения?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
class не позволяет задавать свойства-значения
В синтаксисе классов, как мы видели выше, можно создавать методы. Они будут записаны в прототип, как например User.prototype.sayHi.
Однако, нет возможности задать в прототипе обычное значение (не функцию), такое как User.prototype.key = "value".
Конечно, никто не мешает после объявления класса в прототип дописать подобные свойства, однако предполагается, что в прототипе должны быть только методы.
Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.

'use strict';
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  // геттер
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  // сеттер
  set fullName(newValue) {
    [this.firstName, this.lastName] = newValue.split(' ');
  }
  // вычисляемое название метода
  ["test".toUpperCase()]() {
    alert("PASSED!");
  }
};
let user = new User("Вася", "Пупков");
alert( user.fullName ); // Вася Пупков
user.fullName = "Иван Петров";
alert( user.fullName ); // Иван Петров
user.TEST(); // PASSED!
EXTENSION!@@



@@!BLOCK
ES-2015 Классы
BLOCK!@@

@@!QWESTION
Как задат статическое свойство для class?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
С помощью ключевого слова static
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Класс, как и функция, является объектом. Статические свойства класса User – это свойства непосредственно User, то есть доступные из него «через точку».
Для их объявления используется ключевое слово static.
Например:
'use strict';
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  static createGuest() {
    return new User("Гость", "Сайта");
  }
};
let user = User.createGuest();
alert( user.firstName ); // Гость
alert( User.createGuest ); // createGuest ... (функция)
Как правило, они используются для операций, не требующих наличия объекта, например – для фабричных, как в примере выше, то есть как альтернативные варианты конструктора. Или же, можно добавить метод User.compare, который будет сравнивать двух пользователей для целей сортировки.
EXTENSION!@@



@@!BLOCK
ES-2015 Классы
BLOCK!@@

@@!QWESTION
Как классу class Rabbit наследовать от class Animal?

QWESTION!@@

@@!ANSWERS

@@!CORRECT
class Rabbit extends Animal {
  ...
}
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синтаксис:
class Child extends Parent {
  ...
}
Посмотрим как это выглядит на практике. В примере ниже объявлено два класса: Animal и наследующий от него Rabbit:
'use strict';

class Animal {
  constructor(name) {
    this.name = name;
  }
  walk() {
    alert("I walk: " + this.name);
  }
}
class Rabbit extends Animal {
  walk() {
    super.walk();
    alert("...and jump!");
  }
}
new Rabbit("Вася").walk();
// I walk: Вася
// and jump!
Как видим, в new Rabbit доступны как свои методы, так и (через super) методы родителя.
Это потому, что при наследовании через extends формируется стандартная цепочка прототипов: методы Rabbit находятся в Rabbit.prototype, методы Animal – в Animal.prototype, и они связаны через __proto__:

 'use strict';

class Animal { }
class Rabbit extends Animal { }

alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true
Как видно из примера выше, методы родителя (walk) можно переопределить в наследнике. При этом для обращения к родительскому методу используют super.walk().

С конструктором – немного особая история.
Конструктор constructor родителя наследуется автоматически. То есть, если в потомке не указан свой constructor, то используется родительский. В примере выше Rabbit, таким образом, использует constructor от Animal.
Если же у потомка свой constructor, то, чтобы в нём вызвать конструктор родителя – используется синтаксис super() с аргументами для родителя.
Например, вызовем конструктор Animal в Rabbit:
'use strict';

class Animal {
  constructor(name) {
    this.name = name;
  }
  walk() {
    alert("I walk: " + this.name);
  }
}
class Rabbit extends Animal {
  constructor() {
    // вызвать конструктор Animal с аргументом "Кроль"
    super("Кроль"); // то же, что и Animal.call(this, "Кроль")
  }
}
new Rabbit().walk(); // I walk: Кроль
Для такого вызова есть небольшие ограничения:

Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализирует this.
Второе ограничение выглядит несколько странно, поэтому проиллюстрируем его примером:
'use strict';

class Animal {
  constructor(name) {
    this.name = name;
  }
}
class Rabbit extends Animal {
  constructor() {
    alert(this); // ошибка, this не определён!
    // обязаны вызвать super() до обращения к this
    super();
    // а вот здесь уже можно использовать this
  }
}
new Rabbit();
EXTENSION!@@



@@!BLOCK
50--ES-2015 Symbols
BLOCK!@@

@@!QWESTION
Что возвращает метод Object.getOwnPropertySymbols(obj)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Все символы объекта obj
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синтаксис:

let sym = Symbol();
Обратим внимание, не new Symbol, а просто Symbol, так как это – примитив.
У символов есть и соответствующий typeof:
 'use strict';
let sym = Symbol();
alert( typeof sym ); // symbol
Каждый символ – уникален. У функции Symbol есть необязательный аргумент «имя символа». Его можно использовать для описания символа, в целях отладки:
 'use strict';
let sym = Symbol("name");
alert( sym.toString() ); // Symbol(name)
…Но при этом, если у двух символов одинаковое имя, то это не значит, что они равны:
 alert( Symbol("name") == Symbol("name") ); // false
Если хочется из разных частей программы использовать именно одинаковый символ, то можно передавать между ними объект символа или же – использовать «глобальные символы» и «реестр глобальных символов», которые мы рассмотрим далее.

Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.
Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).
Например:
 'use strict';
// создание символа в реестре
let name = Symbol.for("name");
// символ уже есть, чтение из реестра
alert( Symbol.for("name") == name ); // true
Таким образом, можно из разных частей программы, обратившись к реестру, получить единый глобальный символ с именем "name".

У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym). Он позволяет получить по глобальному символу его имя:
 'use strict';
// создание символа в реестре
let test = Symbol.for("name");
// получение имени символа
alert( Symbol.keyFor(test) ); // name
Symbol.keyFor возвращает undefined, если символ не глобальный
Заметим, что Symbol.keyFor работает только для глобальных символов, для остальных будет возвращено undefined:
 'use strict';
alert( Symbol.keyFor(Symbol.for("name")) ); // name, глобальный
alert( Symbol.keyFor(Symbol("name2")) ); // undefined, обычный символ
Таким образом, имя символа, если этот символ не глобальный, не имеет особого применения, оно полезно лишь в целях вывода и отладки.

Допустим, в новом стандарте нам надо добавить к объекту «особый» функционал, например, функцию, которая задаёт преобразование объекта к примитиву. Как obj.toString, но для преобразования в примитивы.
Мы ведь не можем просто сказать, что «свойство obj.toPrimitive теперь будет задавать преобразование к примитиву и автоматически вызываться в таких-то ситуациях». Это опасно. Мы не можем так просто взять и придать особый смысл свойству. Мало ли, вполне возможно, что свойство с таким именем уже используется в существующем коде, и если сделать его особым, то он сломается.
Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.
Поэтому ввели целый тип «символы». Их можно использовать для задания таких свойств, так как они:
а) уникальны,
б) не участвуют в циклах,
в) заведомо не сломают старый код, который о них слыхом не слыхивал.

- Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.
- Все символы уникальны. Символы с одинаковым именем не равны друг другу.
- Существует глобальный реестр символов, доступных через метод Symbol.for("name"). Для глобального символа можно получить имя вызовом Symbol.keyFor(sym).
EXTENSION!@@



@@!BLOCK
51--ES-2015 Итераторы
BLOCK!@@

@@!QWESTION
Что хранится в iterator?
'use strict';
let str = "Hello";
let iterator = str[Symbol.iterator]();
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Объект итератора
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
- Итератор – объект, предназначенный для перебора другого объекта.
- У итератора должен быть метод next(), возвращающий объект {done: Boolean, value: any}, где value – очередное значение, а done: true в конце.
- Метод Symbol.iterator предназначен для получения итератора из объекта. Цикл for..of делает это автоматически, но можно и вызвать его напрямую.
- В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством Symbol.iterator) объекты, например оператор spread ....
- Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.

'use strict';
let arr = [1, 2, 3]; // массив — пример итерируемого объекта
for (let value of arr) {
  alert(value); // 1, затем 2, затем 3
}

Допустим, у нас есть некий объект, который надо «умным способом» перебрать.
Например, range – диапазон чисел от from до to, и мы хотим, чтобы for (let num of range) «перебирал» этот объект. При этом под перебором мы подразумеваем перечисление чисел от from до to.
Объект range без итератора:
let range = {
  from: 1,
  to: 5
};

// хотим сделать перебор
// for (let num of range) ...
Для возможности использовать объект в for..of нужно создать в нём свойство с названием Symbol.iterator (системный символ).
При вызове метода Symbol.iterator перебираемый объект должен возвращать другой объект («итератор»), который умеет осуществлять перебор.
По стандарту у такого объекта должен быть метод next(), который при каждом вызове возвращает очередное значение и проверяет, окончен ли перебор.
В коде это выглядит следующим образом:

 'use strict';

let range = {
  from: 1,
  to: 5
}

// сделаем объект range итерируемым
range[Symbol.iterator] = function() {

  let current = this.from;
  let last = this.to;

  // метод должен вернуть объект с методом next()
  return {
    next() {
      if (current <= last) {
        return {
          done: false,
          value: current++
        };
      } else {
        return {
          done: true
        };
      }
    }

  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
Как видно из кода выше, здесь имеет место разделение сущностей:
Перебираемый объект range сам не реализует методы для своего перебора.
Для этого создаётся другой объект, который хранит текущее состояние перебора и возвращает значение. Этот объект называется итератором и возвращается при вызове метода range[Symbol.iterator].
У итератора должен быть метод next(), который при каждом вызове возвращает объект со свойствами:
value – очередное значение,
done – равно false если есть ещё значения, и true – в конце.
Конструкция for..of в начале своего выполнения автоматически вызывает Symbol.iterator(), получает итератор и далее вызывает метод next() до получения done: true. Такова внутренняя механика. Внешний код при переборе через for..of видит только значения.
EXTENSION!@@



@@!BLOCK
52--ES-2015 Set, Map, WeakSet и WeakMap
BLOCK!@@

@@!QWESTION
Что выведёт alert`ы в строках 1 и 2?
let map = new Map();
map.set('1', 'str1');
map.set(1, 'num1');
map.set(true, 'bool1');
alert( map.get(1)   ); // 1 '
alert( map.get('1') ); // 2
QWESTION!@@

@@!ANSWERS

@@!CORRECT
num1', 'str1'
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Map – коллекция для хранения записей вида ключ:значение.
В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение
Для сохранения и чтения значений используются методы get и set. И ключи и значения сохраняются «как есть», без преобразований типов.
Свойство map.size хранит общее количество записей в map.
Метод set можно чейнить:
map
  .set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
При создании Map можно сразу инициализировать списком значений.
Объект map с тремя ключами, как и в примере выше:
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
EXTENSION!@@



@@!BLOCK
ES-2015 Set, Map, WeakSet и WeakMap
BLOCK!@@

@@!QWESTION
Что выведет alert?
'use strict';
let user = { name: "Вася" };
let visitsCountMap = new Map();
visitsCountMap.set(user, 123);
alert( visitsCountMap.get(user) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
123
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В качестве ключей map можно использовать и объекты
Использование объектов в качестве ключей – как раз тот случай, когда Map сложно заменить обычными объектами Object. Ведь для обычных объектов ключ может быть только строкой.
Как map сравнивает ключи
Для проверки значений на эквивалентность используется алгоритм SameValueZero. Он аналогичен строгому равенству ===, отличие – в том, что NaN считается равным NaN. Поэтому значение NaN также может быть использовано в качестве ключа.
Этот алгоритм нельзя изменять или задавать свою функцию сравнения.
Методы для удаления записей:
- map.delete(key) удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.
- map.clear() – удаляет все записи, очищает map.
Для проверки существования ключа:
- map.has(key) – возвращает true, если ключ есть, иначе false.
EXTENSION!@@



@@!BLOCK
ES-2015 Set, Map, WeakSet и WeakMap
BLOCK!@@

@@!QWESTION
Как провести итерацию в map по ключам?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
С помощью map.keys()
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для итерации по map используется один из трёх методов:
map.keys() – возвращает итерируемый объект для ключей,
map.values() – возвращает итерируемый объект для значений,
map.entries() – возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of.
Например:
 'use strict';
let recipeMap = new Map([
  ['огурцов',   '500 гр'],
  ['помидоров', '350 гр'],
  ['сметаны',   '50 гр']
]);
// цикл по ключам
for(let fruit of recipeMap.keys()) {
  alert(fruit); // огурцов, помидоров, сметаны
}
// цикл по значениям
for(let amount of recipeMap.values()) {
  alert(amount); // 500 гр, 350 гр, 50 гр
}
// цикл по записям [ключ,значение]
for(let entry of recipeMap) { // то же что и recipeMap.entries()
  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения
}
Перебор идёт в том же порядке, что и вставка
Перебор осуществляется в порядке вставки. Объекты Map гарантируют это, в отличие от обычных объектов Object.
Кроме того, у Map есть стандартный метод forEach, аналогичный встроенному в массивы:
'use strict';
let recipeMap = new Map([
  ['огурцов',   '500 гр'],
  ['помидоров', '350 гр'],
  ['сметаны',   '50 гр']
]);
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // огурцов: 500 гр, и т.д.
});
EXTENSION!@@



@@!BLOCK
ES-2015 Set, Map, WeakSet и WeakMap
BLOCK!@@

@@!QWESTION
Чему равно значение set.size? 
'use strict';
let set = new Set();
let vasya = {name: "Вася"};
let petya = {name: "Петя"};
let dasha = {name: "Даша"};
set.add(vasya);
set.add(petya);
set.add(dasha);
set.add(vasya);
set.add(petya);
alert( set.size );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
3
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.
Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз.
В примере выше многократные добавления одного и того же объекта в set не создают лишних копий.
Альтернатива Set – это массивы с поиском дубликата при каждом добавлении, но они гораздо хуже по производительности. Или можно использовать обычные объекты, где в качестве ключа выступает какой-нибудь уникальный идентификатор посетителя. Но это менее удобно, чем простой и наглядный Set.
Основные методы:
set.add(item) – добавляет в коллекцию item, возвращает set (чейнится).
set.delete(item) – удаляет item из коллекции, возвращает true, если он там был, иначе false.
set.has(item) – возвращает true, если item есть в коллекции, иначе false.
set.clear() – очищает set.
Перебор Set осуществляется через forEach или for..of аналогично Map:
'use strict';
let set = new Set(["апельсины", "яблоки", "бананы"]);
// то же, что: for(let value of set)
set.forEach((value, valueAgain, set) => {
  alert(value); // апельсины, затем яблоки, затем бананы
});
Заметим, что в Set у функции в .forEach три аргумента: значение, ещё раз значение, и затем сам перебираемый объект set. При этом значение повторяется в аргументах два раза.
Так сделано для совместимости с Map, где у .forEach-функции также три аргумента. Но в Set первые два всегда совпадают и содержат очередное значение множества.
EXTENSION!@@



@@!BLOCK
ES-2015 Set, Map, WeakSet и WeakMap
BLOCK!@@

@@!QWESTION
Допустима ли подобная запись weakMap.set('Katya', 4); ?
QWESTION!@@

@@!ANSWERS

@@!CORRECT

CORRECT!@@

@@!WRONG
Нет, она приведёт к ошибке TypeError: "Katya" is not a non-null object
WRONG!@@

ANSWERS!@@

@@!EXTENSION
WeakSet – особый вид Set не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.
То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти.
Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.
Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует.
Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент.

Например:
// текущие активные пользователи
let activeUsers = [
  {name: "Вася"},
  {name: "Петя"},
  {name: "Маша"}
];
// вспомогательная информация о них,
// которая напрямую не входит в объект юзера,
// и потому хранится отдельно
let weakMap = new WeakMap();
weakMap.set(activeUsers[0], 1);
weakMap.set(activeUsers[1], 2);
weakMap.set(activeUsers[2], 3);
weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object
alert( weakMap.get(activeUsers[0]) ); // 1
activeUsers.splice(0, 1); // Вася более не активный пользователь
// weakMap теперь содержит только 2 элемента
activeUsers.splice(0, 1); // Петя более не активный пользователь
// weakMap теперь содержит только 1 элемент
Таким образом, WeakMap избавляет нас от необходимости вручную удалять вспомогательные данные, когда удалён основной объект.
У WeakMap есть ряд ограничений:
Только объекты в качестве ключей.
Нет свойства size.
Нельзя перебрать элементы итератором или forEach.
Нет метода clear().
Иными словами, WeakMap работает только на запись (set, delete) и чтение (get, has) элементов по конкретному ключу, а не как полноценная коллекция. Нельзя вывести всё содержимое WeakMap, нет соответствующих методов.
Это связано с тем, что содержимое WeakMap может быть модифицировано сборщиком мусора в любой момент, независимо от программиста. Сборщик мусора работает сам по себе. Он не гарантирует, что очистит объект сразу же, когда это стало возможным. В равной степени он не гарантирует и обратное. Нет какого-то конкретного момента, когда такая очистка точно произойдёт – это определяется внутренними алгоритмами сборщика и его сведениями о системе.
Поэтому содержимое WeakMap в произвольный момент, строго говоря, не определено. Может быть, сборщик мусора уже удалил какие-то записи, а может и нет. С этим, а также с требованиями к эффективной реализации WeakMap, и связано отсутствие методов, осуществляющих доступ ко всем записям.
То же самое относится и к WeakSet: можно добавлять элементы, проверять их наличие, но нельзя получить их список и даже узнать количество.
Эти ограничения могут показаться неудобными, но по сути они не мешают WeakMap/WeakSet выполнять свою основную задачу – быть «вторичным» хранилищем данных для объектов, актуальный список которых (и сами они) хранятся в каком-то другом месте.
EXTENSION!@@



@@!BLOCK
53--Дерево DOM
BLOCK!@@

@@!QWESTION
Как браузер "исправит" этот код?
<table id="table">
  <tr><td>1</td></tr>
</table>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Добавит тег tbody перед тегом table
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
По стандарту DOM они обязаны иметь <tbody>
При чтении неверного HTML браузер автоматически корректирует его для показа и при построении DOM.
В частности, всегда будет верхний тег <html>. Даже если в тексте нет – в DOM он будет, браузер создаст его самостоятельно.
То же самое касается и тега <body>.
Например, если файл состоит из одного слова "Привет", то браузер автоматически обернёт его в <html> и <body>.
При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.
EXTENSION!@@



@@!BLOCK
54--Навигация по DOM-элементам
BLOCK!@@

@@!QWESTION
Есть ли разница между document.body.childNodes и document.body.children
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые, children – только дочерние узлы-элементы, то есть соответствующие тегам.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Доступ к DOM начинается с объекта document. Из него можно добраться до любых узлов.
Так выглядят основные ссылки, по которым можно переходить между узлами DOM:
https://learn.javascript.ru/article/traversing-dom/dom-links@2x.png

https://learn.javascript.ru/article/traversing-dom/dom-links-elements@2x.png
Навигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в childNodes сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть.
Но для большинства задач текстовые узлы нам не интересны.
EXTENSION!@@



@@!BLOCK
55--Дерево DOM
BLOCK!@@

@@!QWESTION
Как получить доступ к послелнему элементу, не обязятельно тегу
QWESTION!@@

@@!ANSWERS

@@!CORRECT
lastChild
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Список детей – только для чтения!
Скажем больше – все навигационные свойства, которые перечислены в этой главе – только для чтения. Нельзя просто заменить элемент присвоением childNodes[i] = ....
Изменение DOM осуществляется другими методами, которые мы рассмотрим далее, все навигационные ссылки при этом обновляются автоматически.
Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые.
Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу.
EXTENSION!@@



@@!BLOCK
Дерево DOM
BLOCK!@@

@@!QWESTION
Коллекция и массив — это синонимы?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
DOM-коллекции, такие как childNodes и другие, которые мы увидим далее, не являются JavaScript-массивами.
В них нет методов массивов.
Сделать массив из коллекции:
Применить метод массива через call/apply:
var elems = document.documentElement.childNodes;
[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
});

При помощи Array.prototype.slice сделать из коллекции массив.
Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr с индексами от a до b-1 включительно. Если же вызвать его без аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr.
Это работает и для коллекции:
var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив
elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});

Нельзя перебирать коллекцию через for..in
Ранее мы говорили, что не рекомендуется использовать для перебора массива цикл for..in.
Цикл for..in выведет не только ожидаемые индексы, по которым лежат узлы в коллекции, но и свойство length (в коллекции оно enumerable), а также функцию item(n) – она никогда не используется, возвращает n-й элемент коллекции, проще обратиться по индексу [n].
EXTENSION!@@



@@!BLOCK
Дерево DOM
BLOCK!@@

@@!QWESTION
Как перейти к следующему элементу-тегу?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
nextElementSibling
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:
children – только дочерние узлы-элементы, то есть соответствующие тегам.
firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.
previousElementSibling, nextElementSibling – соседи-элементы.
parentElement – родитель-элемент.

Зачем parentElement? Неужели бывают родители не-элементы?
Свойство elem.parentNode возвращает родитель элемента.
Оно всегда равно parentElement, кроме одного исключения:
alert( document.documentElement.parentNode ); // document
alert( document.documentElement.parentElement ); // null
Иногда это имеет значение, если хочется перебрать всех предков и вызвать какой-то метод, а на документе его нет.
EXTENSION!@@



@@!BLOCK
Дерево DOM
BLOCK!@@

@@!QWESTION
Как получить коллекцию ячеек TD/TH?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
tr.cells
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
TABLE
table.rows – коллекция строк TR таблицы.
table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.
THEAD/TFOOT/TBODY
tbody.rows – коллекция строк TR секции.
TR
tr.cells – коллекция ячеек TD/TH
tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
tr.rowIndex – номер строки в таблице
TD/TH
td.cellIndex – номер ячейки в строке
EXTENSION!@@



@@!BLOCK
Дерево DOM
BLOCK!@@

@@!QWESTION
Как получить коллекцию строк?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
table.rows
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
TABLE
table.rows – коллекция строк TR таблицы.
table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.
THEAD/TFOOT/TBODY
tbody.rows – коллекция строк TR секции.
TR
tr.cells – коллекция ячеек TD/TH
tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
tr.rowIndex – номер строки в таблице
TD/TH
td.cellIndex – номер ячейки в строке
EXTENSION!@@



@@!BLOCK
Дерево DOM
BLOCK!@@

@@!QWESTION
Как получить номер ячейки в строке?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
td.cellIndex
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
TABLE
table.rows – коллекция строк TR таблицы.
table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.
table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.
THEAD/TFOOT/TBODY
tbody.rows – коллекция строк TR секции.
TR
tr.cells – коллекция ячеек TD/TH
tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY
tr.rowIndex – номер строки в таблице
TD/TH
td.cellIndex – номер ячейки в строке
EXTENSION!@@



@@!BLOCK
56--Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Верна ли запись?
var elem = table.getElementById('content');
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
getElementById существует только в контексте document.
По стандарту значение id должно быть уникально, то есть в документе может быть только один элемент с данным id. И именно он будет возвращён.
Если в документе есть несколько элементов с уникальным id, то поведение неопределено. То есть, нет гарантии, что браузер вернёт именно первый или последний – вернёт случайным образом.
Поэтому стараются следовать правилу уникальности id.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Как получить элемент по тегу?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.getElementsByTagName()
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод elem.getElementsByTagName(tag) ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка.
Обратим внимание: в отличие от getElementById, который существует только в контексте document, метод getElementsByTagName может искать внутри любого элемента.
Можно получить всех потомков, передав звездочку '*' вместо тега:
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Верна ли запись?
document.getElementsByTagName('input').value = 5;
QWESTION!@@

@@!ANSWERS

@@!CORRECT
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Возвращается коллекция, а не элемент
То есть, вместо элемента присваивают значение коллекции. Работать такое не будет.
Коллекцию нужно или перебрать в цикле или получить элемент по номеру и уже ему присваивать value, например так:
// работает
document.getElementsByTagName('input')[0].value = 5;

*****
Внутреннее устройство поисковых методов
Эта глава не обязательна при первом чтении учебника.

Если вы хотите действительно глубоко понимать, что происходит при поиске, то посмотрите эту главу. Если нет – её можно пропустить.

Несмотря на схожесть в синтаксисе, поисковые методы get* и querySelector* внутри устроены очень по-разному.

document.getElementById(id)
Браузер поддерживает у себя внутреннее соответствие id -> элемент. Поэтому нужный элемент возвращается сразу. Это очень быстро.

elem.querySelector(query), elem.querySelectorAll(query)
Чтобы найти элементы, удовлетворяющие поисковому запросу, браузер не использует никаких сложных структур данных.

Он просто перебирает все подэлементы внутри элемента elem(или по всему документу, если вызов в контексте документа) и проверяет каждый элемент на соответствие запросу query.

Вызов querySelector прекращает перебор после первого же найденного элемента, а querySelectorAll собирает найденные элементы в «псевдомассив»: внутреннюю структуру данных, по сути аналогичную массиву JavaScript.

Этот перебор происходит очень быстро, так как осуществляется непосредственно движком браузера, а не JavaScript-кодом.

Оптимизации:

В случае поиска по ID: elem.querySelector('#id'), большинство браузеров оптимизируют поиск, используя вызов getElementById.
Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.
elem.getElementsBy*(…)
Результаты поиска getElementsBy* – живые! При изменении документа – изменяется и результат запроса.

Например, найдём все div при помощи querySelectorAll и getElementsByTagName, а потом изменим документ:
<div></div>
<script>
  var resultGet = document.getElementsByTagName('div');
  var resultQuery = document.querySelectorAll('div');

  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 1

  document.body.innerHTML = ''; // удалить всё содержимое BODY

  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 0
</script>
Как видно, длина коллекции, найденной через querySelectorAll, осталась прежней. А длина коллекции, возвращённой getElementsByTagName, изменилась.

Дело в том, что результат запросов getElementsBy* – это не массив, а специальный объект, имеющий тип NodeList или HTMLCollection. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а «живой поисковой запрос».

Собственно поиск выполняется только при обращении к элементам коллекции или к её длине.

Алгоритмы getElementsBy*
Поиск getElementsBy* наиболее сложно сделать эффективно, так как его результат – «живая» коллекция, она должна быть всегда актуальной для текущего состояния документа.
var elems = document.getElementsByTagName('div');
alert( elems[0] );
// изменили документ
alert( elems[0] ); // результат может быть уже другой
Можно искать заново при каждой попытке получить элемент из elems. Тогда результат будет всегда актуален, но поиск будет работать уж слишком медленно. Да и зачем? Ведь, скорее всего, документ не поменялся.

Чтобы производительность getElementsBy* была достаточно хорошей, активно используется кеширование результатов поиска.

Для этого есть два основных способа: назовём их условно «Способ Firefox» (Firefox, IE) и «Способ WebKit» (Chrome, Safari, Opera).

Для примера, рассмотрим поиск в произвольном документе, в котором есть 1000 элементов div.

Посмотрим, как будут работать браузеры, если нужно выполнить следующий код:

// вместо document может быть любой элемент
var elems = document.getElementsByTagName('div');
alert( elems[0] );
alert( elems[995] );
alert( elems[500] );
alert( elems.length );
Способ Firefox
Перебрать подэлементы document.body в порядке их появления в поддереве. Запоминать все найденные элементы во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска.

Разбор действий браузера при выполнении кода выше:

Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает все найденные.
Возвращает ранее запомненный элемент с индексом 500, без дополнительного поиска!
Продолжает обход поддерева с элемента, на котором остановился (995) и до конца. Запоминает найденные элементы и возвращает их количество.
Способ WebKit
Перебирать подэлементы document.body. Запоминать только один, последний найденный, элемент, а также, по окончании перебора – длину коллекции.

Здесь кеширование используется меньше.

Разбор действий браузера по строкам:

Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает его и возвращает.
Браузер запоминает только последний найденный, поэтому не помнит об элементе 500. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента 995 – назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.
Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.
Основное различие – в том, что Firefox запоминает все найденные, а Webkit – только последний. Таким образом, «метод Firefox» требует больше памяти, но гораздо эффективнее при повторном доступе к предыдущим элементам.

А «метод Webkit» ест меньше памяти и при этом работает не хуже в самом важном и частом случае – последовательном переборе коллекции, без возврата к ранее выбранным.

Запомненные элементы сбрасываются при изменениях DOM.

Документ может меняться. При этом, если изменение может повлиять на результаты поиска, то запомненные элементы необходимо сбросить. Например, добавление нового узла div сбросит запомненные элементы коллекции elem.getElementsByTagName('div').

Сбрасывание запомненных элементов при изменении документа выполняется интеллектуально.

Во-первых, при добавлении элемента будут сброшены только те коллекции, которые могли быть затронуты обновлением. Например, если в документе есть два независимых раздела <section>, и поисковая коллекция привязана к первому из них, то при добавлении во второй – она сброшена не будет.

Если точнее – будут сброшены все коллекции, привязанные к элементам вверх по иерархии от непосредственного родителя нового div и выше, то есть такие, которые потенциально могли измениться. И только они.

Во-вторых, если добавлен только div, то не будут сброшены запомненные элементы для поиска по другим тегам, например elem.getElementsByTagName('a').

…И, конечно же, не любые изменения DOM приводят к сбросу кешей, а только те, которые могут повлиять на коллекцию. Если где-то добавлен новый атрибут элементу – с кешем для getElementsByTagName ничего не произойдёт, так как атрибут никак не может повлиять на результат поиска по тегу.

Прочие поисковые методы, такие как getElementsByClassName тоже сбрасывают кеш при изменениях интеллектуально.

Разницу в алгоритмах поиска легко «пощупать». Посмотрите сами:
<script>
  for (var i = 0; i < 10000; i++) document.write('<span> </span>');

  var elements = document.body.getElementsByTagName('span');
  var len = elements.length;

  var d = new Date;
  for (var i = 0; i < len; i++) elements[i];
  alert( "Последовательно: " + (new Date - d) + "мс" ); // (1)

  var d = new Date;
  for (var i = 0; i < len; i += 2) elements[i], elements[len - i - 1];
  alert( "Вразнобой: " + (new Date - d) + "мс" ); // (2)
</script>
В примере выше первый цикл проходит элементы последовательно. А второй – идет по шагам: один с начала, потом один с конца, потом ещё один с начала, ещё один – с конца, и так далее.

Количество обращений к элементам одинаково.

В браузерах, которые запоминают все найденные (Firefox, IE) – скорость будет одинаковой.
В браузерах, которые запоминают только последний (Webkit) – разница будет порядка 100 и более раз, так как браузер вынужден бегать по дереву при каждом запросе заново.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Как получить все элементы с определённым атрибутом name?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.getElementsByName('age');
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
До появления стандарта HTML5 этот метод возвращал только те элементы, в которых предусмотрена поддержка атрибута name, в частности: iframe, a, input и другими. В современных браузерах (IE10+) тег не имеет значения.
Используется этот метод весьма редко.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Как получить все элементы с определённым классом?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
elem.getElementsByClassName(className)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Как и getElementsByTagName, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Чем elem.querySelectorAll(css)[0] оличается от elem.querySelector(css)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
elem.querySelector(css) работает быстрее, так как ищет только первый узел
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вызов elem.querySelectorAll(css) возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.
Псевдо-классы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например, document.querySelectorAll(':hover') вернёт список, в порядке вложенности, из текущих элементов под курсором мыши.
querySelector
Вызов elem.querySelector(css) возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
Иначе говоря, результат – такой же, как и при elem.querySelectorAll(css)[0], но в последнем вызове сначала ищутся все элементы, а потом берётся первый, а в elem.querySelector(css) ищется только первый, то есть он эффективнее.

*****
Внутреннее устройство поисковых методов
Эта глава не обязательна при первом чтении учебника.

Если вы хотите действительно глубоко понимать, что происходит при поиске, то посмотрите эту главу. Если нет – её можно пропустить.

Несмотря на схожесть в синтаксисе, поисковые методы get* и querySelector* внутри устроены очень по-разному.

document.getElementById(id)
Браузер поддерживает у себя внутреннее соответствие id -> элемент. Поэтому нужный элемент возвращается сразу. Это очень быстро.

elem.querySelector(query), elem.querySelectorAll(query)
Чтобы найти элементы, удовлетворяющие поисковому запросу, браузер не использует никаких сложных структур данных.

Он просто перебирает все подэлементы внутри элемента elem(или по всему документу, если вызов в контексте документа) и проверяет каждый элемент на соответствие запросу query.

Вызов querySelector прекращает перебор после первого же найденного элемента, а querySelectorAll собирает найденные элементы в «псевдомассив»: внутреннюю структуру данных, по сути аналогичную массиву JavaScript.

Этот перебор происходит очень быстро, так как осуществляется непосредственно движком браузера, а не JavaScript-кодом.

Оптимизации:

В случае поиска по ID: elem.querySelector('#id'), большинство браузеров оптимизируют поиск, используя вызов getElementById.
Последние результаты поиска сохраняются в кеше. Но это до тех пор, пока документ как-нибудь не изменится.
elem.getElementsBy*(…)
Результаты поиска getElementsBy* – живые! При изменении документа – изменяется и результат запроса.

Например, найдём все div при помощи querySelectorAll и getElementsByTagName, а потом изменим документ:
<div></div>
<script>
  var resultGet = document.getElementsByTagName('div');
  var resultQuery = document.querySelectorAll('div');

  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 1

  document.body.innerHTML = ''; // удалить всё содержимое BODY

  alert( resultQuery.length + ', ' + resultGet.length ); // 1, 0
</script>
Как видно, длина коллекции, найденной через querySelectorAll, осталась прежней. А длина коллекции, возвращённой getElementsByTagName, изменилась.

Дело в том, что результат запросов getElementsBy* – это не массив, а специальный объект, имеющий тип NodeList или HTMLCollection. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а «живой поисковой запрос».

Собственно поиск выполняется только при обращении к элементам коллекции или к её длине.

Алгоритмы getElementsBy*
Поиск getElementsBy* наиболее сложно сделать эффективно, так как его результат – «живая» коллекция, она должна быть всегда актуальной для текущего состояния документа.
var elems = document.getElementsByTagName('div');
alert( elems[0] );
// изменили документ
alert( elems[0] ); // результат может быть уже другой
Можно искать заново при каждой попытке получить элемент из elems. Тогда результат будет всегда актуален, но поиск будет работать уж слишком медленно. Да и зачем? Ведь, скорее всего, документ не поменялся.

Чтобы производительность getElementsBy* была достаточно хорошей, активно используется кеширование результатов поиска.

Для этого есть два основных способа: назовём их условно «Способ Firefox» (Firefox, IE) и «Способ WebKit» (Chrome, Safari, Opera).

Для примера, рассмотрим поиск в произвольном документе, в котором есть 1000 элементов div.

Посмотрим, как будут работать браузеры, если нужно выполнить следующий код:

// вместо document может быть любой элемент
var elems = document.getElementsByTagName('div');
alert( elems[0] );
alert( elems[995] );
alert( elems[500] );
alert( elems.length );
Способ Firefox
Перебрать подэлементы document.body в порядке их появления в поддереве. Запоминать все найденные элементы во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска.

Разбор действий браузера при выполнении кода выше:

Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает все найденные.
Возвращает ранее запомненный элемент с индексом 500, без дополнительного поиска!
Продолжает обход поддерева с элемента, на котором остановился (995) и до конца. Запоминает найденные элементы и возвращает их количество.
Способ WebKit
Перебирать подэлементы document.body. Запоминать только один, последний найденный, элемент, а также, по окончании перебора – длину коллекции.

Здесь кеширование используется меньше.

Разбор действий браузера по строкам:

Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает его и возвращает.
Браузер запоминает только последний найденный, поэтому не помнит об элементе 500. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента 995 – назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.
Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.
Основное различие – в том, что Firefox запоминает все найденные, а Webkit – только последний. Таким образом, «метод Firefox» требует больше памяти, но гораздо эффективнее при повторном доступе к предыдущим элементам.

А «метод Webkit» ест меньше памяти и при этом работает не хуже в самом важном и частом случае – последовательном переборе коллекции, без возврата к ранее выбранным.

Запомненные элементы сбрасываются при изменениях DOM.

Документ может меняться. При этом, если изменение может повлиять на результаты поиска, то запомненные элементы необходимо сбросить. Например, добавление нового узла div сбросит запомненные элементы коллекции elem.getElementsByTagName('div').

Сбрасывание запомненных элементов при изменении документа выполняется интеллектуально.

Во-первых, при добавлении элемента будут сброшены только те коллекции, которые могли быть затронуты обновлением. Например, если в документе есть два независимых раздела <section>, и поисковая коллекция привязана к первому из них, то при добавлении во второй – она сброшена не будет.

Если точнее – будут сброшены все коллекции, привязанные к элементам вверх по иерархии от непосредственного родителя нового div и выше, то есть такие, которые потенциально могли измениться. И только они.

Во-вторых, если добавлен только div, то не будут сброшены запомненные элементы для поиска по другим тегам, например elem.getElementsByTagName('a').

…И, конечно же, не любые изменения DOM приводят к сбросу кешей, а только те, которые могут повлиять на коллекцию. Если где-то добавлен новый атрибут элементу – с кешем для getElementsByTagName ничего не произойдёт, так как атрибут никак не может повлиять на результат поиска по тегу.

Прочие поисковые методы, такие как getElementsByClassName тоже сбрасывают кеш при изменениях интеллектуально.

Разницу в алгоритмах поиска легко «пощупать». Посмотрите сами:
<script>
  for (var i = 0; i < 10000; i++) document.write('<span> </span>');

  var elements = document.body.getElementsByTagName('span');
  var len = elements.length;

  var d = new Date;
  for (var i = 0; i < len; i++) elements[i];
  alert( "Последовательно: " + (new Date - d) + "мс" ); // (1)

  var d = new Date;
  for (var i = 0; i < len; i += 2) elements[i], elements[len - i - 1];
  alert( "Вразнобой: " + (new Date - d) + "мс" ); // (2)
</script>
В примере выше первый цикл проходит элементы последовательно. А второй – идет по шагам: один с начала, потом один с конца, потом ещё один с начала, ещё один – с конца, и так далее.

Количество обращений к элементам одинаково.

В браузерах, которые запоминают все найденные (Firefox, IE) – скорость будет одинаковой.
В браузерах, которые запоминают только последний (Webkit) – разница будет порядка 100 и более раз, так как браузер вынужден бегать по дереву при каждом запросе заново.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Какой метод проверяет, удовлетворяет ли elem селектору css?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
elem.matches(css)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.
Не поддерживается в IE8-.
Этот метод бывает полезным, когда мы перебираем элементы (в массиве или по обычным навигационным ссылкам) и пытаемся отфильтровать те из них, которые нам интересны.
Ранее в спецификации он назывался matchesSelector, и большинство браузеров поддерживают его под этим старым именем, либо с префиксами ms/moz/webkit.
Например:
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>
<script>
  var elems = document.body.children;

  for (var i = 0; i < elems.length; i++) {
    if (elems[i].matches('a[href$="zip"]')) {
      alert( "Ссылка на архив: " + elems[i].href );
    }
  }
</script>
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Метод elem.closest(css) начинает поиск с родительского элемента?
QWESTION!@@


@@!ANSWERS

@@!CORRECT
Нет. С элемента, на котором вызван.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.
Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его.
EXTENSION!@@



@@!BLOCK
Поиск: getElement* и querySelector* и не только
BLOCK!@@

@@!QWESTION
Где чаще всего используется язык запросов XPath?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
В XML
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для полноты картины рассмотрим ещё один способ поиска, который обычно используется в XML. Это язык запросов XPath.
Он очень мощный, во многом мощнее CSS, но сложнее. Например, запрос для поиска элементов H2, содержащих текст "XPath", будет выглядеть так: //h2[contains(., "XPath")].
Все современные браузеры, кроме IE, поддерживают XPath с синтаксисом, близким к описанному в MDN.
Найдем заголовки с текстом XPath в текущем документе:
 var result = document.evaluate("//h2[contains(., 'XPath')]", document.documentElement, null,
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
for (var i = 0; i < result.snapshotLength; i++) {
  alert( result.snapshotItem(i).outerHTML );
}
IE тоже поддерживает XPath, но эта поддержка не соответствует стандарту и работает только для XML-документов, например, полученных с помощью XMLHTTPRequest (AJAX). Для обычных же HTML-документов XPath в IE не поддерживается.
Так как XPath сложнее и длиннее CSS, то используют его очень редко.
EXTENSION!@@



@@!BLOCK
57--Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Как узнать класс DOM-узла?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Привести его к строке. alert( document.body );
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Самое главное различие между DOM-узлами – разные узлы являются объектами различных классов.
Поэтому, к примеру, у узла, соответствующего тегу <td> – одни свойства, у <form> – другие, у <a> – третьи.
Есть и кое-что общее, за счёт наследования.
Классы DOM образуют иерархию.
Основной объект в ней: Node, от которого наследуют остальные:
http://learn.javascript.ru/article/basic-dom-node-properties/hierarchy.png

На рисунке выше изображены основные классы:
Прямо от Node наследуют текстовые узлы Text, комментарии Comment и элементы Element.
Элементы Element – это ещё не HTML-элементы, а более общий тип, который используется в том числе в XML. От него наследует SVGElement для SVG-графики и, конечно, HTMLElement.
От HTMLElement уже наследуют разнообразные узлы HTML:
Для <input> – HTMLInputElement
Для <body> – HTMLBodyElement
Для <a> – HTMLAnchorElement… и так далее.
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Чему соответствует значение nodeType = 3?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Текстовому узлу
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Тип узла содержится в его свойстве nodeType.
Существует 12 типов узлов
interface Node {
  // Всевозможные значения nodeType
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5;
  const unsigned short ENTITY_NODE = 6;
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12;
  ...
}
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
В чём разница между nodeName и tagName?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Свойство nodeName определено для любых узлов Node, а свойство tagName есть только у элементов Element
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Существует целых два свойства: nodeName и tagName, которые содержат название(тег) элемента узла.
Название HTML-тега всегда находится в верхнем регистре.
В XHTML nodeName может быть не в верхнем регистре
У браузера есть два режима обработки документа: HTML и XML-режим. Обычно используется режим HTML.
XML-режим включается, когда браузер получает XML-документ через XMLHttpRequest(технология AJAX) или при наличии заголовка Content-Type: application/xml+xhtml.
В XML-режиме сохраняется регистр и nodeName может выдать «body» или даже «bOdY» – в точности как указано в документе. XML-режим используют очень редко.

Разница отражена в названиях свойств, но неочевидна.

Свойство tagName есть только у элементов Element (в IE8- также у комментариев, но это ошибка в браузере).
Свойство nodeName определено для любых узлов Node, для элементов оно равно tagName, а для не-элементов обычно содержит строку с типом узла.

alert( document.nodeName ); // #document, т.к. корень DOM -- не элемент
alert( document.tagName ); // undefined
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
С помощью какого свойства записать новое содержимое в HTML-элемент?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
innerHTML
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Оно позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать.
Значение, возвращаемое innerHTML – всегда валидный HTML-код. При записи можно попробовать записать что угодно, но браузер исправит ошибки:
 <body>
  <script>
    document.body.innerHTML = '<b>тест'; // незакрытый тег
    alert( document.body.innerHTML ); // <b>тест</b> (исправлено)
  </script>
</body>

Для таблиц в IE9- – innerHTML только для чтения
В Internet Explorer версии 9 и ранее, innerHTML доступно только для чтения для элементов COL, COLGROUP, FRAMESET, HEAD, HTML, STYLE, TABLE, TBODY, TFOOT, THEAD, TITLE, TR.
В частности, в IE9- запрещена запись в innerHTML для любых табличных элементов, кроме ячеек (TD/TH).

Добавление innerHTML+= осуществляет перезапись
Синтаксически, можно добавить текст к innerHTML через +=:
chatDiv.innerHTML += "<div>Привет<img src='smile.gif'/> !</div>";
chatDiv.innerHTML += "Как дела?";
На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись:
Удаляется старое содержание
На его место становится новое значение innerHTML.
Так как новое значение записывается с нуля, то все изображения и другие ресурсы будут перезагружены. В примере выше вторая строчка перезагрузит smile.gif, который был до неё. Если в chatDiv много текста, то эта перезагрузка будет очень заметна.
Есть и другие побочные эффекты, например если существующий текст был выделен мышкой, то в большинстве браузеров это выделение пропадёт. Если в HTML был <input>, в который посетитель что-то ввёл, то введённое значение пропадёт. И тому подобное.
К счастью, есть и другие способы добавить содержимое, не использующие innerHTML.

Скрипты не выполняются
Если в innerHTML есть тег script – он не будет выполнен.
К примеру:
 <div id="my"></div>
<script>
  var elem = document.getElementById('my');
  elem.innerHTML = 'ТЕСТ<script>alert( 1 );</scr' + 'ipt>';
</script>
В примере закрывающий тег </scr'+'ipt> разбит на две строки, т.к. иначе браузер подумает, что это конец скрипта. Вставленный скрипт не выполнится.
Исключение – IE9-, в нем вставляемый скрипт выполняется, если у него есть атрибут defer. Но это нестандартная возможность, которой не следует пользоваться.
IE8- обрезает style и script в начале innerHTML
Если в начале innerHTML находятся стили <style>, то старый IE проигнорирует их. То есть, иными словами, они не применятся.
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Что вернёт alert?
<div>Привет, Мир!</div>
<script>
  var div = document.body.children[0];
  div.outerHTML = '<p>Новый элемент!</p>';
  alert( div.outerHTML );
</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
<div>Привет, Мир!</div>
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Свойство outerHTML содержит HTML элемента целиком.
Изменить outerHTML элемента невозможно.
Здесь мы остановимся чуть подробнее. Дело в том, что технически свойство outerHTML доступно на запись. Но при этом элемент не меняется, а заменяется на новый, который тут же создаётся из нового outerHTML.
При этом переменная, в которой изначально был старый элемент, и в которой мы «перезаписали» outerHTML, остаётся со старым элементом.
Это легко может привести к ошибкам, что видно на примере:
<div>Привет, Мир!</div>
<script>
  var div = document.body.children[0];
  // заменяем div.outerHTML на <p>...</p>
  div.outerHTML = '<p>Новый элемент!</p>';
  // ... но содержимое div.outerHTML осталось тем же, несмотря на "перезапись"
  alert( div.outerHTML ); // <div>Привет, Мир!</div>
</script>
То, что произошло в примере выше – так это замена div в документе на новый узел <p>...</p>. При этом переменная div не получила этот новый узел! Она сохранила старое значение, чтение из неё это отлично показывает.
Записал outerHTML? Понимай последствия!
Иногда начинающие делают здесь ошибку: сначала заменяют div.outerHTML, а потом продолжают работать с div, как будто это изменившийся элемент. Такое возможно с innerHTML, но не с outerHTML.
Записать новый HTML в outerHTML можно, но нужно понимать, что это никакое не изменение свойств узла, а создание нового.
Новосозданный узел не доступен сразу в переменной, хотя его, конечно, можно получить из DOM.
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
В чем отличие между nodeValue и data?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
На узлах, где data нет, nodeValue есть и равен null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Свойство innerHTML есть только у узлов-элементов.
Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data.
Свойство nodeValue мы использовать не будем.
Оно работает так же, как data, но на некоторых узлах, где data нет, nodeValue есть и имеет значение null. Как-то использовать это тонкое отличие обычно нет причин.
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Есть ли свойство data у узлов-элементов?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Будут ли применены html-теги в строке <b>Винни-пух</b>?
<script>
  var name = prompt("Введите имя?", "<b>Винни-пух</b>");
  document.body.children[1].textContent = name;
</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Свойство textContent содержит только текст внутри элемента, за вычетом всех <тегов>.
Оно поддерживается везде, кроме IE8-.
<div>
  <h1>Срочно в номер!</h1>
  <p>Марсиане атакуют людей!</p>
</div>
<script>
  var news = document.body.children[0];
  // \n  Срочно в номер!\n  Марсиане атакуют людей!\n
  alert( news.textContent );
</script>
Иными словами, elem.textContent возвращает конкатенацию всех текстовых узлов внутри elem.

Нестандартное свойство innerText
Всеми браузерами, кроме Firefox 44- (согласно CanIUse.Com), поддерживается нестандартное свойство innerText.
У него, в некотором роде, преимущество перед textContent в том, что оно по названию напоминает innerHTML, его проще запомнить.
Однако, свойство innerText не следует использовать, так как оно не стандартное и не будет стандартным.
Это свойство возвращает текст не в том виде, в котором он в DOM, а в том, в котором он виден – как если бы мы выбрали содержимое элемента мышкой и скопировали его. В частности, если элемент невидим, то его текст возвращён не будет. Это довольно странная особенность существует по историческим причинам и скорее мешает, чем помогает.
Впрочем, при записи значения innerText работает так же, как и textContent.
EXTENSION!@@



@@!BLOCK
Свойства узлов: тип, тег и содержимое
BLOCK!@@

@@!QWESTION
Валидна ли такая запись <div hidden>С атрибутом hidden</div> ?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да, в HTML5
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В стандарте HTML5 предусмотрен специальный атрибут и свойство для этого: hidden.
Его поддерживают все современные браузеры, кроме IE10-.
Технически, атрибут hidden работает так же, как style="display:none". Но его проще поставить через JavaScript (меньше букв), и могут быть преимущества для скринридеров и прочих нестандартных браузеров.
EXTENSION!@@



@@!BLOCK
58--Современный DOM: полифиллы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
<input type="no-such-type">
<script>
  alert( document.body.children[0].type );
</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
text
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если мы хотим проверить поддержку не свойства целиком, а некоторых его значений, то ситуация сложнее.
Например, нам интересно, поддерживает ли браузер <input type="range">. То есть, понятно, что свойство type у input, в целом, поддерживается, а вот конкретный тип <input>?
Для этого можно создать <input> с таким type и посмотреть, подействовал ли он.
Например:
<input type="radio">
<input type="no-such-type">
<script>
  alert( document.body.children[0].type ); // radio, поддерживается
  alert( document.body.children[1].type ); // text, не поддерживается
</script>
Первый input имеет type="radio". Этот тип точно поддерживается, поэтому input.type имеет значение "radio", как и указано.
Второй input имеет type="no-such-type". В качестве типа, для примера, специально указано заведомо неподдерживаемое значение. При этом input.type равен "text", таково значение по умолчанию. Мы можем прочитать его и увидеть, что поддержки нет.
Эта проверка работает, так как хоть в HTML-атрибут type и можно присвоить любую строку, но DOM-свойство type по стандарту хранит реальный тип input'а.
EXTENSION!@@



@@!BLOCK
59--Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Что выведет alert?
document.body.myData = {
  name: 'Петр',
  familyName: 'Петрович'
};
alert( document.body.myData.name );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Петр
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Узел DOM – это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.
Нестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега.
Обратим внимание, пользовательские DOM-свойства:
- Могут иметь любое значение.
- Названия свойств чувствительны к регистру.
- Работают за счет того, что DOM-узлы являются объектами JavaScript.
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Можно ли так обратиться к атрибуту (разный регистр первой буквы)?
<body>
  <div id="elem" about="Elephant"></div>
  <script>
    alert( elem.getAttribute('About') );
  </script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Элементам DOM, с другой стороны, соответствуют HTML-теги, у которых есть текстовые атрибуты.
Конечно, здесь речь именно об узлах-элементах, не о текстовых узлах или комментариях.
Доступ к атрибутам осуществляется при помощи стандартных методов:
- elem.hasAttribute(name) – проверяет наличие атрибута
- elem.getAttribute(name) – получает значение атрибута
- elem.setAttribute(name, value) – устанавливает атрибут
- elem.removeAttribute(name) – удаляет атрибут
Эти методы работают со значением, которое находится в HTML.
Также все атрибуты элемента можно получить с помощью свойства elem.attributes, которое содержит псевдо-массив объектов типа Attr.
В отличие от свойств, атрибуты:
- Всегда являются строками.
- Их имя нечувствительно к регистру (ведь это HTML)
- Видны в innerHTML (за исключением старых IE)
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Что выведет первый alert, что второй?
<a id="a" href="#"></a>
<script>
  a.href = '/';

  alert( 'атрибут:' + a.getAttribute('href') );
  alert( 'свойство:' + a.href );

</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Первый —'/', второй — полный URL
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синхронизация не гарантирует одинакового значения в атрибуте и свойстве.
Для примера, посмотрим, что произойдет с атрибутом "href" при изменении свойства:
<a id="a" href="#"></a>
<script>
  a.href = '/';
  alert( 'атрибут:' + a.getAttribute('href') ); // '/'
  alert( 'свойство:' + a.href );  // полный URL
</script>
Это происходит потому, что атрибут может быть любым, а свойство href, в соответствии со спецификацией W3C, должно быть полной ссылкой.
Стало быть, если мы хотим именно то, что в HTML, то нужно обращаться через атрибут.
Есть и другие подобные атрибуты
Кстати, есть и другие атрибуты, которые не копируются в точности. Например, DOM-свойство input.checked имеет логическое значение true/false, а HTML-атрибут checked – любое строковое, важно лишь его наличие.
Работа с checked через атрибут и свойство:
<input id="input" type="checkbox" checked>
<script>
  // работа с checked через атрибут
  alert( input.getAttribute('checked') ); // пустая строка
  input.removeAttribute('checked'); // снять галочку
  // работа с checked через свойство
  alert( input.checked ); // false <-- может быть только true/false
  input.checked = true; // поставить галочку (при этом атрибут в элементе не появится)
</script>
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Что выведет alert?
<body>
  <input id="input" type="text" value="markup">
  <script>
    input.value = 'new';
    alert( input.getAttribute('value') );
  </script>
</body>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
'markup'
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Изменение некоторых свойств обновляет атрибут. Но это скорее исключение, чем правило.
Чаще синхронизация – односторонняя: свойство зависит от атрибута, но не наоборот.
Например, при изменении свойства input.value атрибут input.getAttribute('value') не меняется:
<body>
  <input id="input" type="text" value="markup">
  <script>
    input.value = 'new'; // поменяли свойство
    alert( input.getAttribute('value') ); // 'markup', не изменилось!
  </script>
</body>
То есть, изменение DOM-свойства value на атрибут не влияет, он остаётся таким же.
А вот изменение атрибута обновляет свойство:
<body>
  <input id="input" type="text" value="markup">
  <script>
    input.setAttribute('value', 'new'); // поменяли атрибут
    alert( input.value ); // 'new', input.value изменилось!
  </script>
</body>
Эту особенность можно красиво использовать.
Получается, что атрибут input.getAttribute('value') хранит оригинальное (исходное) значение даже после того, как пользователь заполнил поле и свойство изменилось.
Например, можно взять изначальное значение из атрибута и сравнить со свойством, чтобы узнать, изменилось ли значение. А при необходимости и перезаписать свойство атрибутом, отменив изменения.
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Что возвращает elem.className?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Строку, содержащую классы элемента, разелённые пробелом
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Как удалить класс с помощью classList?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
elem.classList.remove("class")
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Атрибут class – уникален. Ему соответствует аж целых два свойства!
Работать с классами как со строкой неудобно. Поэтому, кроме className, в современных браузерах есть свойство classList.
Свойство classList – это объект для работы с классами.
Оно поддерживается в IE начиная с IE10, но его можно эмулировать в IE8+, подключив мини-библиотеку classList.js.
Методы classList:
- elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class.
- elem.classList.add/remove("class") – добавляет/удаляет класс class
- elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.
Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Что выведет alert?
alert( img.href );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
undefined
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У каждого элемента есть некоторый набор стандартных свойств, например для <a> это будут href, name, а для <img> это будут src, alt, и так далее.
Точный набор свойств описан в стандарте, обычно мы более-менее представляем, если пользуемся HTML, какие свойства могут быть, а какие – нет.
Для нестандартных атрибутов DOM-свойство не создаётся.
EXTENSION!@@



@@!BLOCK
Атрибуты и DOM-свойства
BLOCK!@@

@@!QWESTION
Как обратиться к свойству data-user-location="street" через dataset?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
dataset.userLocation
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JavaScript.

Как правило, это делается при помощи атрибутов с названиями, начинающимися на data-.
Стандарт HTML5 специально разрешает атрибуты data-* и резервирует их для пользовательских данных.
При этом во всех браузерах, кроме IE10-, к таким атрибутам можно обратиться не только как к атрибутам, но и как к свойствам, при помощи специального свойства dataset
Обратим внимание – название data-user-location трансформировалось в dataset.userLocation. Дефис превращается в большую букву.
EXTENSION!@@



@@!BLOCK
60--Методы contains и compareDocumentPosition
BLOCK!@@

@@!QWESTION
parent.contains(child) вернёт true если parent == child?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если есть два элемента, то иногда бывает нужно понять, лежит ли один из них выше другого, то есть является ли его предком.
Метод contains для проверки на вложенность. Возвращает true, если parent содержит child или parent == child.
EXTENSION!@@



@@!BLOCK
Методы contains и compareDocumentPosition
BLOCK!@@

@@!QWESTION
Что означает такая битовая маска 000100, возвращённая методом compareDocumentPosition?
nodeA.compareDocumentPosition(nodeB);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
nodeA предшествует nodeB
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Бывает, что у нас есть два элемента, к примеру, <li> в списке, и нужно понять, какой из них выше другого.
Метод compareDocumentPosition – более мощный, чем contains, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов.

Синтаксис:
var result = nodeA.compareDocumentPosition(nodeB);
Возвращаемое значение – битовая маска (см. Побитовые операторы), биты в которой означают следующее:

Биты  Число Значение
000000  0   nodeA и nodeB -- один и тот же узел
000001  1   Узлы в разных документах (или один из них не в документе)
000010  2   nodeB предшествует nodeA (в порядке обхода документа)
000100  4   nodeA предшествует nodeB
001000  8   nodeB содержит nodeA
010000  16  nodeA содержит nodeB
100000  32  Зарезервировано для браузера
Понятие «предшествует» – означает не только «предыдущий сосед при общем родителе», но и имеет более общий смысл: "раньше встречается в порядке прямого обхода дерева документа.
Могут быть и сочетания битов. Примеры реальных значений:
 <p>...</p>
<ul>
  <li>1.1</li>
</ul>
<script>
  var p = document.body.children[0];
  var ul = document.body.children[1];
  var li = ul.children[0];

  // 1. <ul> находится после <p>
  alert( ul.compareDocumentPosition(p) ); // 2 = 10

  // 2. <p> находится до <ul>
  alert( p.compareDocumentPosition(ul) ); // 4 = 100

  // 3. <ul> родитель <li>
  alert( ul.compareDocumentPosition(li) ); // 20 = 10100

  // 4. <ul> потомок <body>
  alert( ul.compareDocumentPosition(document.body) ); // 10 = 1010
</script>
EXTENSION!@@



@@!BLOCK
Методы contains и compareDocumentPosition
BLOCK!@@

@@!QWESTION
Что означает такая битовая маска 000001, возвращённая методом compareDocumentPosition?
nodeA.compareDocumentPosition(nodeB);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Узлы в разных документах (или один из них не в документе)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Бывает, что у нас есть два элемента, к примеру, <li> в списке, и нужно понять, какой из них выше другого.
Метод compareDocumentPosition – более мощный, чем contains, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов.

Синтаксис:
var result = nodeA.compareDocumentPosition(nodeB);
Возвращаемое значение – битовая маска (см. Побитовые операторы), биты в которой означают следующее:

Биты  Число Значение
000000  0   nodeA и nodeB -- один и тот же узел
000001  1   Узлы в разных документах (или один из них не в документе)
000010  2   nodeB предшествует nodeA (в порядке обхода документа)
000100  4   nodeA предшествует nodeB
001000  8   nodeB содержит nodeA
010000  16  nodeA содержит nodeB
100000  32  Зарезервировано для браузера
Понятие «предшествует» – означает не только «предыдущий сосед при общем родителе», но и имеет более общий смысл: "раньше встречается в порядке прямого обхода дерева документа.
Могут быть и сочетания битов. Примеры реальных значений:
 <p>...</p>
<ul>
  <li>1.1</li>
</ul>
<script>
  var p = document.body.children[0];
  var ul = document.body.children[1];
  var li = ul.children[0];

  // 1. <ul> находится после <p>
  alert( ul.compareDocumentPosition(p) ); // 2 = 10

  // 2. <p> находится до <ul>
  alert( p.compareDocumentPosition(ul) ); // 4 = 100

  // 3. <ul> родитель <li>
  alert( ul.compareDocumentPosition(li) ); // 20 = 10100

  // 4. <ul> потомок <body>
  alert( ul.compareDocumentPosition(document.body) ); // 10 = 1010
</script>
EXTENSION!@@



@@!BLOCK
Методы contains и compareDocumentPosition
BLOCK!@@

@@!QWESTION
Что означает такая битовая маска 010000, возвращённая методом compareDocumentPosition?
nodeA.compareDocumentPosition(nodeB);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
nodeA содержит nodeB
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Бывает, что у нас есть два элемента, к примеру, <li> в списке, и нужно понять, какой из них выше другого.
Метод compareDocumentPosition – более мощный, чем contains, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов.

Синтаксис:
var result = nodeA.compareDocumentPosition(nodeB);
Возвращаемое значение – битовая маска (см. Побитовые операторы), биты в которой означают следующее:

Биты  Число Значение
000000  0   nodeA и nodeB -- один и тот же узел
000001  1   Узлы в разных документах (или один из них не в документе)
000010  2   nodeB предшествует nodeA (в порядке обхода документа)
000100  4   nodeA предшествует nodeB
001000  8   nodeB содержит nodeA
010000  16  nodeA содержит nodeB
100000  32  Зарезервировано для браузера
Понятие «предшествует» – означает не только «предыдущий сосед при общем родителе», но и имеет более общий смысл: "раньше встречается в порядке прямого обхода дерева документа.
Могут быть и сочетания битов. Примеры реальных значений:
 <p>...</p>
<ul>
  <li>1.1</li>
</ul>
<script>
  var p = document.body.children[0];
  var ul = document.body.children[1];
  var li = ul.children[0];

  // 1. <ul> находится после <p>
  alert( ul.compareDocumentPosition(p) ); // 2 = 10

  // 2. <p> находится до <ul>
  alert( p.compareDocumentPosition(ul) ); // 4 = 100

  // 3. <ul> родитель <li>
  alert( ul.compareDocumentPosition(li) ); // 20 = 10100

  // 4. <ul> потомок <body>
  alert( ul.compareDocumentPosition(document.body) ); // 10 = 1010
</script>
EXTENSION!@@



@@!BLOCK
61--Добавление и удаление узлов
BLOCK!@@

@@!QWESTION
С помощью какого метода можно создать текстовый узел?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.createTextNode(text)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Добавление и удаление узлов
BLOCK!@@

@@!QWESTION
С помощью какого метода можно создать новый элемент (тег)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.createElement(tag)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Добавление и удаление узлов
BLOCK!@@

@@!QWESTION
Что указывают вторым параметром в методе parentElem.insertBefore()?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Элемент, перед которым будет вставлен узел из первого параметра parentElem.insertBefore()
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Чтобы DOM-узел был показан на странице, его необходимо вставить в document.
Для этого первым делом нужно решить, куда мы будем его вставлять. Предположим, что мы решили, что вставлять будем в некий элемент parentElem, например var parentElem = document.body.
Для вставки внутрь parentElem есть следующие методы:
parentElem.appendChild(elem)
Добавляет elem в конец дочерних элементов parentElem.

parentElem.insertBefore(elem, nextSibling)
Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling.

Дело в том, что если вторым аргументом указать null, то insertBefore сработает как appendChild.
EXTENSION!@@



@@!BLOCK
Что возвращают методы вставки?
BLOCK!@@

@@!QWESTION
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Вставленный узел.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Добавление и удаление узлов
BLOCK!@@

@@!QWESTION
Какую копию создаст elem.cloneNode();
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Копию без дочерних элементов
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вызов elem.cloneNode(true) создаст «глубокую» копию элемента – вместе с атрибутами, включая подэлементы. Если же вызвать с аргументом false, то копия будет сделана без дочерних элементов. Это нужно гораздо реже.
Если элемент большой, то клонировать его будет гораздо быстрее, чем пересоздавать.
EXTENSION!@@



@@!BLOCK
Добавление и удаление узлов
BLOCK!@@

@@!QWESTION
Какой метод позволяет среди детей parentElem удалить elem и вставить на его место newElem.
QWESTION!@@

@@!ANSWERS

@@!CORRECT
parentElem.replaceChild(newElem, elem)
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для удаления узла есть два метода:
parentElem.removeChild(elem)

Удаляет elem из списка детей parentElem.
parentElem.replaceChild(newElem, elem)

Среди детей parentElem удаляет elem и вставляет на его место newElem.
Оба этих метода возвращают удаленный узел, то есть elem. Если нужно, его можно вставить в другое место DOM тут же или в будущем.

Если вы хотите переместить элемент на новое место – не нужно его удалять со старого.
Все методы вставки автоматически удаляют вставляемый элемент со старого места.
EXTENSION!@@



@@!BLOCK
62--Мультивставка: insertAdjacentHTML и DocumentFragment
BLOCK!@@

@@!QWESTION
Где будет вставлен html: elem.insertAdjacentHTML('beforeEnd', html);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Внутрь `elem`, в конец.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Сначала вставить UL в документ, а потом добавить к нему LI или полностью создать список «вне DOM», а потом – вставить в документ.
Как ни странно, между этими последовательностями есть разница. В большинстве браузеров, второй вариант – быстрее.
Почему же? Иногда говорят: «потому что браузер перерисовывает каждый раз при добавлении элемента». Это не так. Дело вовсе не в перерисовке.
Браузер достаточно «умён», чтобы ничего не перерисовывать понапрасну. В большинстве случаев процессы перерисовки и сопутствующие вычисления будут отложены до окончания работы скрипта, и на тот момент уже совершенно без разницы, в какой последовательности были изменены узлы.
Тем не менее, при вставке узла происходят разные внутренние события и обновления внутренних структур данных, скрытые от наших глаз.

Рассмотрим случай, когда в документе уже есть большой список UL. И тут понадобилось срочно добавить еще 20 элементов LI.
ul.innerHTML += "<li>1</li><li>2</li>...";
Но операцию ul.innerHTML += "..." можно по-другому переписать как ul.innerHTML = ul.innerHTML + "...". Иначе говоря, она не прибавляет, а заменяет всё содержимое списка на дополненную строку. Это и нехорошо с точки зрения производительности, но и будут побочные эффекты. В частности, все внешние ресурсы (картинки) внутри перезаписываемого innerHTML будут загружены заново. Если в каких-то переменных были ссылки на элементы списка – они станут неверны, так как содержимое полностью заменяется. В общем, так лучше не делать.

Метод insertAdjacentHTML позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами!
Он поддерживается всеми браузерами, кроме Firefox меньше версии 8, ну а там его можно эмулировать.

html
Строка HTML, которую нужно вставить
where :Куда по отношению к elem вставлять строку. Всего четыре варианта:
1. `beforeBegin` -- перед `elem`.
2. `afterBegin` -- внутрь `elem`, в самое начало.
3. `beforeEnd` -- внутрь `elem`, в конец.
4. `afterEnd` -- после `elem`.

У этого метода есть «близнецы-братья», которые поддерживаются везде, кроме Firefox, но в него они добавляются тем же полифиллом:
elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem.
elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem.
EXTENSION!@@



@@!BLOCK
Мультивставка: insertAdjacentHTML и DocumentFragment
BLOCK!@@

@@!QWESTION
Оптимизирует ли вставку DocumentFragment в современных браузерах?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет. Эффект от него, как правило, небольшой, а иногда может быть и отрицательным.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вставить пачку узлов единовременно поможет DocumentFragment. Это особенный кросс-браузерный DOM-объект, который похож на обычный DOM-узел, но им не является.
Синтаксис для его создания:
var fragment = document.createDocumentFragment();
В него можно добавлять другие узлы.
fragment.appendChild(node);
Его можно клонировать:
fragment.cloneNode(true); // клонирование с подэлементами
У DocumentFragment нет обычных свойств DOM-узлов, таких как innerHTML, tagName и т.п. Это не узел.
Его «Фишка» заключается в том, что когда DocumentFragment вставляется в DOM – то он исчезает, а вместо него вставляются его дети. Это свойство является уникальной особенностью DocumentFragment.
EXTENSION!@@



@@!BLOCK
Мультивставка: insertAdjacentHTML и DocumentFragment
BLOCK!@@

@@!QWESTION
Как вставляются строки в современных методах вставки таких как node.append(...nodes) и т.п.?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Строки вставляются именно как текстовые узлы
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Сравнительно недавно в стандарте появились методы, которые позволяют вставить что угодно и куда угодно.
Синтаксис:
node.append(...nodes) – вставляет nodes в конец node,
node.prepend(...nodes) – вставляет nodes в начало node,
node.after(...nodes) – вставляет nodes после узла node,
node.before(...nodes) – вставляет nodes перед узлом node,
node.replaceWith(...nodes) – вставляет nodes вместо node.
Эти методы ничего не возвращают.
Во всех этих методах nodes – DOM-узлы или строки, в любом сочетании и количестве. Причём строки вставляются именно как текстовые узлы, в отличие от insertAdjacentHTML.
EXTENSION!@@



@@!BLOCK
63--Метод document.write
BLOCK!@@

@@!QWESTION
В чём отличие document.write(str) и document.writeln(str)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.writeln(str) добавляет после str символ перевода строки "\n".
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод document.write(str) работает только пока HTML-страница находится в процессе загрузки. Он дописывает текст в текущее место HTML ещё до того, как браузер построит из него DOM.
Нет никаких ограничений на содержимое document.write.

Технически, вызвать document.write можно в любое время, однако, когда HTML загрузился, и браузер полностью построил DOM, документ становится «закрытым». Попытка дописать что-то в закрытый документ открывает его заново. При этом все текущее содержимое удаляется.

Метод document.write работает быстрее, фактически это самый быстрый способ добавить на страницу текст, сгенерированный скриптом.
EXTENSION!@@



@@!BLOCK
64--Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Будет ли работать такая запись elem.style.width = 100
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет. Единицы измерения обязательны
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS.
EXTENSION!@@



@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Как установить свойство -moz-border-radius с помощью метода style?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
element.style.MozBorderRadius = '5px';
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Каждый дефис даёт большую букву.
EXTENSION!@@



@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Что будет если элементу, у которого уже есть стили в свойстве style, указать style.cssText?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
При установке style.cssText все предыдущие свойства style удаляются.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Как вычислить текущее используемое значение свойства элемента?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
getComputedStyle(element[, pseudo])
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для того, чтобы получить текущее используемое значение свойства, используется метод window.getComputedStyle, описанный в стандарте DOM Level 2.

Его синтаксис таков:
getComputedStyle(element[, pseudo])
element
Элемент, значения для которого нужно получить
pseudo
Указывается, если нужен стиль псевдо-элемента, например "::before". Пустая строка или отсутствие аргумента означают сам элемент.

getComputedStyle требует полное свойство!
Для правильного получения значения нужно указать точное свойство. Например: paddingLeft, marginTop, borderLeftWidth.
При обращении к сокращенному: padding, margin, border – правильный результат не гарантируется.
Действительно, допустим свойства paddingLeft/paddingTop взяты из разных классов CSS. Браузер не обязан объединять их в одно свойство padding. Иногда, в простейших случаях, когда свойство задано сразу целиком, getComputedStyle сработает для сокращённого свойства, но не во всех браузерах.
EXTENSION!@@
 


@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Можно ли получить цвет посещённых ссылок через getComputedStyle?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У посещенных ссылок может быть другой цвет, фон, чем у обычных. Это можно поставить в CSS с помощью псевдокласса :visited.
Но getComputedStyle не дает доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку.
Кроме того, большинство браузеров запрещают применять к :visited CSS-стили, которые могут изменить геометрию элемента, чтобы даже окольным путем нельзя было это понять. В целях безопасности.
EXTENSION!@@



@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
Чем окончательное (resolved) значение отличается от вычисленного (computed)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Окончательное (resolved) значение – приводят размеры к пикселям
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В CSS есть две концепции:

Вычисленное (computed) значение – это то, которое получено после применения всех правил CSS и CSS-наследования. Например, width: auto или font-size: 125%.
Окончательное (resolved) значение – непосредственно применяемое к элементу. При этом все размеры приводятся к пикселям, например width: 212px или font-size: 16px. В некоторых браузерах пиксели могут быть дробными.
Когда-то getComputedStyle задумывалось для возврата вычисленного значения, но со временем оказалось, что окончательное гораздо удобнее.

Поэтому сейчас в целом все значения возвращаются именно окончательные, кроме некоторых небольших глюков в браузерах, которые постепенно вычищаются.
EXTENSION!@@



@@!BLOCK
Стили, getComputedStyle
BLOCK!@@

@@!QWESTION
В каком формате возвращает значения  currentStyle для IE8-?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
В формате вычисленного (computed) значения
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В IE8- нет getComputedStyle, но у элементов есть свойство currentStyle, которое возвращает вычисленное (computed) значение: уже с учётом CSS-каскада, но не всегда в окончательном формате.
Чтобы код работал и в старых и новых браузерах, обычно пишут кросс-браузерный код, наподобие такого:
function getStyle(elem) {
  return window.getComputedStyle ? getComputedStyle(elem, "") : elem.currentStyle;
}
Если вы откроете такой документ в IE8-, то размеры будут в процентах, а в современных браузерах – в пикселях.
EXTENSION!@@



@@!BLOCK
65--Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
На какой элемент хранится ссылка в offsetParent?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
На ближайший позиционированный элемент
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
https://learn.javascript.ru/article/metrics/metric-all@2x.png

Когда браузер рисует страницу, то он высчитывает дерево расположения элементов, иначе говоря «дерево геометрии» или «дерево рендеринга», которое содержит всю информацию о размерах.
При этом одни элементы естественным образом рисуются внутри других. Но, к примеру, если у элемента стоит position:absolute, то его расположение вычисляется уже не относительно непосредственного родителя parentNode, а относительно ближайшего позиционированного элемента (т.е. свойство position которого не равно static), или BODY, если такой отсутствует.
Получается, что элемент имеет в дополнение к обычному родителю в DOM – ещё одного «родителя по позиционированию», то есть относительно которого он рисуется. Этот элемент и будет в свойстве offsetParent.

Свойства offsetLeft/Top задают смещение относительно offsetParent.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
Какие свойства хранят внешние высоты/ширину элемента?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
offsetWidth/Height
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки border.

Метрики для невидимых элементов равны нулю.
Координаты и размеры в JavaScript устанавливаются только для видимых элементов.
Для элементов с display:none или находящихся вне документа дерево рендеринга не строится. Для них метрики равны нулю. Кстати, и offsetParent для таких элементов тоже null.
Это дает нам замечательный способ для проверки, виден ли элемент:
function isHidden(elem) {
  return !elem.offsetWidth && !elem.offsetHeight;
}
Работает, даже если родителю элемента установлено свойство display:none.
Работает для всех элементов, кроме TR, с которым возникают некоторые проблемы в разных браузерах. Обычно, проверяются не TR, поэтому всё ок.
Считает элемент видимым, даже если позиционирован за пределами экрана или имеет свойство visibility:hidden.
«Схлопнутый» элемент, например пустой div без высоты и ширины, будет считаться невидимым.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
Что хранят свойства clientTop и clientLeft?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Отступ внутренней части элемента от внешней.
CORRECT!@@

@@!WRONG
Размеры рамки
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Но на самом деле они – вовсе не рамки, а отступ внутренней части элемента от внешней.

В чём же разница?

Она возникает тогда, когда документ располагается справа налево (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство clientLeft включает в себя еще и ширину полосы прокрутки.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
clientWidth/Height включает в себя прокрутку?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
clientWidth/Height включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.
https://learn.javascript.ru/article/metrics/metric-client-width-height@2x.png
На рисунке выше посмотрим вначале на clientHeight, её посчитать проще всего. Прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота 200px плюс верхнее и нижнее поля padding (по 20px), итого 240px.
На рисунке нижний padding заполнен текстом, но это неважно: по правилам он всегда входит в clientHeight.
Теперь clientWidth – ширина содержимого здесь не равна CSS-ширине, её часть «съедает» полоса прокрутки. Поэтому в clientWidth входит не CSS-ширина, а реальная ширина содержимого 284px плюс левое и правое поля padding (по 20px), итого 324px.
Если padding нет, то clientWidth/Height в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
Как узнать ширину элемента с учётом прокрутки?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
scrollWidth 
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
scrollHeight – полная внутренняя высота, включая прокрученную область.
scrollWidth – полная внутренняя ширина, если прокрутки нет, она равна clientWidth.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
Можно ли менять свойства scrollLeft/scrollTop?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.
В отличие от большинства свойств, которые доступны только для чтения, значения scrollLeft/scrollTop можно изменить, и браузер выполнит прокрутку элемента.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка элементов
BLOCK!@@

@@!QWESTION
Все браузеры учитывают полосу прокрутки при формировании getComputedStyle(elem).width?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Не стоит брать width/height из CSS
Во-первых, CSS-свойства width/height зависят от другого свойства – box-sizing, которое определяет, что такое, собственно, эти ширина и высота. Получается, что изменение box-sizing, к примеру, для более удобной вёрстки, сломает такой JavaScript.
Во-вторых, в CSS свойства width/height могут быть равны auto.
Конечно, с точки зрения CSS размер auto – совершенно нормально, но нам-то в JavaScript нужен конкретный размер в пикселях, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина width из CSS вообще бесполезна.
Есть и ещё одна причина.
Полоса прокрутки – причина многих проблем и недопониманий. Как говорится, «дьявол кроется в деталях». Недопустимо, чтобы наш код работал на элементах без прокрутки и начинал «глючить» с ней.
Как мы говорили ранее, при наличии вертикальной полосы прокрутки, в зависимости от браузера, устройства и операционной системы, она может сдвинуть содержимое.
Получается, что реальная ширина содержимого меньше CSS-ширины. И это учитывают свойства clientWidth/clientHeight.
…Но при этом некоторые браузеры также учитывают это в результате getComputedStyle(elem).width, то есть возвращают реальную внутреннюю ширину, а некоторые – именно CSS-свойство. Эти кросс-браузерные отличия – ещё один повод не использовать такой подход, а использовать свойства-метрики.
EXTENSION!@@



@@!BLOCK
66--Размеры и прокрутка страницы
BLOCK!@@

@@!QWESTION
Как получить высоту видимой части окна?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.documentElement.clientHeight
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
С точки зрения HTML, документ – это document.documentElement. У этого элемента, соответствующего тегу <html>, есть все стандартные свойства и метрики и, в теории, они и должны нам помочь.
Свойства clientWidth/Height для элемента document.documentElement – это как раз ширина/высота видимой области окна.

Все браузеры, кроме IE8-, также поддерживают свойства window.innerWidth/innerHeight. Они хранят текущий размер окна браузера.
В чём отличие? Оно небольшое, но чрезвычайно важное.
Свойства clientWidth/Height, если есть полоса прокрутки, возвращают именно ширину/высоту внутри неё, доступную для документа, а window.innerWidth/Height – игнорируют её наличие.
Если справа часть страницы занимает полоса прокрутки, то эти строки выведут разное:
 alert( window.innerWidth ); // вся ширина окна
alert( document.documentElement.clientWidth ); // ширина минус прокрутка
Обычно нам нужна именно доступная ширина окна, например, чтобы нарисовать что-либо, то есть за вычетом полосы прокрутки. Поэтому используем documentElement.clientWidth.

Ширина/высота страницы с учётом прокрутки
Теоретически, видимая часть страницы – это documentElement.clientWidth/Height, а полный размер с учётом прокрутки – по аналогии, documentElement.scrollWidth/scrollHeight.
Это верно для обычных элементов.
А вот для страницы с этими свойствами возникает проблема, когда прокрутка то есть, то нет. В этом случае они работают некорректно. В браузерах Chrome/Safari и Opera при отсутствии прокрутки значение documentElement.scrollHeight в этом случае может быть даже меньше, чем documentElement.clientHeight, что, конечно же, выглядит как совершеннейшая чепуха и нонсенс.
Эта проблема возникает именно для documentElement, то есть для всей страницы.
Надёжно определить размер страницы с учетом прокрутки можно, взяв максимум из нескольких свойств:
 var scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert( 'Высота с учетом прокрутки: ' + scrollHeight );
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка страницы
BLOCK!@@

@@!QWESTION
Можно записать значения в свойства window.pageXOffset/pageYOffset?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У обычного элемента текущую прокрутку можно получить в scrollLeft/scrollTop.
Что же со страницей?
Большинство браузеров корректно обработает запрос к documentElement.scrollLeft/Top, однако Safari/Chrome/Opera есть ошибки (к примеру 157855, 106133), из-за которых следует использовать document.body.
Чтобы вообще обойти проблему, можно использовать специальные свойства window.pageXOffset/pageYOffset:
 alert( 'Текущая прокрутка сверху: ' + window.pageYOffset );
alert( 'Текущая прокрутка слева: ' + window.pageXOffset );
Эти свойства:
Не поддерживаются IE8-
Их можно только читать, а менять нельзя.
Если IE8- не волнует, то просто используем эти свойства.
Кросс-браузерный вариант с учётом IE8 предусматривает откат на documentElement:
 var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
alert( "Текущая прокрутка: " + scrollTop );

Прокрутку окна можно получить как window.pageYOffset (для горизонтальной – window.pageXOffset) везде, кроме IE8-.
На всякий случай – вот самый кросс-браузерный способ, учитывающий IE7- в том числе:
var html = document.documentElement;
var body = document.body;
var scrollTop = html.scrollTop || body && body.scrollTop || 0;
scrollTop -= html.clientTop; // в IE7- <html> смещён относительно (0,0)
alert( "Текущая прокрутка: " + scrollTop );
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка страницы
BLOCK!@@

@@!QWESTION
Как прокрутить страницу к указанным координатам относительно документа?
В чем отличие scrollTo(pageX,pageY) от scrollBy(x,y)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Первый прокручивает страницу к указанным координатам относительно документа, второй прокручивает страницу относительно текущих координат.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
На обычных элементах свойства scrollTop/scrollLeft можно изменять, и при этом элемент будет прокручиваться.
Никто не мешает точно так же поступать и со страницей. Во всех браузерах, кроме Chrome/Safari/Opera можно осуществить прокрутку установкой document.documentElement.scrollTop, а в указанных – использовать для этого document.body.scrollTop. И будет работать. Можно попробовать прокручивать и так и эдак и проверять, подействовала ли прокрутка, будет кросс-браузерно.
Но есть и другое, простое и универсальное решение – специальные методы прокрутки страницы window.scrollBy(x,y) и window.scrollTo(pageX,pageY).

Чтобы прокрутить страницу при помощи JavaScript, её DOM должен быть полностью загружен.
EXTENSION!@@



@@!BLOCK
Размеры и прокрутка страницы
BLOCK!@@

@@!QWESTION
Как прокрутится страница?
elem.scrollIntoView(false);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Страница прокруится до элемента так, чтобы он был внизу страницы.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для полноты картины рассмотрим также метод elem.scrollIntoView(top).
Метод elem.scrollIntoView(top) вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр top равен true, и внизу, если top равен false. Причем, если параметр top не указан, то он считается равным true.
EXTENSION!@@



@@!BLOCK
Координаты в окне
BLOCK!@@

@@!QWESTION
Как вычисляются координаты в getBoundingClientRect()?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Относительно текущей видимой области (окна).
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод elem.getBoundingClientRect() возвращает координаты элемента, под которыми понимаются размеры «воображаемого прямоугольника», который охватывает весь элемент.
Координаты возвращаются в виде объекта со свойствами:
top – Y-координата верхней границы элемента,
left – X-координата левой границы,
right – X-координата правой границы,
bottom – Y-координата нижней границы.

Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области.
Иначе говоря, если страницу прокрутить, то элемент поднимется выше или опустится ниже – его координаты относительно окна изменятся.

Координаты right/bottom отличаются от CSS-свойств
Если рассмотреть позиционирование элементов при помощи CSS-свойства position, то там тоже указываются left, right, top, bottom.
Однако, по CSS свойство right задаёт расстояние от правой границы, а bottom – от нижней.
Если вы взглянете на иллюстрацию выше, то увидите, что в JavaScript это не так. Все координаты отсчитываются слева/сверху, в том числе и эти.

Метод elem.getBoundingClientRect() изнутри
Браузер отображает любое содержимое, используя прямоугольники.
В случае с блочным элементом, таким как DIV, элемент сам по себе образует прямоугольник. Но если элемент строчный и содержит в себе длинный текст, то каждая строка будет отдельным прямоугольником, с одинаковой высотой но разной длиной (у каждой строки – своя длина).
Более подробно это описано в: спецификации.
Если обобщить, содержимое элемента может отображаться в одном прямоугольнике или в нескольких.
Все эти прямоугольники можно получить с помощью elem.getClientRects(). А метод elem.getBoundingClientRect() возвращает один охватывающий прямоугольник для всех getClientRects().
EXTENSION!@@



@@!BLOCK
Координаты в окне
BLOCK!@@

@@!QWESTION
Что возвращает elementFromPoint(x, y)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Элемент, который находится на координатах (x, y) относительно окна.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Этот метод получает координаты относительно окна и возвращает самый глубокий элемент, который там находится.
Для координат вне окна elementFromPoint возвращает null
Метод document.elementFromPoint(x,y) работает только если координаты (x,y) находятся в пределах окна.
Если одна из них отрицательна или больше чем ширина/высота окна – он возвращает null.
В большинстве случаев использования это не является проблемой, но нужно обязательно иметь такую возможность в виду.
EXTENSION!@@



@@!BLOCK
Координаты в документе
BLOCK!@@

@@!QWESTION
Как получить координаты относительно страницы?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
elem.getBoundingClientRect().left + pageXOffset
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Система координат относительно страницы или, иначе говоря, относительно документа, начинается в левом-верхнем углу, но не окна, а именно страницы.
И координаты в ней означают позицию по отношению не к окну браузера, а к документу в целом.
Если провести аналогию с CSS, то координаты относительно окна – это position:fixed, а относительно документа – position:absolute (при позиционировании вне других элементов, естественно).
Мы будем называть координаты в ней pageX/pageY.
Они нужны в первую очередь для того, чтобы показывать элемент в определённом месте страницы, а не окна.

К сожалению, готовой функции для получения координат элемента относительно страницы нет. Но её можно легко написать самим.
Эти две системы координат жёстко связаны: pageY = clientY + текущая вертикальная прокрутка.
Наша функция getCoords(elem) будет брать результат elem.getBoundingClientRect() и прибавлять текущую прокрутку документа.
Результат getCoords: объект с координатами {left: .., top: ..}
function getCoords(elem) { // кроме IE8-
  var box = elem.getBoundingClientRect();

  return {
    top: box.top + pageYOffset,
    left: box.left + pageXOffset
  };

}
Если нужно поддерживать более старые IE, то вот альтернативный, самый кросс-браузерный вариант:
function getCoords(elem) {
  // (1)
  var box = elem.getBoundingClientRect();

  var body = document.body;
  var docEl = document.documentElement;

  // (2)
  var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
  var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

  // (3)
  var clientTop = docEl.clientTop || body.clientTop || 0;
  var clientLeft = docEl.clientLeft || body.clientLeft || 0;

  // (4)
  var top = box.top + scrollTop - clientTop;
  var left = box.left + scrollLeft - clientLeft;

  return {
    top: top,
    left: left
  };
}
Разберем что и зачем, по шагам:
Получаем прямоугольник.
Считаем прокрутку страницы. Все браузеры, кроме IE8- поддерживают свойство pageXOffset/pageYOffset. В более старых IE, когда установлен DOCTYPE, прокрутку можно получить из documentElement, ну и наконец если DOCTYPE некорректен – использовать body.
В IE документ может быть смещен относительно левого верхнего угла. Получим это смещение.
Добавим прокрутку к координатам окна и вычтем смещение html/body, чтобы получить координаты нужного нам элемента.

У любой точки в браузере есть координаты:
Относительно окна window – elem.getBoundingClientRect().
Относительно документа document – добавляем прокрутку, во всех фреймворках есть готовая функция.
Относительно экрана screen – можно узнать координаты браузера, но не элемента.
EXTENSION!@@



@@!BLOCK
Координаты в документе
BLOCK!@@

@@!QWESTION
Что возвращает данное свойство screen.width?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ширину экрана
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Есть ещё одна система координат, которая используется очень редко, но для полноты картины необходимо её упомянуть.
Координаты относительно экрана screenX/screenY отсчитываются от его левого-верхнего угла. Имеется в виду именно весь экран, а не окно браузера.
Такие координаты могут быть полезны, например, при работе с мобильными устройствами или для открытия нового окна посередине экрана вызовом window.open.

Размеры экрана хранятся в глобальной переменной screen:
 // общая ширина/высота
alert( screen.width + ' x ' + screen.height );
// доступная ширина/высота (за вычетом таскбара и т.п.)
alert( screen.availWidth + ' x ' + screen.availHeight );
// есть и ряд других свойств screen (см. документацию)
Координаты левого-верхнего угла браузера на экране хранятся в window.screenX, window.screenY (не поддерживаются IE8-):
 alert( "Браузер находится на " + window.screenX + "," + window.screenY );
Они могут быть и меньше нуля, если окно частично вне экрана.
Заметим, что общую информацию об экране и браузере получить можно, а вот координаты конкретного элемента на экране – нельзя, нет аналога getBoundingClientRect или иного метода для этого.
EXTENSION!@@



@@!BLOCK
Введение в браузерные события
BLOCK!@@

@@!QWESTION
Данный код сработает?
<input type="button" id="button" value="Кнопка" onclick="sayThanks" />
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Функция должна быть присвоена как sayThanks, а не sayThanks().
button.onclick = sayThanks;
Если добавить скобки, то sayThanks() – будет уже результат выполнения функции (а так как в ней нет return, то в onclick попадёт undefined). Нам же нужна именно функция.
…А вот в разметке как раз скобки нужны:
<input type="button" id="button" onclick="sayThanks()" />
Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создает функцию из его содержимого. Поэтому последний пример – фактически то же самое, что:
button.onclick = function() {
  sayThanks(); // содержимое атрибута
};

Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал.
EXTENSION!@@



@@!BLOCK
Введение в браузерные события
BLOCK!@@

@@!QWESTION
Какой обработчик сработает?
input.onclick = function() { alert(1); } // 1
input.onclick = function() { alert(2); } // 2
QWESTION!@@

@@!ANSWERS

@@!CORRECT
2
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.
Например, одна часть кода хочет при клике на кнопку делать ее подсвеченной, а другая – выдавать сообщение. Нужно в разных местах два обработчика повесить.
При этом новый обработчик будет затирать предыдущий. Например, следующий код на самом деле назначает один обработчик – последний

Не используйте setAttribute.
Такой вызов работать не будет:
// при нажатии на body будут ошибки
// потому что при назначении в атрибут функция будет преобразована в строку
document.body.setAttribute('onclick', function() { alert(1) });
EXTENSION!@@



@@!BLOCK
Введение в браузерные события
BLOCK!@@

@@!QWESTION
Этот код удалит обработчик?
elem.addEventListener( "click" , function() {alert('Спасибо!')});
elem.removeEventListener( "click", function() {alert('Спасибо!')});
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Методы addEventListener и removeEventListener являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.
Назначение обработчика осуществляется вызовом addEventListener с тремя аргументами:
element.addEventListener(event, handler[, phase]);
event
Имя события, например click
handler
Ссылка на функцию, которую надо поставить обработчиком.
phase
Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен, мы его рассмотрим позже.

Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
Вот так removeEventListener не сработает:
elem.addEventListener( "click" , function() {alert('Спасибо!')});
// ....
elem.removeEventListener( "click", function() {alert('Спасибо!')});
В removeEventListener передана не та же функция, а другая, с одинаковым кодом, но это не важно.

Вот так правильно:
function handler() {
  alert( 'Спасибо!' );
}
input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
Обратим внимание – если функцию не сохранить где-либо, а просто передать в addEventListener, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener.

addEventListener работает всегда, а DOM-свойство – нет
У специальных методов есть ещё одно преимущество перед DOM-свойствами.
Есть некоторые события, которые нельзя назначить через DOM-свойство, но можно через addEventListener.
Например, таково событие transitionend, то есть окончание CSS-анимации. В большинстве браузеров оно требует назначения через addEventListener.
Вы можете проверить это, запустив код в примере ниже. Как правило, сработает лишь второй обработчик, но не первый.
<style>
  button {
    transition: width 1s;
    width: 100px;
  }

  .wide {
    width: 300px;
  }
</style>
<button id="elem" onclick="this.classList.toggle('wide');">
  Нажми меня
</button>
<script>
  elem.ontransitionend = function() {
    alert( "ontransitionend" ); // не сработает
  };
  elem.addEventListener("transitionend", function() {
    alert( "addEventListener" ); // сработает по окончании анимации
  });
</script>
EXTENSION!@@



@@!BLOCK
Введение в браузерные события
BLOCK!@@

@@!QWESTION
Обработчики, назначенные с attachEvent, получают this?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При работе с событиями в IE8- есть много отличий. Как правило, они формальны – некое свойство или метод называются по-другому. Начиная с версии 9, также работают и стандартные свойства и методы.
В IE8- вместо addEventListener/removeEventListener используются свои методы.
Назначение обработчика осуществляется вызовом attachEvent:
element.attachEvent("on" + event, handler);
Удаление обработчика – вызовом detachEvent:

element.detachEvent("on" + event, handler);
Например:
function handler() {
  alert( 'Спасибо!' );
}
button.attachEvent("onclick", handler) // Назначение обработчика
  // ....
button.detachEvent("onclick", handler) // Удаление обработчика

Как видите, почти то же самое, только событие должно включать префикс on.
У обработчиков, назначенных с attachEvent, нет this
Обработчики, назначенные с attachEvent не получают this!
Это важная особенность и подводный камень старых IE.
Чтобы ваш код работал в старом IE, нужно либо использовать DOM-свойства, то есть onclick, либо подключить полифилл для современных методов, например такой или с сервиса polyfill.io или какой-то другой.
EXTENSION!@@



@@!BLOCK
Порядок обработки событий
BLOCK!@@

@@!QWESTION
Что запишется в интут (во всех браузерах, кроме IE)?
<input type="button" id="button" value="Нажми меня">
<input type="text" id="text" size="60">
<script>
  button.onclick = function() {
    text.value += ' ->в onclick ';
    text.focus(); // вызов инициирует событие onfocus
    text.value += ' из onclick-> ';
  };
  text.onfocus = function() {
    text.value += ' !focus! ';
  };
</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
->в onclick  !focus!  из onclick->  !focus!
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Обычно возникающие события «становятся в очередь».
Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.

При этом обработчик onclick вызовет метод focus() на текстовом поле text. Код обработчика onfocus, который при этом запустится, сработает синхронно, прямо сейчас, до завершения onclick.
<input type="button" id="button" value="Нажми меня">
<input type="text" id="text" size="60">
<script>
  button.onclick = function() {
    text.value += ' ->в onclick ';
    text.focus(); // вызов инициирует событие onfocus
    text.value += ' из onclick-> ';
  };
  text.onfocus = function() {
    text.value += ' !focus! ';
  };
</script>
При клике на кнопке в примере выше будет видно, что управление вошло в onclick, затем перешло в onfocus, затем вышло из onclick.
Исключение в IE
Так ведут себя все браузеры, кроме IE.
В нём событие onfocus – всегда асинхронное, так что будет сначала полностью обработан клик, а потом – фокус. В остальных – фокус вызовется посередине клика. Попробуйте кликнуть в IE и в другом браузере, чтобы увидеть разницу.
EXTENSION!@@



@@!BLOCK
Объект события
BLOCK!@@

@@!QWESTION
Этот код сработает в IE8-?
elem.onclick = function(event){
  alert( event.clientX );
};
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
IE8- вместо передачи параметра обработчику создаёт глобальный объект window.event. Обработчик может обратиться к нему.
Работает это так:
elem.onclick = function() {
  // window.event - объект события
  alert( window.event.clientX );
};

Кроссбраузерное решение
Универсальное решение для получения объекта события:
element.onclick = function(event) {
  event = event || window.event; // (*)
  // Теперь event - объект события во всех браузерах.
};
EXTENSION!@@



@@!BLOCK
Всплытие и перехват
BLOCK!@@

@@!QWESTION
Что означает третий параметр (true) в обработчике?
elem.addEventListener("click", handler, true);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Событие будет обработано на «стадии перехвата» (capturing stage).
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
Строго говоря, стандарт выделяет целых три стадии прохода события:
Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
Событие достигло целевого элемента. Это – «стадия цели» (target stage).
После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).
В стандарте DOM Events 3 это продемонстрировано так:
То есть, при клике на TD событие путешествует по цепочке родителей сначала вниз к элементу («погружается»), а потом наверх («всплывает»), по пути задействуя обработчики.
Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.
Обработчики, добавленные через on...-свойство, ничего не знают о стадии перехвата, а начинают работать со всплытия.
Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
Если аргумент true, то событие будет перехвачено по дороге вниз.
Если аргумент false, то событие будет поймано при всплытии.
Стадия цели, обозначенная на рисунке цифрой (2), особо не обрабатывается, так как обработчики, назначаемые обоими этими способами, срабатывают также на целевом элементе.
Есть события, которые не всплывают, но которые можно перехватить
Бывают события, которые можно поймать только на стадии перехвата, а на стадии всплытия – нельзя…
Например, таково событие фокусировки на элементе onfocus. Конечно, это большая редкость, такое исключение существует по историческим причинам.
EXTENSION!@@



@@!BLOCK
Всплытие и перехват
BLOCK!@@

@@!QWESTION
Чем отличается event.stopImmediatePropagation() от "event.stopPropagation()?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
event.stopImmediatePropagation() не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
event.stopImmediatePropagation()
Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
То есть, stopPropagation препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.
Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

Не прекращайте всплытие без необходимости!
Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.
Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.
Например:
Мы делаем меню. Оно обрабатывает клики на своих элементах и делает для них stopPropagation. Вроде бы, всё работает.
Позже мы решили отслеживать все клики в окне, для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Например, Яндекс.Метрика так делает, если включить соответствующую опцию.
Над областью, где клики убиваются stopPropagation, статистика работать не будет! Получилась «мёртвая зона».
Проблема в том, что stopPropagation убивает всякую возможность отследить событие сверху, а это бывает нужно для реализации чего-нибудь «эдакого», что к меню отношения совсем не имеет.
EXTENSION!@@



@@!BLOCK
Всплытие и перехват
BLOCK!@@

@@!QWESTION
Где используется подобная запись event.srcElement?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
В IE8-
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Чтобы было проще ориентироваться, я собрал отличия IE8-, которые имеют отношение ко всплытию, в одну секцию.
Их знание понадобится, если вы решите писать на чистом JS, без фреймворков и вам понадобится поддержка IE8-.
Нет свойства event.currentTarget
Обратим внимание, что при назначении обработчика через onсвойство у нас есть this, поэтому event.currentTarget, как правило, не нужно, а вот при назначении через attachEvent обработчик не получает this, так что текущий элемент, если нужен, можно будет взять лишь из замыкания.
Вместо event.target в IE8- используется event.srcElement
Если мы пишем обработчик, который будет поддерживать и IE8- и современные браузеры, то можно начать его так:
elem.onclick = function(event) {
  event = event || window.event;
  var target = event.target || event.srcElement;
  // ... теперь у нас есть объект события и target
  ...
}
Для остановки всплытия используется код event.cancelBubble=true.
Кросс-браузерно остановить всплытие можно так:
event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);
EXTENSION!@@



@@!BLOCK
73--Действия браузера по умолчанию
BLOCK!@@

@@!QWESTION
Как отменить действие по умолчанию?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
event.preventDefault()
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если же обработчик назначен через onсобытие (не через addEventListener), то можно просто вернуть false из обработчика.
В следующем примере при клике по ссылке переход не произойдет:
<a href="/" onclick="return false">Нажми здесь</a>
Возвращать true не нужно
Обычно значение, которое возвращает обработчик события, игнорируется.
Единственное исключение – это return false из обработчика, назначенного через onсобытие.
Иногда в коде начинающих разработчиков можно увидеть return других значений. Но они не нужны и никак не обрабатываются.

В IE8- для отмены действия по умолчанию нужно назначить свойство event.returnValue = false.
Кроссбраузерный код для отмены действия по умолчанию:
element.onclick = function(event) {
  event = event || window.event;
  if (event.preventDefault) { // если метод существует
    event.preventDefault(); // то вызвать его
  } else { // иначе вариант IE8-:
    event.returnValue = false;
  }
}
EXTENSION!@@



@@!BLOCK
74--Генерация событий на элементах
BLOCK!@@

@@!QWESTION
Что вернёт element.dispatchEvent(event), если в сгенерированном событии вызван event.preventDefault()?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
false
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вначале рассмотрим современный способ генерации событий, по стандарту DOM 4. Он поддерживается всеми браузерами, кроме IE11-. А далее рассмотрим устаревшие варианты, поддерживаемые IE.
Объект события в нём создаётся при помощи встроенного конструктора Event.

Синтаксис:
var event = new Event(тип события[, флаги]);

Где:
Тип события – может быть как своим, так и встроенным, к примеру "click".
Флаги – объект вида { bubbles: true/false, cancelable: true/false }, где свойство bubbles указывает, всплывает ли событие, а cancelable – можно ли отменить действие по умолчанию.
Флаги по умолчанию: {bubbles: false, cancelable: false}.

Затем, чтобы инициировать событие, запускается elem.dispatchEvent(event).
При этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг bubbles, то оно будет всплывать.
При просмотре примера ниже обработчик onclick на кнопке сработает сам по себе, событие генерируется скриптом:
 <button id="elem" onclick="alert('Клик');">Автоклик</button>
<script>
  var event = new Event("click");
  elem.dispatchEvent(event);
</script>

На сгенерированном событии, как и на встроенном браузерном, обработчик может вызвать метод event.preventDefault(). Тогда dispatchEvent возвратит false.
Остановимся здесь подробнее. Обычно вызов preventDefault() предотвращает действие браузера. В случае, если событие придумано нами, имеет нестандартное имя – никакого действия браузера, конечно, нет.
Но код, который генерирует событие, может предусматривать какие-то ещё действия после dispatchEvent.
Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия продолжать не надо.
В примере ниже есть функция hide(), которая при вызове генерирует событие hide на элементе #rabbit, уведомляя всех интересующихся, что кролик собирается спрятаться.
Любой обработчик может узнать об этом, подписавшись на событие через rabbit.addEventListener('hide',...) и, при желании, отменить действие по умолчанию через event.preventDefault(). Тогда кролик не исчезнет:
 <pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<script>
  function hide() {
    var event = new Event("hide", {
      cancelable: true
    });
    if (!rabbit.dispatchEvent(event)) {
      alert( 'действие отменено обработчиком' );
    } else {
      rabbit.hidden = true;
    }
  }
  rabbit.addEventListener('hide', function(event) {
    if (confirm("Вызвать preventDefault?")) {
      event.preventDefault();
    }
  });
  // прячемся через 2 секунды
  setTimeout(hide, 2000);
</script>

Как отличить реальное нажатие от скриптового?
В целях безопасности иногда хорошо бы знать – инициировано ли действие посетителем или это кликнул скрипт.
Единственный способ, которым код может отличить реальное нажатие от программного, является проверка свойства event.isTrusted.
Оно на момент написания статьи поддерживается IE и Firefox и равно true, если посетитель кликнул сам, и всегда false – если событие инициировал скрипт.
EXTENSION!@@



@@!BLOCK
Генерация событий на элементах
BLOCK!@@

@@!QWESTION
Чему равно значение свойства bubbles по умолчанию?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
false
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Другие свойства событий
При создании события браузер автоматически ставит следующие свойства:
isTrusted: false – означает, что событие сгенерировано скриптом, это свойство изменить невозможно.
target: null – это свойство ставится автоматически позже при dispatchEvent.
type: тип события – первый аргумент new Event.
bubbles, cancelable – false, по второму аргументу new Event.

Как правило события имеет смысл генерировать:
Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.
Либо при создании своих «элементов интерфейса». Например, никто не мешает при помощи JavaScript создать из <div class="calendar"> красивый календарь и генерировать на нём событие change при выборе даты. Эту тему мы разовьём позже.
EXTENSION!@@



@@!BLOCK
Генерация событий на элементах
BLOCK!@@

@@!QWESTION
Чем отличаются специализированные конструкторы MouseEvent, KeyboardEvent и другие от Event?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Специфический конструктор позволяет указать стандартные свойства для данного типа события.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Например, clientX/clientY для события мыши:
var e = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});
alert( e.clientX ); // 100

Впрочем, использование конкретного конструктора не является обязательным, можно обойтись Event, а свойства записать в объект отдельно, после конструктора. 
EXTENSION!@@



@@!BLOCK
Генерация событий на элементах
BLOCK!@@

@@!QWESTION
Чем отличаются конструкторы Event и CustomEvent?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Наличием дополнительное свойство detail у второго аргумента-объекта
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для генерации своих, нестандартных, событий, хоть и можно использовать конструктор Event, но существует и специфический конструктор CustomEvent.
Технически, он абсолютно идентичен Event, кроме небольшой детали: у второго аргумента-объекта есть дополнительное свойство detail, в котором можно указывать информацию для передачи в событие.
Например:
<h1 id="elem">Привет для Васи!</h1>
<script>
  elem.addEventListener("hello", function(event) {
    alert( event.detail.name );
  }, false);
  var event = new CustomEvent("hello", {
    detail: { name: "Вася" }
  });
  elem.dispatchEvent(event);
</script>
EXTENSION!@@



@@!BLOCK
Генерация событий на элементах
BLOCK!@@

@@!QWESTION
Как создать обьъект события в IE9?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
var event = document.createEvent(eventInterface);
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Способ генерации событий, описанный выше, не поддерживается в IE11-, там нужен другой, более старый способ, описанный в стандарте DOM 3 Events.
В нём была предусмотрена иерархия событий, с различными методами инициализации.
Она поддерживается как современными браузерами, так и IE9+. Там используется немного другой синтаксис, но по возможностям – всё то же самое, что и в современном стандарте.
Можно использовать этот немного устаревший способ, если нужно поддерживать IE9+. Далее мы на его основе создадим полифилл.
Объект события создаётся вызовом document.createEvent:
var event = document.createEvent(eventInterface);

Аргументы:
eventInterface – это тип события, например MouseEvent, FocusEvent, KeyboardEvent. В секции 5 DOM 3 Events есть подробный список, какое событие к какому интерфейсу относится.
На практике можно всегда использовать самый общий интерфейс: document.createEvent("Event").

Далее событие нужно инициализировать:
event.initEvent(type, boolean bubbles, boolean cancelable);

Аргументы:
type – тип события, например "click".
bubbles – всплывает ли событие.
cancelable – можно ли отменить событие.

initMouseEvent, initKeyboardEvent и другие…
У конкретных типов событий, например MouseEvent, KeyboardEvent, есть методы, которые позволяют указать стандартные свойства.
Они называются по аналогии: initMouseEvent, initKeyboardEvent.
Их можно использовать вместо базового initEvent, если хочется, чтобы свойства событий соответствовали встроенным браузерным.
Выглядят они немного страшновато, например (взято из спецификации):
void initMouseEvent(
  DOMString typeArg, // тип
  boolean bubblesArg, // всплывает?
  boolean cancelableArg, // можно отменить?
  AbstractView ? viewArg, // объект window, null означает текущее окно
  long detailArg, // свойство detail и другие...
  long screenXArg,
  long screenYArg,
  long clientXArg,
  long clientYArg,
  boolean ctrlKeyArg,
  boolean altKeyArg,
  boolean shiftKeyArg,
  boolean metaKeyArg,
  unsigned short buttonArg,
  EventTarget ? relatedTargetArg);
};
Для инициализации мышиного события нужно обязательно указать все аргументы, например:
<button id="elem">Автоклик</button>
<script>
  elem.onclick = function(e) {
    alert( 'Клик на координатах ' + e.clientX + ':' + e.clientY );
  };
  var event = document.createEvent("MouseEvent");
  event.initMouseEvent("click", true, true, null, 0, 0, 0, 100, 100, true, true, true, null, 1, null);
  elem.dispatchEvent(event);
</script>
Браузер, по стандарту, может сгенерировать отсутствующие свойства самостоятельно, например pageX, но это нужно проверять в конкретных случаях, иногда это не работает или работает некорректно, так что лучше указать все.

В совсем старом IE были «свои» методы document.createEventObject() и elem.fireEvent().
Пример с ними для IE8:
<button id="elem">Автоклик</button>
<script>
  document.body.onclick = function() {
    alert( "Клик, event.type=" + event.type );
    return false;
  };
  var event = document.createEventObject();
  if (!elem.fireEvent("onclick", event)) {
    alert( 'Событие было отменено' );
  }
</script>
При помощи fireEvent можно сгенерировать только встроенные события.
Если указать "hello" вместо "onclick" в примере выше – будет ошибка.
Параметры bubbles и cancelable настраивать нельзя, браузер использует стандартные для данного типа событий.
EXTENSION!@@



@@!BLOCK
75--Мышь: клики, кнопка, координаты
BLOCK!@@

@@!QWESTION
Какая кнопка мыши нажата если event.which == 2?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Средняя 
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При обработке событий, связанных с кликами мыши, бывает важно знать, какая кнопка нажата.
Для получения кнопки мыши в объекте event есть свойство which.
На практике оно используется редко, т.к. обычно обработчик вешается либо onclick – только на левую кнопку мыши, либо oncontextmenu – только на правую.

Возможны следующие значения:
event.which == 1 – левая кнопка
event.which == 2 – средняя кнопка
event.which == 3 – правая кнопка

В старых IE8- не поддерживалось свойство which, а вместо него использовалось свойство button, которое является 3-х битным числом, в котором каждому биту соответствует кнопка мыши. Бит установлен в 1, только если соответствующая кнопка нажата.
Чтобы его расшифровать – нужна побитовая операция & («битовое И»):
!!(button & 1) == true (1-й бит установлен), если нажата левая кнопка,
!!(button & 2) == true (2-й бит установлен), если нажата правая кнопка,
!!(button & 4) == true (3-й бит установлен), если нажата средняя кнопка.

Что интересно, при этом мы можем узнать, были ли две кнопки нажаты одновременно, в то время как стандартный which такой возможности не даёт. Так что, в некотором смысле, свойство button – более мощное.
Можно легко сделать функцию, которая будет ставить свойство which из button, если его нет:
function fixWhich(e) {
  if (!e.which && e.button) { // если which нет, но есть button... (IE8-)
    if (e.button & 1) e.which = 1; // левая кнопка
    else if (e.button & 4) e.which = 2; // средняя кнопка
    else if (e.button & 2) e.which = 3; // правая кнопка
  }
}
EXTENSION!@@



@@!BLOCK
Мышь: клики, кнопка, координаты
BLOCK!@@

@@!QWESTION
Когда срабатывает событие oncontextmenu?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
При клике правой кнопкой мыши
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Мышь: клики, кнопка, координаты
BLOCK!@@

@@!QWESTION
В каком случает значением свойства event.altKey будет true?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Когда в момент события клик была нажата клавиша Alt
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Во всех событиях мыши присутствует информация о нажатых клавишах-модификаторах.
Соответствующие свойства:
shiftKey
altKey
ctrlKey
metaKey (для Mac)
Например, кнопка ниже сработает только на Alt+Shift+Клик:
<button>Alt+Shift+Кликни меня!</button>
<script>
  document.body.children[0].onclick = function(e) {
    if (!e.altKey || !e.shiftKey) return;
    alert( 'Ура!' );
  }
</script>
Внимание: на Mac вместо Ctrl используется Cmd
На компьютерах под управлением Windows и Linux есть специальные клавиши Alt, Shift и Ctrl. На Mac есть ещё одна специальная клавиша: Cmd, которой соответствует свойство metaKey.
В большинстве случаев там, где под Windows/Linux используется Ctrl, на Mac используется Cmd. Там, где пользователь Windows нажимает Ctrl+Enter или Ctrl+A, пользователь Mac нажмёт Cmd+Enter или Cmd+A, и так далее, почти всегда Cmd вместо Ctrl.
Поэтому, если мы хотим поддерживать сочетание Ctrl+click или другие подобные, то под Mac имеет смысл использовать Cmd+click. Пользователям Mac это будет гораздо комфортнее.
Более того, даже если бы мы хотели бы заставить пользователей Mac использовать именно Ctrl+click – это было бы затруднительно. Дело в том, что обычный клик с зажатым Ctrl под Mac работает как правый клик и генерирует событие oncontextmenu, а вовсе не onclick, как под Windows/Linux.
Решение – чтобы пользователи обоих операционных систем работали с комфортом, в паре с ctrlKey нужно обязательно использовать metaKey.
В JS-коде это означает, что для удобства пользователей Mac нужно проверять if (event.ctrlKey || event.metaKey).
EXTENSION!@@



@@!BLOCK
Мышь: клики, кнопка, координаты
BLOCK!@@

@@!QWESTION
Какое из этих свойств предоставляет текущие координаты курсора по горизонтали относительно окна: clientX, pageX?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
clientX
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Все мышиные события предоставляют текущие координаты курсора в двух видах: относительно окна и относительно документа.
Пара свойств clientX/clientY содержит координаты курсора относительно текущего окна.
При этом, например, если ваше окно размером 500x500, а мышь находится в центре, тогда и clientX и clientY будут равны 250.
Можно как угодно прокручивать страницу, но если не двигать при этом мышь, то координаты курсора clientX/clientY не изменятся, потому что они считаются относительно окна, а не документа.
В той же системе координат работает и метод elem.getBoundingClientRect(), возвращающий координаты элемента, а также position:fixed.
Относительно документа: pageX/Y
Координаты курсора относительно документа находятся в свойствах pageX/pageY.
Так как эти координаты – относительно левого-верхнего узла документа, а не окна, то они учитывают прокрутку. Если прокрутить страницу, а мышь не трогать, то координаты курсора pageX/pageY изменятся на величину прокрутки, они привязаны к конкретной точке в документе.
В IE8- этих свойств нет, но можно получить их способом, описанным в конце главы.
Устарели: x, y, layerX, layerY
Некоторые браузеры поддерживают свойства event.x/y, event.layerX/layerY.
Эти свойства устарели, они нестандартные и не добавляют ничего к описанным выше. Использовать их не стоит.
EXTENSION!@@



@@!BLOCK
Мышь: клики, кнопка, координаты
BLOCK!@@

@@!QWESTION
Можно ли отловить двойной клик в IE8-, отслеживая только click? Какое событие нужно отслеживать?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет. Нужно событие dblclick.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Все браузеры, кроме IE8-, генерируют dblclick в дополнение к другим событиям.
То есть, обычно:
mousedown (нажал)
mouseup+click (отжал)
mousedown (нажал)
mouseup+click+dblclick (отжал).

IE8- на втором клике не генерирует mousedown и click.
Получается:
mousedown (нажал)
mouseup+click (отжал)
(нажал второй раз, без события)
mouseup+dblclick (отжал).
Поэтому отловить двойной клик в IE8-, отслеживая только click, нельзя, ведь при втором нажатии его нет. Нужно именно событие dblclick.
EXTENSION!@@



@@!BLOCK
76--Мышь: отмена выделения, невыделяемые элементы
BLOCK!@@

@@!QWESTION
Чтобы избежать выделения, нужно предотвратить действие браузера по умолчанию для события ___ в IE и mousedown в других браузерах.
Для какого события в IE?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
selectstart
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Чтобы избежать выделения, мы должны предотвратить действие браузера по умолчанию для события selectstart в IE и mousedown в других браузерах.
При установке на родителя – все его потомки станут невыделяемыми.
Выделение, всё же, возможно
Отмена действия браузера при mousedown/selectstart отменяет выделение при клике, но не запрещает его полностью.
Если пользователь всё же хочет выделить текстовое содержимое элемента, то он может сделать это.
Достаточно начать выделение (зажать кнопку мыши) не на самом элементе, а рядом с ним. Ведь там отмены не произойдёт, выделение начнётся, и дальше можно передвинуть мышь уже на элемент.
EXTENSION!@@



@@!BLOCK
Мышь: отмена выделения, невыделяемые элементы
BLOCK!@@

@@!QWESTION
CSS- свойство user-select стандартное?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Существует нестандартное CSS-свойство user-select, которое делает элемент невыделяемым.
Оно когда-то планировалось в стандарте CSS3, потом от него отказались, но поддержка в браузерах уже была сделана и потому осталась.
Это свойство работает (с префиксом) везде, кроме IE9-:
<style>
  b {
    -webkit-user-select: none;
    /* user-select -- это нестандартное свойство */

    -moz-user-select: none;
    /* поэтому нужны префиксы */

    -ms-user-select: none;
  }
</style>
Строка до..
<div ondblclick="alert('Тест')">
  <b>Этот текст нельзя выделить (кроме IE9-)</b>
</div>
.. Строка после

Читайте на эту тему также Controlling Selection with CSS user-select.
EXTENSION!@@




@@!BLOCK
Мышь: отмена выделения, невыделяемые элементы
BLOCK!@@

@@!QWESTION
unselectable=«on» в IE9- наследуется?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В IE9- нет user-select, но есть атрибут unselectable.
Он отменяет выделение, но у него есть особенности:
Во-первых, невыделяемость не наследуется. То есть, невыделяемость родителя не делает невыделяемыми детей.
Во-вторых, текст, в отличие от user-select, всё равно можно выделить, если начать выделение не на самом элементе, а рядом с ним.
EXTENSION!@@



@@!BLOCK
77--Мышь: движение mouseover/out, mouseenter/leave
BLOCK!@@

@@!QWESTION
Какая информация хранится в event.relatedTarget для mouseover?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Элемент, с которого пришла мышь.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие mouseover происходит, когда мышь появляется над элементом, а mouseout – когда уходит из него.

«Лишний» mouseout при уходе на потомка
Представьте ситуацию – курсор зашёл на элемент. Сработал mouseover на нём. Потом курсор идёт на дочерний… И, оказывается, на элементе-родителе при этом происходит mouseout! Как будто курсор с него ушёл, хотя он всего лишь перешёл на потомка.
При переходе на потомка срабатывает mouseout на родителе.
Это кажется странным, но легко объяснимо.
Согласно браузерной логике, курсор мыши может быть только над одним элементом – самым глубоким в DOM (и верхним по z-index).
Так что если он перешел куда-нибудь, то автоматически ушёл с предыдущего элемента. Всё просто.
Самое забавное начинается чуть позже.
Ведь события mouseover и mouseout всплывают.
Получается, что если поставить обработчики mouseover и mouseout на #FROM и #TO, то последовательность срабатывания при переходе #FROM → #TO будет следующей:
mouseout на #FROM (с event.target=#FROM, event.relatedTarget=#TO).
mouseover на #TO (с event.target=#TO, event.relatedTarget=#FROM).
Событие mouseover после срабатывания на #TO всплывает выше, запуская обработчики mouseover на родителях. Ближайший родитель – как раз #FROM, то есть сработает обработчик mouseover на нём, с теми же значениями target/relatedTarget.
Если посмотреть на 1) и 3), то видно, что на #FROM сработает сначала mouseout, а затем с #TO всплывёт mouseover.
Если по mouseover мы что-то показываем, а по mouseout – скрываем, то получится «мигание».
У обработчиков создаётся впечатление, что курсор ушёл mouseout с родителя, а затем тут же перешёл mouseover на него (за счёт всплытия mouseover с потомка).
EXTENSION!@@



@@!BLOCK
Мышь: движение mouseover/out, mouseenter/leave
BLOCK!@@

@@!QWESTION
Какая информация хранится в event.relatedTarget для mouseout?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Элемент, на который перешла мышь.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие mouseover происходит, когда мышь появляется над элементом, а mouseout – когда уходит из него.

relatedTarget может быть null
Свойство relatedTarget может быть равно null.
Это вполне нормально и означает, что мышь пришла не с другого элемента, а из-за пределов окна (или ушла за окно). Мы обязательно должны иметь в виду такую возможность, когда пишем код, который обращается к свойствам event.relatedTarget.

Частота событий
Событие mousemove срабатывает при передвижении мыши. Но это не значит, что каждый пиксель экрана порождает отдельное событие!
События mousemove и mouseover/mouseout срабатывают так часто, насколько это позволяет внутренняя система взаимодействия с мышью браузера.
Это означает, что если посетитель двигает мышью быстро, то DOM-элементы, через которые мышь проходит на большой скорости, могут быть пропущены.
При быстром движении с элемента #FROM до элемента #TO, как изображено на картинке выше – промежуточные <DIV> будут пропущены. Сработает только событие mouseout на #FROM и mouseover на #TO.
На практике это полезно, потому что таких промежуточных элементов может быть много, и если обрабатывать заход и уход с каждого, будут дополнительные вычислительные затраты.
С другой стороны, мы должны это понимать и не рассчитывать на то, что мышь аккуратно пройдёт с одного элемента на другой и так далее. Нет, она «прыгает».
В частности, возможна ситуация, когда курсор прыгает в середину страницы, и при этом relatedTarget=null, то есть он пришёл «ниоткуда» (на самом деле извне окна):
Обратим внимание ещё на такую деталь. При быстром движении курсор окажется над #TO сразу, даже если этот элемент глубоко в DOM. Его родители при движении сквозь них события не поймают.
EXTENSION!@@



@@!BLOCK
Мышь: движение mouseover/out, mouseenter/leave
BLOCK!@@

@@!QWESTION
mouseleave "всплывает"?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже срабатывают, когда курсор заходит на элемент и уходит с него, но с двумя отличиями.
Не учитываются переходы внутри элемента.
События mouseenter/mouseleave не всплывают.
Эти события более интуитивно понятны.

Курсор заходит на элемент – срабатывает mouseenter, а затем – неважно, куда он внутри него переходит, mouseleave будет, когда курсор окажется за пределами элемента.
EXTENSION!@@



@@!BLOCK
Мышь: движение mouseover/out, mouseenter/leave
BLOCK!@@

@@!QWESTION
Какой аналог для relatedTarget для mouseout используется в IE8-?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
toElement 
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В IE8- нет свойства relatedTarget. Вместо него используется fromElement для mouseover и toElement для mouseout.
EXTENSION!@@



@@!BLOCK
78--Мышь: колёсико, событие wheel
BLOCK!@@

@@!QWESTION
Событие onwheel срабатывает до прокрутки?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Несмотря на то, что колёсико мыши обычно ассоциируется с прокруткой, это совсем разные вещи.
При прокрутке срабатывает событие onscroll – рассмотрим его в дальнейшем. Оно произойдёт при любой прокрутке, в том числе через клавиатуру, но только на прокручиваемых элементах. Например, элемент с overflow:hidden в принципе не может сгенерировать onscroll.
А событие wheel является чисто «мышиным». Оно генерируется над любым элементом при передвижении колеса мыши. При этом не важно, прокручиваемый он или нет. В частности, overflow:hidden никак не препятствует обработке колеса мыши.
Кроме того, событие onscroll происходит после прокрутки, а onwheel – до прокрутки, поэтому в нём можно отменить саму прокрутку (действие браузера).

Зоопарк wheel в разных браузерах
Событие wheel появилось в стандарте не так давно. Оно поддерживается Chrome 31+, IE9+, Firefox 17+.
До него браузеры обрабатывали прокрутку при помощи событий mousewheel (все кроме Firefox) и DOMMouseScroll, MozMousePixelScroll (только Firefox).
Самые важные свойства современного события и его нестандартных аналогов:
wheel
Свойство deltaY – количество прокрученных пикселей по вертикали. Существуют также свойства deltaX и deltaZ для других направлений прокрутки.
MozMousePixelScroll
Срабатывает, начиная с Firefox 3.5, только в Firefox. Даёт возможность отменить прокрутку и получить размер в пикселях через свойство detail, ось прокрутки в свойстве axis.
mousewheel
Срабатывает в браузерах, которые ещё не реализовали wheel. В свойстве wheelDelta – условный «размер прокрутки», обычно равен 120 для прокрутки вверх и -120 – вниз. Он не соответствует какому-либо конкретному количеству пикселей.
Чтобы кросс-браузерно отловить прокрутку и, при необходимости, отменить её, можно использовать все эти события.

Пример, включающий поддержку IE8-:
if (elem.addEventListener) {
  if ('onwheel' in document) {
    // IE9+, FF17+, Ch31+
    elem.addEventListener("wheel", onWheel);
  } else if ('onmousewheel' in document) {
    // устаревший вариант события
    elem.addEventListener("mousewheel", onWheel);
  } else {
    // Firefox < 17
    elem.addEventListener("MozMousePixelScroll", onWheel);
  }
} else { // IE8-
  elem.attachEvent("onmousewheel", onWheel);
}

function onWheel(e) {
  e = e || window.event;
  // wheelDelta не дает возможность узнать количество пикселей
  var delta = e.deltaY || e.detail || e.wheelDelta;
  var info = document.getElementById('delta');
  info.innerHTML = +info.innerHTML + delta;
  e.preventDefault ? e.preventDefault() : (e.returnValue = false);
}

Ошибка в IE8
В браузере IE8 (только версия 8) есть ошибка. При наличии обработчика mousewheel – элемент не скроллится. Иначе говоря, действие браузера отменяется по умолчанию.	
Это, конечно, не имеет значения, если элемент в принципе не прокручиваемый.

------

Эта глава и описанная далее функция fixEvent нужны только для поддержки IE8-.
Если IE8- для Вас неактуален, то пролистывайте дальше, это читать Вам не надо.
Функция fixEvent предназначена для запуска в начале обработчика, вот так:
elem.onclick = function(event) {
  // если IE8-, то получить объект события window.event и исправить его
  event = event || fixEvent.call(this, window.event);
  ...
}
Она добавит объекту события в IE8- следующие стандартные свойства:
target
currentTarget – если обработчик назначен не через attachEvent.
relatedTarget – для mouseover/mouseout и mouseenter/mouseleave.
pageX/pageY
which

Код функции:
function fixEvent(e) {
  e.currentTarget = this;
  e.target = e.srcElement;
  if (e.type == 'mouseover' || e.type == 'mouseenter') e.relatedTarget = e.fromElement;
  if (e.type == 'mouseout' || e.type == 'mouseleave') e.relatedTarget = e.toElement;
  if (e.pageX == null && e.clientX != null) {
    var html = document.documentElement;
    var body = document.body;
    e.pageX = e.clientX + (html.scrollLeft || body && body.scrollLeft || 0);
    e.pageX -= html.clientLeft || 0;
    e.pageY = e.clientY + (html.scrollTop || body && body.scrollTop || 0);
    e.pageY -= html.clientTop || 0;
  }
  if (!e.which && e.button) {
    e.which = e.button & 1 ? 1 : (e.button & 2 ? 3 : (e.button & 4 ? 2 : 0));
  }
  return e;
}
EXTENSION!@@



@@!BLOCK
79--Клавиатура: keyup, keydown, keypress
BLOCK!@@

@@!QWESTION
Скан-код одинаковый для разных раскладок на одной клавише?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
События keydown/keyup происходят при нажатии/отпускании клавиши и позволяют получить её скан-код в свойстве keyCode.
Скан-код клавиши одинаков в любой раскладке и в любом регистре. Например, клавиша z может означать символ "z", "Z" или "я", "Я" в русской раскладке, но её скан-код будет всегда одинаков: 90.

Когда-то в этих кодах была масса кросс-браузерных несовместимостей. Сейчас всё проще – таблицы кодов в различных браузерах почти полностью совпадают. Но некоторые несовместимости, всё же, остались. Вы можете увидеть их в таблице ниже. Слева – клавиша с символом, а справа – скан-коды в различных браузерах.
Таблица несовместимостей:
Клавиша	Firefox	Остальные браузеры
;	 59	  186
=	 107  187
-	 109  189
EXTENSION!@@



@@!BLOCK
Клавиатура: keyup, keydown, keypress
BLOCK!@@

@@!QWESTION
Нажатие клавише "F1" генерирует keypress?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие keypress возникает сразу после keydown, если нажата символьная клавиша, т.е. нажатие приводит к появлению символа.
Любые буквы, цифры генерируют keypress. Управляющие клавиши, такие как Ctrl, Shift, F1, F2… – keypress не генерируют.
Событие keypress позволяет получить код символа. В отличие от скан-кода, он специфичен именно для символа и различен для "z" и "я".
Код символа хранится в свойствах: charCode и which. Здесь скрывается целое «гнездо» кросс-браузерных несовместимостей, разбираться с которыми нет никакого смысла – запомнить сложно, а на практике нужна лишь одна «правильная» функция, позволяющая получить код везде.
Получение символа в keypress
Кросс-браузерная функция для получения символа из события keypress:
// event.type должен быть keypress
function getChar(event) {
  if (event.which == null) { // IE
    if (event.keyCode < 32) return null; // спец. символ
    return String.fromCharCode(event.keyCode)
  }
  if (event.which != 0 && event.charCode != 0) { // все кроме IE
    if (event.which < 32) return null; // спец. символ
    return String.fromCharCode(event.which); // остальные
  }
  return null; // спец. символ
}
Для общей информации – вот основные браузерные особенности, учтённые в getChar(event):
Во всех браузерах, кроме IE, у события keypress есть свойство charCode, которое содержит код символа.
Браузер IE для keypress не устанавливает charCode, а вместо этого он записывает код символа в keyCode (в keydown/keyup там хранится скан-код).
Также в функции выше используется проверка if(event.which!=0), а не более короткая if(event.which). Это не случайно! При event.which=null первое сравнение даст true, а второе – false.

При keydown/keypress значение ещё старое
На момент срабатывания keydown/keypress клавиша ещё не обработана браузером.
Поэтому в обработчике значение input.value – старое, т.е. до ввода.
А что, если мы хотим обработать input.value именно после ввода? Самое простое решение – использовать событие keyup, либо запланировать обработчик через setTimeout(..,0).

Автоповтор
При долгом нажатии клавиши возникает автоповтор. По стандарту, должны генерироваться многократные события keydown (+keypress), и вдобавок стоять свойство repeat=true у объекта события.
То есть поток событий должен быть такой:
keydown
keypress
keydown
keypress
..повторяется, пока клавиша не отжата...
keyup

Однако в реальности на это полагаться нельзя. На момент написания статьи, под Firefox(Linux) генерируется и keyup:
keydown
keypress
keyup
keydown
keypress
keyup
..повторяется, пока клавиша не отжата...
keyup
…А Chrome под MacOS не генерирует keypress. В общем, «зоопарк».
Полагаться можно только на keydown при каждом автонажатии и keyup по отпусканию клавиши.

Итого
Ряд рецептов по итогу этой главы:
- Для реализации горячих клавиш, включая сочетания – используем keydown. Скан-код будет в keyCode, почти все скан-коды кросс-браузерны, кроме нескольких пунктуационных, перечисленных в таблице выше.
- Если нужен именно символ – используем keypress. При этом функция getChar позволит получить символ и отфильтровать лишние срабатывания. Гарантированно получать символ можно только при нажатии обычных клавиш, если речь о сочетаниях с модификаторами, то keypress не всегда генерируется.
- Ловля CapsLock глючит под MacOS. Её можно организовать при помощи проверки navigator.userAgent и navigator.platform, а лучше вообще не трогать эту клавишу.
EXTENSION!@@



@@!BLOCK
80--Загрузка документа: DOMContentLoaded, load, beforeunload, unload
BLOCK!@@

@@!QWESTION
Какими будут размеры картинки в alert?
<script>
  function ready() {
    alert( "Размеры картинки: " + img.offsetWidth + "x" + img.offsetHeight );
  }
  document.addEventListener("DOMContentLoaded", ready);
</script>
<img id="img" src="https://js.cx/clipart/yozhik.jpg?speed=1">
QWESTION!@@

@@!ANSWERS

@@!CORRECT
0х0
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Процесс загрузки HTML-документа, условно, состоит из трёх стадий:

DOMContentLoaded – браузер полностью загрузил HTML и построил DOM-дерево.
load – браузер загрузил все ресурсы.
beforeunload/unload – уход со страницы.
Все эти стадии очень важны. На каждую можно повесить обработчик, чтобы совершить полезные действия:

DOMContentLoaded – означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, ещё не догрузились какие-то картинки или стили.
load – страница и все ресурсы загружены, используется редко, обычно нет нужды ждать этого момента.
beforeunload/unload – можно проверить, сохранил ли посетитель изменения, уточнить, действительно ли он хочет покинуть страницу.

Событие DOMContentLoaded происходит на document и поддерживается во всех браузерах, кроме IE8-. Про поддержку аналогичного функционала в старых IE мы поговорим в конце главы.
Обработчик на него вешается только через addEventListener:
document.addEventListener("DOMContentLoaded", ready);

Обработчик DOMContentLoaded сработает сразу после загрузки документа, не дожидаясь получения картинки.
Поэтому на момент вывода alert и сама картинка будет невидна и её размеры – неизвестны (кроме случая, когда картинка взята из кеша браузера).
В своей сути, событие onDOMContentLoaded – простое, как пробка. Полностью создано DOM-дерево – и вот событие. Но с ним связан ряд существенных тонкостей.

DOMContentLoaded и скрипты
Если в документе есть теги <script>, то браузер обязан их выполнить до того, как построит DOM. Поэтому событие DOMContentLoaded ждёт загрузки и выполнения таких скриптов.
Исключением являются скрипты с атрибутами async и defer, которые подгружаются асинхронно.
Побочный эффект: если на странице подключается скрипт с внешнего ресурса (к примеру, реклама), и он тормозит, то событие DOMContentLoaded и связанные с ним действия могут сильно задержаться.
Современные системы рекламы используют атрибут async, либо вставляют скрипты через DOM: document.createElement('script')..., что работает так же как async: такой скрипт выполняется полностью независимо от страницы и от других скриптов – сам ничего не ждёт и ничего не блокирует.

DOMContentLoaded и стили
Внешние стили никак не влияют на событие DOMContentLoaded. Но есть один нюанс.
Если после стиля идёт скрипт, то этот скрипт обязан дождаться, пока стиль загрузится:
<link type="text/css" rel="stylesheet" href="style.css">
<script>
  // сработает после загрузки style.css
</script>
Такое поведение прописано в стандарте. Его причина – скрипт может захотеть получить информацию со страницы, зависящую от стилей, например, ширину элемента, и поэтому обязан дождаться загрузки style.css.
Побочный эффект – так как событие DOMContentLoaded будет ждать выполнения скрипта, то оно подождёт и загрузки стилей, которые идут перед <script>.

Автозаполнение
Firefox/Chrome/Opera автозаполняют формы по DOMContentLoaded.
Это означает, что если на странице есть форма для ввода логина-пароля, то браузер введёт в неё запомненные значения только по DOMContentLoaded.
Побочный эффект: если DOMContentLoaded ожидает множества скриптов и стилей, то автозаполнение не сработает до полной их загрузки.
Конечно, это довод в пользу того, чтобы не задерживать DOMContentLoaded, в частности – использовать у скриптов атрибуты async и defer.
EXTENSION!@@



@@!BLOCK
Загрузка документа: DOMContentLoaded, load, beforeunload, unload
BLOCK!@@

@@!QWESTION
Чем window.onunload от window.onbeforeunload
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Из window.onunload нельзя отменить сам переход на друшую страницу
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
window.onunload
Когда человек уходит со страницы или закрывает окно, на window срабатывает событие unload. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя.
Это позволяет другое событие – onbeforeunload, которое поэтому используется гораздо чаще.

window.onbeforeunload
Если посетитель инициировал переход на другую страницу или нажал «закрыть окно», то обработчик onbeforeunload может приостановить процесс и спросить подтверждение.
Для этого ему нужно вернуть строку. По историческим причинам некоторые браузеры покажут ее, но большинство – стандартное сообщение.
EXTENSION!@@



@@!BLOCK
Загрузка документа: DOMContentLoaded, load, beforeunload, unload
BLOCK!@@

@@!QWESTION
IE8- поддерживает DOMContentLoaded?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Эмуляция DOMContentLoaded для IE8-
Прежде чем что-то эмулировать, заметим, что альтернативой событию onDOMContentLoaded является вызов функции init из скрипта в самом конце BODY, когда основная часть DOM уже готова:
<body>
  ...
  <script>
    init();
  </script>
</body>
Причина, по которой обычно предпочитают именно событие – одна: удобство. Вешается обработчик и не надо ничего писать в конец BODY.

Как именно эмулируется DOMContentLoaded?
Технически, эмуляция DOMContentLoaded для старых IE осуществляется очень забавно.
Основной приём – это попытка прокрутить документ вызовом:
document.documentElement.doScroll("left");
Метод doScroll работает только в IE и «методом тыка» было обнаружено, что он бросает исключение, если DOM не полностью создан.
Поэтому библиотека пытается вызвать прокрутку, если не получается – через setTimeout(.., 1) пытается прокрутить его ещё раз, и так до тех пор, пока действие не перестанет вызывать ошибку. На этом этапе документ считается загрузившимся.
Внутри фреймов и в очень старых браузерах такой подход может ошибаться, поэтому дополнительно ставится резервный обработчик на onload, чтобы уж точно сработал.
EXTENSION!@@



@@!BLOCK
81--Загрузка скриптов, картинок, фреймов: onload и onerror
BLOCK!@@

@@!QWESTION
Какое событи позволяет отследить загрузку скрипта с сервера?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
onload
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Браузер позволяет отслеживать загрузку внешних ресурсов – скриптов, ифреймов, картинок и других.
Для этого есть два события:
onload – если загрузка успешна.
onerror – если при загрузке произошла ошибка.

Главным помощником станет событие onload. Оно сработает, когда скрипт загрузился и выполнился.
var script = document.createElement('script');
script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
document.body.appendChild(script);
script.onload = function() {
  // после выполнения скрипта становится доступна функция _
  alert( _ ); // её код
}
Любые ошибки загрузки (но не выполнения) скрипта отслеживаются обработчиком onerror.
EXTENSION!@@



@@!BLOCK
Загрузка скриптов, картинок, фреймов: onload и onerror
BLOCK!@@

@@!QWESTION
Как отследить загрузку внешних ресурсов в IE8-?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
script.onreadystatechange
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Примеры выше работают во всех браузерах, кроме IE8-.
В IE для отслеживания загрузки есть другое событие: onreadystatechange. Оно срабатывает многократно, при каждом обновлении состояния загрузки.
Текущая стадия процесса находится в script.readyState:
loading
В процессе загрузки.
loaded
Получен ответ с сервера – скрипт или ошибка. Скрипт на фазе loaded может быть ещё не выполнен.
complete
Скрипт выполнен.

Например, рабочий скрипт:
var script = document.createElement('script');
script.src = "https://code.jquery.com/jquery.js";
document.documentElement.appendChild(script);
script.onreadystatechange = function() {
  alert(this.readyState); // loading -> loaded -> complete
}

Скрипт с ошибкой:
var script = document.createElement('script');
script.src = "http://ajax.googleapis.com/404.js";
document.documentElement.appendChild(script);
script.onreadystatechange = function() {
  alert(this.readyState);  // loading -> loaded
}

Обратим внимание на две особенности:
Стадии могут пропускаться.
Если скрипт в кэше браузера – он сразу даст complete. Вы можете увидеть это, если несколько раз запустите первый пример.
Нет особой стадии для ошибки.
В примере выше это видно, обработка останавливается на loaded.
Итак, самое надёжное средство для IE8- поймать загрузку (или ошибку загрузки) – это повесить обработчик на событие onreadystatechange, который будет срабатывать и на стадии complete и на стадии loaded. Так как скрипт может быть ещё не выполнен к этому моменту, то вызов функции лучше сделать через setTimeout(.., 0).

Пример ниже вызывает afterLoad после загрузки скрипта и работает только в IE:
var script = document.createElement('script');
script.src = "https://code.jquery.com/jquery.js";
document.documentElement.appendChild(script);
function afterLoad() {
  alert("Загрузка завершена: " + typeof(jQuery));
}
script.onreadystatechange = function() {
  if (this.readyState == "complete") { // на случай пропуска loaded
    afterLoad(); // (2)
  }
  if (this.readyState == "loaded") {
    setTimeout(afterLoad, 0);  // (1)
    // убираем обработчик, чтобы не сработал на complete
    this.onreadystatechange = null;
  }
}
Вызов (1) выполнится при первой загрузке скрипта, а (2) – при второй, когда он уже будет в кеше, и стадия станет сразу complete.
Функция afterLoad может и не обнаружить jQuery, если при загрузке была ошибка, причём не важно какая – файл не найден или синтаксис скрипта ошибочен.
EXTENSION!@@



@@!BLOCK
Загрузка скриптов, картинок, фреймов: onload и onerror
BLOCK!@@

@@!QWESTION
iframe поддерживает событие onerror?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Отловить загрузку скрипта (включая ошибку)
Ставим обработчики на onload + onerror + (для IE8-) onreadystatechange, как указано в рецепте выше
Отловить загрузку картинки <img> или стиля <link>
Ставим обработчики на onload + onerror
var img = document.createElement('img');
img.onload = function() { alert("Успех " + this.src) };
img.onerror = function() { alert("Ошибка " + this.src) };
img.src = ...
Изображения начинают загружаться сразу при создании, не нужно их для этого вставлять в HTML.

Чтобы работало в IE8-, src нужно ставить после onload/onerror.
Отловить загрузку <iframe>
Поддерживается только обработчик onload. Он сработает, когда IFRAME загрузится, со всеми подресурсами, а также в случае ошибки.
EXTENSION!@@



@@!BLOCK
82--Навигация и свойства элементов формы
BLOCK!@@

@@!QWESTION
Что вернёт такая запись?
document.forms
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Коллекцию форм присутствующих на странице
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Псевдомассив form.elements
Элементы FORM можно получить по имени или номеру, используя свойство document.forms[name/index].

Например:
document.forms.my -- форма с именем 'my'
document.forms[0] -- первая форма в документе
Любой элемент формы form можно получить аналогичным образом, используя свойство form.elements.

Может быть несколько элементов с одинаковым именем. В таком случае form.elements[name] вернет коллекцию элементов, например:
<body>
<form>
  <input type="radio" name="age" value="10">
  <input type="radio" name="age" value="20">
</form>
<script>
var form = document.forms[0];
var elems = form.elements.age;
alert(elems[0].value); // 10, первый input
</script>
</body>

Свойство elements также есть у элементов <fieldset>. Вот пример:
<body>
  <form>
    <fieldset name="set">
      <legend>fieldset</legend>
      <input name="text" type="text">
    </fieldset>
  </form>

  <script>
    var form = document.forms[0];

    alert( form.elements.text ); // INPUT
    alert( form.elements.set.elements.text ); // INPUT
  </script>
</body>

Доступ form.name тоже работает, но с особенностями
Получить доступ к элементам формы можно не только через form.elements[name/index], но и проще: form[index/name].
Этот способ короче, но обладает одной неприятной особенностью: если к элементу обратиться по его name, а потом свойство name изменить, то он по-прежнему будет доступен под старым именем.
Звучит странно, поэтому посмотрим на примере.
 <form name="myform">
  <input name="text">
</form>
<script>
  var form = document.forms.myform;
  alert( form.elements.text == form.text ); // true, это тот самый INPUT
  form.text.name = "new-name"; // меняем name ему
  // нет больше элемента с таким именем
  alert( form.elements.text ); // undefined
  alert( form.text ); //  INPUT (а должно быть undefined!)
</script>
EXTENSION!@@



@@!BLOCK
Навигация и свойства элементов формы
BLOCK!@@

@@!QWESTION
Как получить ссылку на форму по элементу?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
element.form
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Навигация и свойства элементов формы
BLOCK!@@

@@!QWESTION
Можно ли изменть innerHTML textarea?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для элементов textarea также доступно свойство innerHTML, но лучше им не пользоваться: оно хранит только HTML, изначально присутствовавший в элементе, и не меняется при изменении значения.
EXTENSION!@@



@@!BLOCK
Навигация и свойства элементов формы
BLOCK!@@

@@!QWESTION
Что будет если установить selectedIndex = -1?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Выбор в select очистится
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Селект в JavaScript можно установить двумя путями: поставив значение select.value, либо установив свойство select.selectedIndex в номер нужной опции.:
select.selectedIndex = 0; // первая опция
Установка selectedIndex = -1 очистит выбор.
Список элементов-опций доступен через select.options.
Если select допускает множественный выбор (атрибут multiple), то значения можно получить/установить, сделав цикл по select.options. При этом выбранные опции будут иметь свойство option.selected = true.

new Option
В стандарте the option element есть любопытный короткий синтаксис для создания элемента с тегом option:
option = new Option(text, value, defaultSelected, selected);

Параметры:
text – содержимое,
value – значение,
defaultSelected и selected поставьте в true, чтобы сделать элемент выбранным.

Его можно использовать вместо document.createElement('option'), например:
var option = new Option("Текст", "value");
// создаст <option value="value">Текст</option>

Такой же элемент, но выбранный:
var option = new Option("Текст", "value", true, true);

Дополнительные свойства option
У элементов option также есть особые свойства, которые могут оказаться полезными (см. the option element):
selected
выбрана ли опция
index
номер опции в списке селекта
text
Текстовое содержимое опции (то, что видит посетитель).
EXTENSION!@@



@@!BLOCK
83--Фокусировка: focus/blur
BLOCK!@@

@@!QWESTION
Какое событие возникает при потере фокуса?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
blur
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие focus вызывается тогда, когда пользователь фокусируется на элементе, а blur – когда фокус исчезает, например посетитель кликает на другом месте экрана.
Методы с теми же названиями переводят/уводят фокус с элемента.
Обратим внимание – если из onblur сделать event.preventDefault(), то такого же эффекта не будет, потому что onblur срабатывает уже после того, как элемент потерял фокус.

При загрузке страницы, если на ней существует элемент с атрибутом autofocus – браузер автоматически фокусируется на этом элементе. Работает во всех браузерах, кроме IE9-.
<input type="text" name="search" autofocus>
EXTENSION!@@



@@!BLOCK
Фокусировка: focus/blur
BLOCK!@@

@@!QWESTION
Что означает tabindex="-1"?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Клавиша Tab будет игнорировать элемент
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
По умолчанию не все элементы поддерживают фокусировку.
Перечень элементов немного рознится от браузера к браузеру, например, список для IE описан в MSDN, одно лишь верно всегда – заведомо поддерживают focus/blur те элементы, c которыми посетитель может взаимодействовать: <button>, <input>, <select>, <a> и т.д.
С другой стороны, на элементах для форматирования, таких как <div>, <span>, <table> – по умолчанию сфокусироваться нельзя. Впрочем, существует способ включить фокусировку и для них.
В HTML есть атрибут tabindex.
Его основной смысл – это указать номер элемента при переборе клавишей Tab.
То есть, если есть два элемента, первый имеет tabindex="1", а второй tabindex="2", то нажатие Tab при фокусе на первом элементе – переведёт его на второй.

Исключением являются специальные значения:
tabindex="0" делает элемент всегда последним.
tabindex="-1" означает, что клавиша Tab будет элемент игнорировать.
Любой элемент поддерживает фокусировку, если у него есть tabindex.
EXTENSION!@@



@@!BLOCK
Фокусировка: focus/blur
BLOCK!@@

@@!QWESTION
Почему не сработает данный код?
<!-- при фокусировке на форме ставим ей класс -->
<form onfocus="this.className='focused'">
  <input type="text" name="name" value="Ваше имя">
  <input type="text" name="surname" value="Ваша фамилия">
</form>
<style> .focused { outline: 1px solid red; } </style>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
События focus и blur не всплывают
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Это забавно, но хотя focus/blur не всплывают, они могут быть пойманы на фазе перехвата.
<form id="form">
  <input type="text" name="name" value="Ваше имя">
  <input type="text" name="surname" value="Ваша фамилия">
</form>
<style>
  .focused {
    outline: 1px solid red;
  }
</style>
<script>
  // ставим обработчики на фазе перехвата, последний аргумент true
  form.addEventListener("focus", function() {
    this.classList.add('focused');
  }, true);
  form.addEventListener("blur", function() {
    this.classList.remove('focused');
  }, true);
</script>
EXTENSION!@@



@@!BLOCK
Фокусировка: focus/blur
BLOCK!@@

@@!QWESTION
Чем отличаются события focusin/focusout от focus/blur?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
focusin/focusout всплывают
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
События focusin/focusout – то же самое, что и focus/blur, только они всплывают.

У них две особенности:
Не поддерживаются Firefox (хотя поддерживаются даже старейшими IE), см. https://bugzilla.mozilla.org/show_bug.cgi?id=687787.
Должны быть назначены не через on-свойство, а при помощи elem.addEventListener.
Из-за отсутствия подержки Firefox эти события используют редко. Получается, что во всех браузерах можно использовать focus на стадии перехвата, ну а focusin/focusout – в IE8-, где стадии перехвата нет.
EXTENSION!@@



@@!BLOCK
84--Изменение: change, input, cut, copy, paste
BLOCK!@@

@@!QWESTION
Когда возникает событие change?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
По окончании изменения значения элемента формы, когда это изменение зафиксировано
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие change происходит по окончании изменения значения элемента формы, когда это изменение зафиксировано.
Для текстовых элементов это означает, что событие произойдёт не при каждом вводе, а при потере фокуса.
Например, пока вы набираете что-то в текстовом поле ниже – события нет. Но как только вы уведёте фокус на другой элемент, например, нажмёте кнопку – произойдет событие onchange.
Для остальных же элементов: select, input type=checkbox/radio оно срабатывает сразу при выборе значения.

Поздний onchange в IE8-
В IE8- checkbox/radio при изменении мышью не инициируют событие сразу, а ждут потери фокуса.
Для того, чтобы видеть изменения checkbox/radio тут же – в IE8- нужно повесить обработчик на событие click (оно произойдет и при изменении значения с клавиатуры) или воспользоваться событием propertychange, описанным далее.
EXTENSION!@@



@@!BLOCK
Изменение: change, input, cut, copy, paste
BLOCK!@@

@@!QWESTION
Каким событием заменить input в IE8-?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
onpropertychange
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие input срабатывает тут же при изменении значения текстового элемента и поддерживается всеми браузерами, кроме IE8-.
В IE9 оно поддерживается частично, а именно – не возникает при удалении символов (как и onpropertychange).

propertychange	
Только для IE10-. 
Универсальное событие для отслеживания изменения свойств элементов. Имя изменённого свойства содержится в event.propertyName. Используют для мгновенной реакции на изменение значения в старых IE.

В IE8- событие input не поддерживается, но, как мы видели ранее, есть onpropertychange, которое может заменить его.
Что же касается IE9 – там поддерживаются и input и onpropertychange, но они оба не работают при удалении символов. Поэтому мы будем отслеживать удаление при помощи keyup на Delete и BackSpace . А вот удаление командой «вырезать» из меню – сможет отловить лишь oncut.
Получается вот такая комбинация:
 <input type="text" id="sms"> символов: <span id="result"></span>
<script>
  function showCount() {
    result.innerHTML = sms.value.length;
  }
  sms.onkeyup = sms.oninput = showCount;
  sms.onpropertychange = function() {
    if (event.propertyName == "value") showCount();
  }
  sms.oncut = function() {
    setTimeout(showCount, 0); // на момент oncut значение еще старое
  };
</script>
Здесь мы добавили вызов showCount на все события, которые могут приводить к изменению значения. Да, иногда изменение будет обрабатываться несколько раз, но зато с гарантией. А лишние вызовы легко убрать, например, при помощи throttle-декоратора, описанного в задаче Тормозилка.
Есть и совсем другой простой, но действенный вариант: через setInterval регулярно проверять значение и, если оно слишком длинное, обрезать его.
EXTENSION!@@



@@!BLOCK
Изменение: change, input, cut, copy, paste
BLOCK!@@

@@!QWESTION
Можно ли получить вставляемое значение при cut/copy/paste?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Срабатывают при вставке/копировании/удалении текста. Если в их обработчиках отменить действие браузера, то вставки/копирования/удаления не произойдёт.
Вставляемое значение получить нельзя: на момент срабатывания события в элементе всё ещё старое значение, а новое недоступно.
EXTENSION!@@



@@!BLOCK
85--Формы: отправка, событие и метод submit
BLOCK!@@

@@!QWESTION
Возникает ли событие submit при вызове метода submit()?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие submit возникает при отправке формы. Наиболее частое его применение – это валидация (проверка) формы перед отправкой.	
Метод submit позволяет инициировать отправку формы из JavaScript, без участия пользователя. Далее мы рассмотрим детали их использования.

Чтобы отправить форму на сервер, у посетителя есть два способа:
Первый – это нажать кнопку <input type="submit"> или <input type="image">.
Второй – нажать Enter, находясь на каком-нибудь поле.
Какой бы способ ни выбрал посетитель – будет сгенерировано событие submit. Обработчик в нём может проверить данные и, если они неверны, то вывести ошибку и сделать event.preventDefault() – тогда форма не отправится на сервер.
Взаимосвязь событий submit и click
При отправке формы путём нажатия Enter на текстовом поле, на элементе <input type="submit"> везде, кроме IE8-, генерируется событие click.
В IE8- событие submit не всплывает. Нужно вешать обработчик submit на сам элемент формы, без использования делегирования.

Чтобы отправить форму на сервер из JavaScript – нужно вызвать на элементе формы метод form.submit().
При этом само событие submit не генерируется. Предполагается, что если программист вызывает метод form.submit(), то он выполнил все проверки.
EXTENSION!@@



@@!BLOCK
86--Методы RegExp и String
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = "Люблю регэкспы я, но странною любовью";
alert( str.search( /лю/i ) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
0
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Он возвращает позицию первого совпадения или -1, если ничего не найдено.
Ограничение метода search – он всегда ищет только первое совпадение.
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = "javascript - это такой язык";
var result = str.match( /JAVA(SCRIPT)/gi );
alert( result.index );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
undefined
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод str.match работает по-разному, в зависимости от наличия или отсутствия флага g, поэтому сначала мы разберём вариант, когда его нет.
В этом случае str.match(reg) находит только одно, первое совпадение.
Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами index – позиция, на которой оно обнаружено и input – строка, в которой был поиск.
var str = "ОЙ-Ой-ой";
var result = str.match( /ой/i );
alert( result[0] ); // ОЙ  (совпадение)
alert( result.index ); // 0 (позиция)
alert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

Если часть шаблона обозначена скобками, то она станет отдельным элементом массива.
var str = "javascript - это такой язык";
var result = str.match( /JAVA(SCRIPT)/i );
alert( result[0] ); // javascript (всё совпадение полностью)
alert( result[1] ); // script (часть совпадения, соответствующая скобкам)
alert( result.index ); // 0
alert( result.input ); // javascript - это такой язык

При наличии флага g, вызов match возвращает обычный массив из всех совпадений.
Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Что возвращает match если совпадений не было?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Что вернёт alert?
alert('12-34-56'.replace("-", ":"))
QWESTION!@@

@@!ANSWERS

@@!CORRECT
12:34-56
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При вызове со строкой замены replace всегда заменяет только первое совпадение.
Чтобы заменить все совпадения, нужно использовать для поиска не строку "-", а регулярное выражение /-/g, причём обязательно с флагом g:
// заменить дефис на двоеточие
alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56
В строке для замены можно использовать специальные символы:
Спецсимволы	Действие в строке замены
$$	Вставляет "$".
$&	Вставляет всё найденное совпадение.
$`	Вставляет часть строки до совпадения.
$'	Вставляет часть строки после совпадения.
$*n*	где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.

Пример использования скобок и $1, $2:
 var str = "Василий Пупкин";
alert(str.replace(/(Василий) (Пупкин)/, '$2, $1')) // Пупкин, Василий

Ещё пример, с использованием $&:
 var str = "Василий Пупкин";
alert(str.replace(/Василий Пупкин/, 'Великий $&!')) // Великий Василий Пупкин!
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Что означает offset в данной функции?
function replacer(str, offset, s) {
  alert(offset);
  return str.toLowerCase();
}
var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Позиция, на которой найдено совпадение,
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для ситуаций, которые требуют максимально «умной» замены, в качестве второго аргумента предусмотрена функция.
Она будет вызвана для каждого совпадения, и её результат будет вставлен как замена.
Например:
 var i = 0;

// заменить каждое вхождение "ой" на результат вызова функции
alert("ОЙ-Ой-ой".replace(/ой/gi, function() {
  return ++i;
})); // 1-2-3
В примере выше функция просто возвращала числа по очереди, но обычно она основывается на поисковых данных.

Эта функция получает следующие аргументы:
str – найденное совпадение,
p1, p2, ..., pn – содержимое скобок (если есть),
offset – позиция, на которой найдено совпадение,
s – исходная строка.
Если скобок в регулярном выражении нет, то у функции всегда будет ровно 3 аргумента: replacer(str, offset, s).

Используем это, чтобы вывести полную информацию о совпадениях:
 // вывести и заменить все совпадения
function replacer(str, offset, s) {
  alert( "Найдено: " + str + " на позиции: " + offset + " в строке: " + s );
  return str.toLowerCase();
}
var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
alert( 'Результат: ' + result ); // Результат: ой-ой-ой

С двумя скобочными выражениями – аргументов уже 5:
 function replacer(str, name, surname, offset, s) {
  return surname + ", " + name;
}

var str = "Василий Пупкин";
alert(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Каков будет результат выполнения данных методов?
alert( /javascript/i.test(str) );
alert( str.search(/javascript/i) != -1 );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
false, false
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод test проверяет, есть ли хоть одно совпадение в строке str. Возвращает true/false.
Работает, по сути, так же, как и проверка str.search(reg) != -1
EXTENSION!@@



@@!BLOCK
Методы RegExp и String
BLOCK!@@

@@!QWESTION
Как заставить regexp.exec искать сразу с нужной позиции?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Поставить lastIndex вручную
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для поиска мы уже видели методы:
search – ищет индекс
match – если регэксп без флага g – ищет совпадение с подрезультатами в скобках
match – если регэксп с флагом g – ищет все совпадения, но без скобочных групп.
Метод regexp.exec дополняет их. Он позволяет искать и все совпадения и скобочные группы в них.

Он ведёт себя по-разному, в зависимости от того, есть ли у регэкспа флаг g.
Если флага g нет, то regexp.exec(str) ищет и возвращает первое совпадение, является полным аналогом вызова str.match(reg).
Если флаг g есть, то вызов regexp.exec возвращает первое совпадение и запоминает его позицию в свойстве regexp.lastIndex. Последующий поиск он начнёт уже с этой позиции. Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.

Это используют для поиска всех совпадений в цикле:
 var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
var result;
alert( "Начальное значение lastIndex: " + regexp.lastIndex );
while (result = regexp.exec(str)) {
  alert( 'Найдено: ' + result[0] + ' на позиции:' + result.index );
  alert( 'Свойство lastIndex: ' + regexp.lastIndex );
}
alert( 'Конечное значение lastIndex: ' + regexp.lastIndex );

Здесь цикл продолжается до тех пор, пока regexp.exec не вернёт null, что означает «совпадений больше нет».
Найденные результаты последовательно помещаются в result, причём находятся там в том же формате, что и match – с учётом скобок, со свойствами result.index и result.input.
Поиск с нужной позиции
Можно заставить regexp.exec искать сразу с нужной позиции, если поставить lastIndex вручную:
 var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
regexp.lastIndex = 40;
alert( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции
EXTENSION!@@



@@!BLOCK
87--Классы и спецсимволы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = "+7(903)-123-45-67";
var reg = /\d/;
alert( str.match(reg) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
7
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
\d (от английского «digit» – «цифра»)
Цифра, символ от 0 до 9.

\s (от английского «space» – «пробел»)
Пробельный символ, включая табы, переводы строки и т.п.

\w (от английского «word» – «слово»)
Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание '_'. Не-английские буквы не являются \w, то есть русская буква не подходит.

\D
Не-цифра, то есть любой символ кроме \d, например буква.

\S
Не-пробел, то есть любой символ кроме \s, например буква.

\W
Любой символ, кроме \w, то есть не латинница, не подчёркивание, не цифра. В частности, русские буквы принадлежат этому классу.
EXTENSION!@@



@@!BLOCK
Классы и спецсимволы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
alert( "Hello, Javascript!".match(/\bJava\b/) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Граница слова \b – это особый класс.
Он интересен тем, что обозначает не символ, а границу между символами.
Например, \bJava\b найдёт слово Java в строке Hello, Java!, но не в строке Hello, Javascript!.

Граница имеет «нулевую ширину» в том смысле, что обычно символам регулярного выражения соответствуют символы строки, но не в этом случае.
Граница – это проверка.
При поиске движок регулярных выражений идёт по шаблону и одновременно по строке, пытаясь построить соответствие. Когда он видит \b, то проверяет, что текущая позиция в строке подходит под одно из условий:
Начало текста, если первый символ \w.
Конец текста, если последний символ \w.
Внутри текста, если с одной стороны \w, а с другой – не \w.
https://learn.javascript.ru/article/regexp-character-classes/hello-java-boundaries@2x.png
EXTENSION!@@



@@!BLOCK
Классы и спецсимволы
BLOCK!@@

@@!QWESTION
Нужно ли экранировать [ ?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В регулярных выражениях есть и другие символы, имеющие особый смысл.
Они используются, чтобы расширить возможности поиска.
Вот их полный список: [ \ ^ $ . | ? * + ( ).
EXTENSION!@@



@@!BLOCK
Классы и спецсимволы
BLOCK!@@

@@!QWESTION
Найдёт ли \w символ '_'?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Классы и спецсимволы
BLOCK!@@

@@!QWESTION
Что вернёт \w символ '7v'?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
7
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
88--Наборы и диапазоны [...]
BLOCK!@@

@@!QWESTION
Что вернёт alert?
alert( "Гоп-стоп".match(/[гт]оп/gi) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"Гоп", "топ"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Например, [еао] означает любой символ из этих трёх: 'а', 'е', или 'о'.
Обратим внимание: несмотря на то, что в наборе указано несколько символов, в совпадении должен присутствовать ровно один из них.

Обычно, если мы хотим искать именно точку, а не любой символ, или именно символ \, то мы используем экранирование: указываем \. или \\.
В квадратных скобках большинство специальных символов можно использовать без экранирования, если конечно они не имеют какой-то особый смысл именно внутри квадратных скобок.
То есть, «как есть», без экранирования можно использовать символы:
Точка '.'.
Плюс '+'.
Круглые скобки '( )'.
Дефис '-', если он находится в начале или конце квадратных скобок, то есть не выделяет диапазон.
Символ каретки '^', если не находится в начале квадратных скобок.
А также открывающая квадратная скобка '['.
EXTENSION!@@



@@!BLOCK
Наборы и диапазоны [...]
BLOCK!@@

@@!QWESTION
var str = "ё";
alert( str.match(/[а-я]/i) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Квадратные скобки могут также содержать диапазоны символов.
Например, [a-z] – произвольный символ от a до z, [0-5] – цифра от 0 до 5.
В квадратных скобках можно использовать и диапазоны и символьные классы – вместе.

Буква ё лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно, вот так:
var str = "ё";
alert( str.match(/[а-я]ё/i) );
EXTENSION!@@



@@!BLOCK
Наборы и диапазоны [...]
BLOCK!@@

@@!QWESTION
Что вернёт alert?
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"@", "."
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Кроме обычных, существуют также исключающие диапазоны: [^…].
Квадратные скобки, начинающиеся со знака каретки: [^…] находят любой символ, кроме указанных.
Например:
[^аеуо] – любой символ, кроме 'a', 'e', 'y', 'o'.
EXTENSION!@@



@@!BLOCK
89--Квантификаторы +, *, ? и {n}
BLOCK!@@

@@!QWESTION
Эти записи идентичны \d{5} \d\d\d\d\d
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Количество повторений символа можно указать с помощью числа в фигурных скобках: {n}.
Такое указание называют квантификатором (от англ. quantifier).
У него есть несколько подформ записи:
Точное количество: {5}
Количество от-до: {3,5}
Последнее значение можно и не указывать. Тогда выражение \d{3,} найдет числа, длиной от трех цифр

+
Означает «один или более», то же что {1,}.

?
Означает «ноль или один», то же что и {0,1}. По сути, делает символ необязательным.

*
Означает «ноль или более», то же что {0,}. То есть, символ может повторяться много раз или вообще отсутствовать.
EXTENSION!@@



@@!BLOCK
90--Жадные и ленивые квантификаторы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var reg = /".+"/g;
var str = 'a "witch" and her "broom" is one';
alert( str.match(reg) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"witch" and her "broom"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Жадный
Режим по умолчанию – движок регулярных выражений повторяет его по-максимуму. Когда повторять уже нельзя, например нет больше цифр для \d+, он продолжает поиск с оставшейся части текста. Если совпадение найти не удалось – отступает обратно, уменьшая количество повторений.

a "witch" and her "broom" is one
Первый символ шаблона – это кавычка ".
Движок регулярных выражений пытается сопоставить её на 0-й позиции в строке, но символ a, поэтому на 0-й позиции соответствия явно нет.
Далее он переходит 1ю, 2ю позицию в исходной строке и, наконец, обнаруживает кавычку на 3-й позиции:
Кавычка найдена, далее движок проверяет, есть ли соответствие для остальной части паттерна.
В данном случае следующий символ шаблона: . (точка). Она обозначает «любой символ», так что следующая буква строки 'w' вполне подходит:
Далее «любой символ» повторяется, так как стоит квантификатор .+. Движок регулярных выражений берёт один символ за другим, до тех пор, пока у него это получается.

В данном случае это означает «до конца строки»:
Итак, текст закончился, движок регулярных выражений больше не может найти «любой символ», он закончил повторения для .+ и переходит к следующему символу шаблона.
Следующий символ шаблона – это кавычка. Её тоже необходимо найти, чтобы соответствие было полным. А тут – беда, ведь поисковый текст завершился!
Движок регулярных выражений понимает, что, наверное, взял многовато .+ и начинает отступать обратно.

Иными словами, он сокращает текущее совпадение на один символ:
Это называется «фаза возврата» или «фаза бэктрекинга» (backtracking – англ.).
Теперь .+ соответствует почти вся оставшаяся строка, за исключением одного символа, и движок регулярных выражений ещё раз пытается подобрать соответствие для остатка шаблона, начиная с оставшейся части строки.
Если бы последним символом строки была кавычка '"', то на этом бы всё и закончилось. Но последний символ 'e', так что совпадения нет.

…Поэтому движок уменьшает число повторений .+ ещё на один символ:
Кавычка '"' не совпадает с 'n'. Опять неудача.
Движок продолжает отступать, он уменьшает количество повторений точки '.' до тех пор, пока остаток паттерна, то есть в данном случае кавычка '"', не совпадёт:
Совпадение получено. Дальнейший поиск по оставшейся части строки is one новых совпадений не даст.

Возможно, это не совсем то, что мы ожидали.
В жадном режиме (по умолчанию) регэксп повторяет квантификатор настолько много раз, насколько это возможно, чтобы найти соответствие.
То есть, любой символ .+ повторился максимальное количество раз, что и привело к такой длинной строке.

Ленивый
При указании после квантификатора символа ? он работает в ленивом режиме. То есть, он перед каждым повторением проверяет совпадение оставшейся части шаблона на текущей позиции.
Ленивый режим работы квантификаторов – противоположность жадному, он означает «повторять минимальное количество раз».
Его можно включить, если поставить знак вопроса '?' после квантификатора, так что он станет таким: *? или +? или даже ?? для '?'.
Чтобы не возникло путаницы – важно понимать: обычно ? сам является квантификатором (ноль или один). Но если он стоит после другого квантификатора (или даже после себя), то обретает другой смысл – в этом случае он меняет режим его работы на ленивый.
Регэксп /".+?"/g работает, как задумано – находит отдельно witch и broom:
 var reg = /".+?"/g;
var str = 'a "witch" and her "broom" is one';
alert( str.match(reg) ); // witch, broom

Чтобы в точности понять, как поменялась работа квантификатора, разберём поиск по шагам.
Первый шаг – тот же, кавычка '"' найдена на 3-й позиции:
Второй шаг – тот же, находим произвольный символ '.':
А вот дальше – так как стоит ленивый режим работы +, то движок не повторит точку (произвольный символ) ещё раз, а останавливается на достигнутом и пытается проверить, есть ли соответствие остальной части шаблона, то есть '"':
Если бы остальная часть шаблона на данной позиции совпала, то совпадение было бы найдено. Но в данном случае – нет, символ 'i' не равен '"'.
Движок регулярных выражений увиличивает количество повторений точки на одно и пытается найти соответствие остатку шаблона ещё раз:
Опять неудача. Тогда поисковой движок увеличивает количество повторений ещё и ещё…
Только на пятом шаге поисковой движок наконец находит соответствие для остатка паттерна:
Так как поиск происходит с флагом g, то он продолжается с конца текущего совпадения, давая ещё один результат:
В примере выше продемонстрирована работа ленивого режима для +?. Квантификаторы +? и ?? ведут себя аналогично – «ленивый» движок увеличивает количество повторений только в том случае, если для остальной части шаблона на данной позиции нет соответствия.
Ленивость распространяется только на тот квантификатор, после которого стоит ?.


var str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
var reg = /<a href=".*?" class="doc">/g;
// Неправильное совпадение!
alert( str.match(reg) ); // <a href="link1" class="wrong">... <p style="" class="doc">
Совпадение – не ссылка, а более длинный текст.
Получилось следующее:
Найдено совпадение <a href=".
Лениво ищем .*?, после каждого символа проверяя, есть ли совпадение остальной части шаблона.
Подшаблон .*? будет брать символы до тех пор, пока не найдёт class="doc">.
В данном случае этот поиск закончится уже за пределами ссылки, в теге <p>, вообще не имеющем отношения к <a>.

Получившееся совпадение:
<a href="..................................." class="doc">
<a href="link1" class="wrong">... <p style="" class="doc">
Итак, ленивость нам не помогла.
Необходимо как-то прекратить поиск .*, чтобы он не вышел за пределы кавычек.
Для этого мы используем более точное указание, какие символы нам подходят, а какие нет.
Правильный вариант: [^"]*. Этот шаблон будет брать все символы до ближайшей кавычки, как раз то, что требуется.

Рабочий пример:
var str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
var str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
var reg = /<a href="[^"]*" class="doc">/g;
// Работает!
alert( str1.match(reg) ); // null, совпадений нет, и это верно
alert( str2.match(reg) ); // <a href="link1" class="doc">, <a href="link2" class="doc"
EXTENSION!@@



@@!BLOCK
91--Скобочные группы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;
alert( str.match(reg) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Массив: <h1>, h1
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У такого выделения есть два эффекта:
- Он позволяет выделить часть совпадения в отдельный элемент массива при поиске через String#match или RegExp#exec.
- Если поставить квантификатор после скобки, то он применится ко всей скобке, а не всего лишь к одному символу.

Скобки нумеруются слева направо. Поисковой движок запоминает содержимое каждой скобки и позволяет обращаться к нему – в шаблоне и строке замены и, конечно же, в результатах.
При поиске методом String#match в результирующем массиве будет сначала всё совпадение, а далее – скобочные группы. В шаблоне <(.*?)> скобочная группа только одна:
var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;
alert( str.match(reg) ); // массив: <h1>, h1

Заметим, что метод String#match выдаёт скобочные группы только при поиске без флага /.../g. В примере выше он нашёл только первое совпадение <h1>, а закрывающий </h1> не нашёл, поскольку без флага /.../g ищется только первое совпадение.
Для того, чтобы искать и с флагом /.../g и со скобочными группами, используется метод RegExp#exec:
var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/g;
var match;
while ((match = reg.exec(str)) !== null) {
  // сначала выведет первое совпадение: <h1>,h1
  // затем выведет второе совпадение: </h1>,/h1
  alert(match);
}
Теперь найдено оба совпадения <(.*?)>, каждое – массив из полного совпадения и скобочных групп (одна в данном случае).

Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.
https://learn.javascript.ru/article/regexp-groups/regexp-nested-groups@2x.png
EXTENSION!@@



@@!BLOCK
Скобочные группы
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = "Gogo John!";
var reg = /(?:go)+ (\w+)/i;
var result = str.match(reg);
alert( result[1] );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
John
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Бывает так, что скобки нужны, чтобы квантификатор правильно применился, а вот запоминать их содержимое в массиве не нужно.
Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало ?:.
Например, мы хотим найти (go)+, но содержимое скобок (go) в отдельный элемент массива выделять не хотим.
EXTENSION!@@



@@!BLOCK
92--Обратные ссылки: \n и $n
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = "He said: \"She's the one!\".";
var reg = /['"](.*?)['"]/g;
// Результат не соответствует замыслу
alert( str.match(reg) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
"She'
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Скобочные группы можно не только получать в результате.
Движок регулярных выражений запоминает их содержимое, и затем его можно использовать как в самом паттерне, так и в строке замены.

Как видно, регэксп нашёл открывающую кавычку ", затем текст, вплоть до новой кавычки ', которая закрывает соответствие.
Для того, чтобы попросить регэксп искать закрывающую кавычку – такую же, как открывающую, мы обернём её в скобочную группу и используем обратную ссылку на неё:
 var str = "He said: \"She's the one!\".";
var reg = /(['"])(.*?)\1/g;
alert( str.match(reg) ); // "She's the one!"
Теперь работает верно! Движок регулярных выражений, найдя первое скобочное выражение – кавычку (['"]), запоминает его и далее \1 означает «найти то же самое, что в первой скобочной группе».

Обратим внимание на два нюанса:
- Чтобы использовать скобочную группу в строке замены – нужно использовать ссылку вида $1, а в шаблоне – обратный слэш: \1.
- 	Чтобы в принципе иметь возможность обратиться к скобочной группе – не важно откуда, она не должна быть исключена из запоминаемых при помощи ?:. Скобочные группы вида (?:...) не участвуют в нумерации.
EXTENSION!@@



@@!BLOCK
92--Альтернация (или) |
BLOCK!@@

@@!QWESTION
Что означает эта запись html|php ?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
html или php
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ». Она обозначается символом вертикальной черты | и позволяет выбирать между вариантами.
Например, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.
Соответствующее регулярное выражение: html|php|java(script)?.
Пример использования:
 var reg = /html|php|css|java(script)?/gi
var str = "Сначала появился HTML, затем CSS, потом JavaScript"
alert( str.match(reg) ) // 'HTML', 'CSS', 'JavaScript'
EXTENSION!@@



@@!BLOCK
Начало строки ^ и конец $
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var num = "ля-ля 12.34";
alert( num.match(/^\d+\.\d+$/ig) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
null
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Знак каретки '^' и доллара '$' имеют в регулярном выражении особый смысл. Их называют «якорями» (anchor – англ.).
Каретка ^ совпадает в начале текста, а доллар $ – в конце.
Якоря являются не символами, а проверками.
До этого мы говорили о регулярных выражениях, которые ищут один или несколько символов. Если совпадение есть – эти символы включаются в результат.
А якоря – не такие. Когда поиск ходит до якоря – он проверяет, есть ли соответствие, если есть – продолжает идти по шаблону, не прибавляя ничего к результату.
Каретку ^ обычно используют, чтобы указать, что регулярное выражение необходимо проверить именно с начала текста.
EXTENSION!@@



@@!BLOCK
Многострочный режим, флаг "m"
BLOCK!@@

@@!QWESTION
Что вернёт alert?
var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';
alert( str.match(/[а-я]+\n/gim) );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Винни
,Пятачок
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Многострочный режим включается, если у регэкспа есть флаг /m.
В этом случае изменяется поведение ^ и $.
В многострочном режиме якоря означают не только начало/конец текста, но и начало/конец строки.

Это потому что в обычном режиме каретка ^ – это только начало текста, а в многострочном – начало любой строки.
Символ доллара $ ведёт себя аналогично.
Регулярное выражение [а-я]+$ в следующем примере находит последнее слово в каждой строке:
 var str = '1е место: Винни\n' +
  '2е место: Пятачок\n' +
  '33е место: Слонопотам';
alert( str.match(/[а-я]+$/gim) ); // Винни,Пятачок,Слонопотам
Без флага m якорь $ обозначал бы конец всего текста, и было бы найдено только последнее слово.
Для того, чтобы найти конец строки, можно использовать не только $, но и символ \n.
Но, в отличие от $, символ \n во-первых берёт символ в результат, а во-вторых – не совпадает в конце текста (если, конечно, последний символ – не конец строки).


Чёрная дыра бэктрекинга
Некоторые регулярные выражения, с виду являясь простыми, могут выполняться оооочень долго, и даже «подвешивать» интерпретатор JavaScript.

Рано или поздно, с этим сталкивается любой разработчик, потому что нечаянно создать такое регулярное выражение – легче лёгкого.

Типична ситуация, когда регулярное выражение до поры до времени работает нормально, и вдруг на каком-то тексте как начнёт «подвешивать» интерпретатор и есть 100% процессора.

Это может стать уязвимостью. Например, если JavaScript выполняется на сервере, то при разборе данных, присланных посетителем, он может зависнуть, если использует подобный регэксп. На клиенте тоже возможно подобное, при использовании регэкспа для подсветки синтаксиса.

Такие уязвимости «убивали» почтовые сервера и системы обмена сообщениями и до появления JavaScript, и наверно будут «убивать» и после его исчезновения. Так что мы просто обязаны с ними разобраться.

Пример
План изложения у нас будет таким:

Сначала посмотрим на проблему в реальной ситуации.
Потом упростим реальную ситуацию до «корней» и увидим, откуда она берётся.
Рассмотрим, например, поиск по HTML.

Мы хотим найти теги с атрибутами, то есть совпадения вида <a href="..." class=doc ...>.

Самый простой способ это сделать – <[^>]*>. Но он же и не совсем корректный, так как тег может выглядеть так: <a test="<>" href="#">. То есть, внутри «закавыченного» атрибута может быть символ >. Простейший регэксп на нём остановится и найдёт <a test="<>.

Соответствие:

<[^>]*....>
<a test="<>" href="#">
А нам нужен весь тег.

Для того, чтобы правильно обрабатывать такие ситуации, нужно учесть их в регулярном выражении. Оно будет иметь вид <тег (ключ=значение)*>.

Если перевести на язык регэкспов, то: <\w+(\s*\w+=(\w+|"[^"]*")\s*)*>:

<\w+ – начало тега
(\s*\w+=(\w+|"[^"]*")\s*)* – произвольное количество пар вида слово=значение, где «значение» может быть также словом \w+, либо строкой в кавычках "[^"]*".
Мы пока не учитываем все детали грамматики HTML, ведь строки возможны и в „одинарных“ кавычках, но на данный момент этого достаточно. Главное, что регулярное выражение получилось в меру простым и понятным.

Испытаем полученный регэксп в действии:

 var reg = /<\w+(\s*\w+=(\w+|"[^"]*")\s*)*>/g;

var str='...<a test="<>" href="#">... <b>...';

alert( str.match(reg) ); // <a test="<>" href="#">, <b>
Отлично, всё работает! Нашло как длинный тег <a test="<>" href="#">, так и одинокий <b>.

А теперь – демонстрация проблемы.

Если запустить пример ниже, то он может подвесить браузер:

 






var reg = /<\w+(\s*\w+=(\w+|"[^"]*")\s*)*>/g;

var str = "<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  \
a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b";

// Этот поиск будет выполняться очень, очень долго
alert( str.match(reg) );
Некоторые движки регулярных выражений могут в разумное время разобраться с таким поиском, но большинство – нет.

В чём дело? Почему несложное регулярное выражение на такой небольшой строке «виснет» наглухо?

Упростим ситуацию, удалив тег и возможность указывать строки в кавычках:

 







// только атрибуты, разделённые пробелами
var reg = /<(\s*\w+=\w+\s*)*>/g;

var str = "<a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  \
a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b";

// Этот поиск будет выполняться очень, очень долго
alert( str.match(reg) );
То же самое.

На этом мы закончим с демонстрацией «практического примера» и перейдём к разбору происходящего.

Бектрекинг
В качестве ещё более простого регулярного выражения, рассмотрим (\d+)*$.

В большинстве движков регэкспов, например в Chrome или IE, этот поиск выполняется очень долго (осторожно, может «подвесить» браузер):

 alert( '12345678901234567890123456789123456789z'.match(/(\d+)*$/) );
В чём же дело, что не так с регэкспом?

Внимательный читатель, посмотрев на него, наверняка удивится, ведь он «какой-то странный». Квантификатор * здесь выглядит лишним.

Если хочется найти число, то с тем же успехом можно искать \d+$.

Да, этот регэксп носит искусственный характер, но, разобравшись с ним, мы поймём и практический пример, данный выше. Причина их медленной работы одинакова.

В целом, с регэкспом «всё так», синтаксис вполне допустимый. Проблема в том, как выполняется поиск по нему.

Посмотрим, что происходит при поиске в строке 123456789z:

Первым делом, движок регэкспов пытается найти \d+. Плюс + является жадным по умолчанию, так что он хватает все цифры, какие может:

\d+.......
(123456789)z
Затем движок пытается применить звёздочку вокруг скобок (\d+)*, но больше цифр нет, так что звёздочка не даёт повторений.

Затем в шаблоне идёт символ конца строки $, а в тексте – символ z.

           X
\d+........$
(123456789)z
Соответствия нет.

Так как соответствие не найдено, то «жадный» плюс + отступает на один символ (бэктрекинг).

Теперь \d+ – это все цифры, за исключением последней:

\d+.......
(12345678)9z
После бэктрекинга, \d+ содержит всё число, кроме последней цифры. Движок снова пытается найти совпадение, уже с новой позиции (9).

Звёздочка (\d+)* теперь может быть применена – она даёт число 9:

\d+.......\d+
(12345678)(9)z
Движок пытается найти $, но это ему не удаётся – на его пути опять z:

             X
\d+.......\d+
(12345678)(9)z
Так как совпадения нет, то поисковой движок отступает назад ещё раз.

Теперь первое число \d+ будет содержать 7 цифр, а остаток строки 89 становится вторым \d+:

             X
\d+......\d+
(1234567)(89)z
Увы, всё ещё нет соответствия для $.

Поисковой движок снова должен отступить назад. При этом последний жадный квантификатор отпускает символ. В данном случае это означает, что укорачивается второй \d+, до одного символа 8, и звёздочка забирает следующий 9.

               X
\d+......\d+\d+
(1234567)(8)(9)z
…И снова неудача. Второе и третье \d+ отступили по-максимуму, так что сокращается снова первое число, до 123456, а звёздочка берёт оставшееся:

             X
\d+.......\d+
(123456)(789)z
Снова нет совпадения. Процесс повторяется, последний жадный квантификатор + отпускает один символ (9):

               X
\d+.....\d+ \d+
(123456)(78)(9)z
…И так далее.

Получается, что движок регулярных выражений перебирает все комбинации из 123456789 и их подпоследовательности. А таких комбинаций очень много.

На этом месте умный читатель может воскликнуть: «Во всём виноват бэктрекинг? Давайте включим ленивый режим – и не будет никакого бэктрекинга!»

Что ж, заменим \d+ на \d+? и посмотрим (аккуратно, может подвесить браузер):

 alert( '12345678901234567890123456789123456789z'.match(/(\d+?)*$/) );
Не помогло!

Ленивые регулярные выражения делают то же самое, но в обратном порядке.

Просто подумайте о том, как будет в этом случае работать поисковой движок.

Некоторые движки регулярных выражений содержат хитрые проверки и конечные автоматы, которые позволяют избежать бесконечного перебора или кардинально ускорить его, но не все движки и не всегда.

Возвращаясь к примеру выше – при поиске <(\s*\w+=\w+\s*)*> в строке <a=b a=b a=b a=b происходит то же самое.

Поиск успешно начинается, выбирается некая комбинация из \s*\w+=\w+\s*, которая, так как в конце нет >, оказывается не подходящей. Движок честно отступает, пробует другую комбинацию – и так далее.

Что делать?
Проблема – в сверхмноговариантном переборе.

Движок регулярных выражений перебирает кучу возможных вариантов скобок там, где это не нужно.

Например, в регэкспе (\d+)*$ нам (людям) очевидно, что в (\d+) откатываться не нужно. От того, что вместо одного \d+ у нас два независимых \d+\d+, ничего не изменится.

Без разницы:

\d+........
(123456789)z

\d+...\d+....
(1234)(56789)z
Если вернуться к более реальному примеру <(\s*\w+=\w+\s*)*> то сам алгоритм поиска, который у нас в голове, предусматривает, что мы «просто» ищем тег, а потом пары атрибут=значение (сколько получится).

Никакого «отката» здесь не нужно.

В современных регулярных выражениях для решения этой проблемы придумали «possessive» (сверхжадные? неоткатные? точный перевод пока не устоялся) квантификаторы, которые вообще не используют бэктрегинг.

То есть, они даже проще, чем «жадные» – берут максимальное количество символов и всё. Поиск продолжается дальше. При несовпадении никакого возврата не происходит.

Это, с одной стороны, уменьшает количество возможных результатов, но, с другой стороны, в ряде случаев очевидно, что возврат (уменьшение количество повторений квантификатора) результата не даст. А только потратит время, что как раз и доставляет проблемы. Как раз такие ситуации и описаны выше.

Есть и другое средство – «атомарные скобочные группы», которые запрещают перебор внутри скобок, по сути позволяя добиваться того же, что и сверхжадные квантификаторы,

К сожалению, в JavaScript они не поддерживаются.

Однако, можно получить подобный эффект при помощи предпросмотра. Подробное описание соответствия с учётом синтаксиса сверхжадных квантификаторов и атомарных групп есть в статьях Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead и Mimicking Atomic Groups, здесь же мы останемся в рамках синтаксиса JavaScript.

Взятие максимального количества повторений a+ без отката выглядит так: (?=(a+))\1.

То есть, иными словами, предпросмотр ?= ищет максимальное количество повторений a+, доступных с текущей позиции. А затем они «берутся в результат» обратной ссылкой \1. Дальнейший поиск – после найденных повторений.

Откат в этой логике в принципе не предусмотрен, поскольку предпросмотр «откатываться» не умеет. То есть, если предпросмотр нашёл 5 штук a+, и в результате поиск не удался, то он не будет откатываться на 4 повторения. Эта возможность в предпросмотре отсутствует, а в данном случае она как раз и не нужна.

Исправим регэксп для поиска тега с атрибутами <\w+(\s*\w+=(\w+|"[^"]*")\s*)*>, описанный в начале главы. Используем предпросмотр, чтобы запретить откат на меньшее количество пар атрибут=значение:

 // регэксп для пары атрибут=значение
var attr = /(\s*\w+=(\w+|"[^"]*")\s*)/

// используем его внутри регэкспа для тега
var reg = new RegExp('<\\w+(?=(' + attr.source + '*))\\1>', 'g');

var good = '...<a test="<>" href="#">... <b>...';

var bad = "<tag a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b\
  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b  a=b";

alert( good.match(reg) ); // <a test="<>" href="#">, <b>
alert( bad.match(reg) ); // null (нет результатов, быстро)
Отлично, всё работает! Нашло как длинный тег <a test="<>" href="#">, так и одинокий <b>.
EXTENSION!@@



@@!BLOCK
93--Куки, document.cookie
BLOCK!@@

@@!QWESTION
Чему должен быть равен path=, чтобы cookie было доступно со всех страниц сайта?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
path=/
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Чтение cookie: document.cookie
Эта строка состоит из пар ключ=значение, которые перечисляются через точку с запятой с пробелом "; ".
В document.cookie можно писать. При этом запись не перезаписывает существующие cookie, а дополняет к ним!

Эти настройки указываются после пары ключ=значение, каждое – после точки с запятой:
path=/mypath
Путь, внутри которого будет доступ к cookie. Если не указать, то имеется в виду текущий путь и все пути ниже него.
Как правило, используется path=/, то есть cookie доступно со всех страниц сайта.

domain=site.com
Домен, на котором доступно cookie. Если не указать, то текущий домен. Допустимо указывать текущий домен site.com и его поддомены, например forum.site.com.

Если указать специальную маску .site.com, то cookie будет доступно на сайте и всех его поддоменах. Это используется, например, в случаях, когда кука содержит данные авторизации и должна быть доступна как на site.com, так и на forum.site.com.

expires=Tue, 19 Jan 2038 03:14:07 GMT
Дата истечения куки в формате GMT. Получить нужную дату можно, используя объект Date. Его можно установить в любое время, а потом вызвать toUTCString(), например:

// +1 день от текущего момента
var date = new Date;
date.setDate(date.getDate() + 1);
alert( date.toUTCString() );
Если дату не указать, то cookie будет считаться «сессионным». Такое cookie удаляется при закрытии браузера. Если дата в прошлом, то кука будет удалена.

secure
Cookie можно передавать только по HTTPS.

Например, чтобы поставить cookie name=value по текущему пути с датой истечения через 60 секунд:

 var date = new Date(new Date().getTime() + 60 * 1000);
document.cookie = "name=value; path=/; expires=" + date.toUTCString();
Чтобы удалить это cookie:

 var date = new Date(0);
document.cookie = "name=; path=/; expires=" + date.toUTCString();
EXTENSION!@@



@@!BLOCK
94--Promise
BLOCK!@@

@@!QWESTION
Эти два варианта кода одинаковы?
// 1
let p = new Promise((resolve, reject) => {
  throw new Error("o_O");
})
p.catch(alert); // Error: o_O

// 2
let p = new Promise((resolve, reject) => {
	reject(new Error("o_O"))
})
p.catch(alert);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать коллбэки двух типов:
onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
Способ использования, в общих чертах, такой:

Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
Внешний код, получив promise, навешивает на него обработчики.
По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
Синтаксис создания Promise:
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически
  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})

Универсальный метод для навешивания обработчиков:
promise.then(onFulfilled, onRejected)
onFulfilled – функция, которая будет вызвана с результатом при resolve.
onRejected – функция, которая будет вызвана с ошибкой при reject.
С его помощью можно назначить как оба обработчика сразу, так и только один:

// onFulfilled сработает при успешном выполнении
promise.then(onFulfilled)
// onRejected сработает при ошибке
promise.then(null, onRejected)
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Что выведут alert`ы?
'use strict';
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("result", "new message"), 1000);
});

promise
  .then(
    function (firstArg, secondArg){
    	alert(firstArg);
    	alert(secondArg);
    }
  );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
result, undefined
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Функции resolve/reject принимают ровно один аргумент – результат/ошибку.
Именно он передаётся обработчикам в .then.

Заметим, что после вызова resolve/reject промис уже не может «передумать».
Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
"Убъёт" ли скрипт асинхронная ошибка из промиса при отсутствии внешнего .catch?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Обработчик .catch(onRejected) получает ошибку и должен обработать её.
Есть два варианта развития событий:
Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).
Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).
Это также похоже на обычный try..catch – в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не «вываливается» в консоль и не «убивает» скрипт.
Ведь возможно, что новый обработчик .catch будет добавлен в цепочку позже.

.catch
Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.

Синхронный throw – то же самое, что reject
Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:
'use strict';
let p = new Promise((resolve, reject) => {
  // то же что reject(new Error("o_O"))
  throw new Error("o_O");
})
p.catch(alert); // Error: o_O

// Ошибки выброшеные из асинхронных функций не будут пойманы методом catch
var p2 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    throw 'Uncaught Exception!';
  }, 1000);
});
p2.catch(function(e) {
  console.log(e); // Никогда не вызовется
});

// Ошибки выброшеные после выполнения обещания будут проигнорированны
var p3 = new Promise(function(resolve, reject) {
  resolve();
  throw 'Silenced Exception!';
});
p3.catch(function(e) {
   console.log(e); // Никогда не вызовется
});
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Что выведут alert`ы в строках 1 и 2
var promise = new Promise((resolve, reject) => resolve(1));
promise.then( function f1(result) {
  alert(result); // 1
  return 'f1';
})
promise.then( function f2(result) {
  alert(result); // 2
  return 'f2';
})
QWESTION!@@

@@!ANSWERS

@@!CORRECT
1
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Согласно стандарту, у объекта new Promise(executor) при создании есть четыре внутренних свойства:
PromiseState – состояние, вначале «pending».
PromiseResult – результат, при создании значения нет.
PromiseFulfillReactions – список функций-обработчиков успешного выполнения.
PromiseRejectReactions – список функций-обработчиков ошибки.

Когда функция-executor вызывает reject или resolve, то PromiseState становится "resolved" или "rejected", а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь "PromiseJobs".
Эта очередь автоматически выполняется, когда интерпретатору «нечего делать». Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как setTimeout(..,0).
Исключение из этого правила – если resolve возвращает другой Promise. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.
Добавляет обработчики в списки один метод: .then(onResolved, onRejected). Метод .catch(onRejected) – всего лишь сокращённая запись .then(null, onRejected).
Он делает следующее:
Если PromiseState == "pending", то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.
Иначе обработчики сразу помещаются в очередь на выполнение.
Здесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно – после (выполнятся в ближайшее время, через асинхронную очередь).

Например:
 // Промис выполнится сразу же
var promise = new Promise((resolve, reject) => resolve(1));
// PromiseState = "resolved"
// PromiseResult = 1
// Добавили обработчик к выполненному промису
promise.then(alert); // ...он сработает тут же

// Промис выполнится сразу же
var promise = new Promise((resolve, reject) => resolve(1));
promise.then( function f1(result) {
  alert(result); // 1
  return 'f1';
})
promise.then( function f2(result) {
  alert(result); // 1
  return 'f2';
})

Вид объекта promise после этого:
https://learn.javascript.ru/article/promise/promiseTwo@2x.png

На этой иллюстрации можно увидеть добавленные нами обработчики f1, f2, а также – автоматически добавленные обработчики ошибок "Thrower".
Дело в том, что .then, если один из обработчиков не указан, добавляет его «от себя», следующим образом:
Для успешного выполнения – функция Identity, которая выглядит как arg => arg, то есть возвращает аргумент без изменений.
Для ошибки – функция Thrower, которая выглядит как arg => throw arg, то есть генерирует ошибку.
Это, по сути дела, формальность, но без неё некоторые особенности поведения промисов могут «не сойтись» в общую логику, поэтому мы упоминаем о ней здесь.
Обратим внимание, в этом примере намеренно не используется чейнинг. То есть, обработчики добавляются именно на один и тот же промис.
Поэтому оба alert выдадут одно значение 1.
Все функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (PromiseResult) после установки не меняется.
Поэтому, чтобы продолжить работу с результатом, используется чейнинг.
Для того, чтобы результат обработчика передать следующей функции, .then создаёт новый промис и возвращает его.

В примере выше создаётся два таких промиса (т.к. два вызова .then), каждый из которых даёт свою ветку выполнения:
https://learn.javascript.ru/article/promise/promiseTwoThen@2x.png

Изначально эти новые промисы – «пустые», они ждут. Когда в будущем выполнятся обработчики f1, f2, то их результат будет передан в новые промисы по стандартному принципу:
Если вернётся обычное значение (не промис), новый промис перейдёт в "resolved" с ним.
Если был throw, то новый промис перейдёт в состояние "rejected" с ошибкой.
Если вернётся промис, то используем его результат (он может быть как resolved, так и rejected).
Дальше выполнятся уже обработчики на новом промисе, и так далее.
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Что вернёт Promise.all если какой-то из промисов завершился с ошибкой?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Эту ошибку
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
Например:
 Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(results => {
  alert(results);
});
Допустим, у нас есть массив с URL.
let urls = [
  '/article/promise/user.json',
  '/article/promise/guest.json'
];
Чтобы загрузить их параллельно, нужно:
Создать для каждого URL соответствующий промис.
Обернуть массив таких промисов в Promise.all.
Получится так:
'use strict';
let urls = [
  '/article/promise/user.json',
  '/article/promise/guest.json'
];
Promise.all( urls.map(httpGet) )
  .then(results => {
    alert(results);
  });
Заметим, что если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.
Например:
 Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json'),
  httpGet('/article/promise/no-such-page.json') // (нет такой страницы)
]).then(
  result => alert("не сработает"),
  error => alert("Ошибка: " + error.message) // Ошибка: Not Found
)
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Что возвращает Promise.race(iterable)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Первый успешно выполнившийся промис из списка
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Promise.race(iterable)
Вызов Promise.race, как и Promise.all, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.
Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
Например:
 Promise.race([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(firstResult => {
  firstResult = JSON.parse(firstResult);
  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
});
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Эти конструкции идентичны?
Promise.resolve(value) // 1
new Promise((resolve) => resolve(value)) // 2
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Promise.resolve(value)
Вызов Promise.resolve(value) создаёт успешно выполнившийся промис с результатом value.
Он аналогичен конструкции:
new Promise((resolve) => resolve(value))
Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.
Например:
 Promise.resolve(window.location) // начать с этого значения
  .then(httpGet) // вызвать для него httpGet
  .then(alert) // и вывести результат
Promise.reject(error)
Аналогично Promise.resolve(value) создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой error.
Например:
 Promise.reject(new Error("..."))
  .catch(alert) // Error: ...
Метод Promise.reject используется очень редко, гораздо реже чем resolve, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.
EXTENSION!@@



@@!BLOCK
Promise vm7
BLOCK!@@

@@!QWESTION
Что выведет в консоль этот код?
Promise.resolve('foo')
  .then(Promise.resolve('bar'))
  .then(function (result) {
    console.log(result);
  });
QWESTION!@@

@@!ANSWERS

@@!CORRECT
foo
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Причина в том, что, когда вы передаете в then() что-то отличное от функции (например, промис), это интерпретируется как then(null) и в следующий по цепочке промис «проваливается» результат предыдущего. Проверьте сами:
Promise.resolve('foo')
  .then(null)
  .then(function (result) {
    console.log(result);
  });
Добавьте сколько угодно then(null), результат останется прежним — в консоли вы увидите foo.
Данный пример возвращает нас к выбору между промисами и фабриками промисов. Мы разбирали его выше. Если коротко, вы можете передавать прямо в then() промис, но результат будет совсем не тем, что вы ожидали. Метод then() ожидает функцию. Чтобы ожидания сбылись, нужно переписать пример как-то так:
Promise.resolve('foo')
  .then(function () {
    return Promise.resolve('bar');
  })
  .then(function (result) {
    console.log(result);
  });
В консоли вы увидите bar, как и ожидали.
Запоминаем: в метод then() передаем только функции.
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Укажите последовательно исполнения данных конструкций.
// 1
doSomething().then(function () {
    return doSomethingElse();
  })
  .then(finalHandler);

// 2
doSomething().then(function () {
    doSomethingElse();
  })
  .then(finalHandler);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
// 1
doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|

// 2
doSomething
|-----------------|
                  doSomethingElse(undefined)
                  |------------------|
                  										finalHandler(undefined)
                  										|------------------|
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
// 1
У функции doSomething() нет аргумента, поэтому doSomethingElse() получает undefined.
Т.к. в первом then есть return finalHandler ждёт выполнения doSomethingElse

// 2
В первом then нет return, поэтому doSomethingElse возвращает результат в никуда.
Кроме того, если в doSomethingElse есть асинхронная операция, finalHandler не будет ждать её исполнения
т.к. function () {
    doSomethingElse();
  }) вернёт undefined (поведение по умолчанию при отсутствии явного return), с которым и будет работать finalHandler.
EXTENSION!@@



@@!BLOCK
Promise
BLOCK!@@

@@!QWESTION
Укажите последовательно исполнения данных конструкций.
// 1
doSomething().then(doSomethingElse())
  .then(finalHandler);

// 2
doSomething().then(doSomethingElse)
  .then(finalHandler);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
// 1
doSomething
|-----------------|
doSomethingElse(undefined)
|---------------------------------|
                  finalHandler(resultOfDoSomething)
                  |------------------|

// 2
doSomething
|-----------------|
                  doSomethingElse(resultOfDoSomething)
                  |------------------|
                                     finalHandler(resultOfDoSomethingElse)
                                     |------------------|
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В обоих примерах функция doSomethingElse выступает как параметр resolve (.then(resolve, reject)), поэтому then возвращает её результат.

// 1
Функция doSomethingElse() вызывается сразу (есть скобки после имени функции), то в then передаётся её результат, а не она сама.
И выполнена doSomethingElse будет синхронно.
finalHandler получит результат doSomethingElse

Функция doSomethingElse() вызывается вызывается методом .then, выполняется асинхронно, передаёт свой результат в ожидающую её finalHandler.
EXTENSION!@@



@@!BLOCK
95--Генераторы
BLOCK!@@

@@!QWESTION
Что выведет console.log() в строке // 1?
function* generateSequence() {
  console.log( 'Hello' );  // 1
  yield 1;
  yield 2;
}
generateSequence();
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ничего
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Генераторы – новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.
Создание генератора
Для объявления генератора используется новая синтаксическая конструкция: function* (функция со звёздочкой).
Её называют «функция-генератор» (generator function).
Выглядит это так:
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
При запуске generateSequence() код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором».
При создании генератора код находится в начале своего выполнения.
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
Что выведет console.log() в строке?
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
let generator = generateSequence();
let one = generator.next();
console.log( one );
QWESTION!@@

@@!ANSWERS

@@!CORRECT
{value: 1, done: false}
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При создании генератора код находится в начале своего выполнения.
Основным методом генератора является next(). При вызове он возобновляет выполнение кода до ближайшего ключевого слова yield. По достижении yield выполнение приостанавливается, а значение – возвращается во внешний код:
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
let generator = generateSequence();
let one = generator.next();
alert(JSON.stringify(one)); // {value: 1, done: false}

Повторный вызов generator.next() возобновит выполнение и вернёт результат следующего yield:
let two = generator.next();
alert(JSON.stringify(two)); // {value: 2, done: false}
И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
let three = generator.next();
alert(JSON.stringify(three)); // {value: 3, done: true}
Функция завершена. Внешний код должен увидеть это из свойства done:true и обработать value:3, как окончательный результат.
Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: {done: true}.
«Открутить назад» завершившийся генератор нельзя, но можно создать новый ещё одним вызовом generateSequence() и выполнить его.
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
Что выведет alert?
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
let generator = generateSequence();
for(let value of generator) {
  alert(value);
}
QWESTION!@@

@@!ANSWERS

@@!CORRECT
1, затем 2
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Как вы, наверно, уже догадались по наличию метода next(), генератор связан с итераторами. В частности, он является итерируемым объектом.
Его можно перебирать и через for..of:
 function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
let generator = generateSequence();
for(let value of generator) {
  alert(value); // 1, затем 2
}
Заметим, однако, существенную особенность такого перебора!
При запуске примера выше будет выведено значение 1, затем 2. Значение 3 выведено не будет. Это потому что стандартный перебор итератора игнорирует value на последнем значении, при done: true. Так что результат return в цикле for..of не выводится.
Соответственно, если мы хотим, чтобы все значения возвращались при переборе через for..of, то надо возвращать их через yield:
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}
let generator = generateSequence();
for(let value of generator) {
  alert(value); // 1, затем 2, затем 3
}
…А зачем вообще return при таком раскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через for..of – в некотором смысле «исключение». Как мы увидим дальше, в других контекстах return очень даже востребован.
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
Код // 1 и код // 2 работают одиноково?

// 1
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}
function* generateAlphaNum() {
  yield* generateSequence(48, 57);
}
let str = '';
for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}
alert(str);

// 2
function* generateAlphaNum() {
  for (let i = 48; i <= 57; i++) yield i;
}
let str = '';
for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}
alert(str);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Один генератор может включать в себя другие. Это называется композицией.
Разберём композицию на примере.
Пусть у нас есть функция generateSequence, которая генерирует последовательность чисел:
 function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}
// Используем оператор … для преобразования итерируемого объекта в массив
let sequence = [...generateSequence(2,5)];
alert(sequence); // 2, 3, 4, 5
Мы хотим на её основе сделать другую функцию generateAlphaNum(), которая будет генерировать коды для буквенно-цифровых символов латинского алфавита:
48..57 – для 0..9
65..90 – для A..Z
97..122 – для a..z
Далее этот набор кодов можно превратить в строку и использовать, к примеру, для выбора из него случайного пароля. Только символы пунктуации ещё хорошо бы добавить для надёжности, но в этом примере мы будем без них.
Естественно, раз в нашем распоряжении есть готовый генератор generateSequence, то хорошо бы его использовать.
Конечно, можно внутри generateAlphaNum запустить несколько раз generateSequence, объединить результаты и вернуть. Так мы бы сделали с обычными функциями. Но композиция – это кое-что получше.
Она выглядит так:
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

  // 0..9
  yield* generateSequence(48, 57);

  // A..Z
  yield* generateSequence(65, 90);

  // a..z
  yield* generateSequence(97, 122);

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
Здесь использована специальная форма yield*. Она применима только к другому генератору и делегирует ему выполнение.
То есть, при yield* интерпретатор переходит внутрь генератора-аргумента, к примеру, generateSequence(48, 57), выполняет его, и все yield, которые он делает, выходят из внешнего генератора.
Получается – как будто мы вставили код внутреннего генератора во внешний напрямую, вот так:
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;

  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;

  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
Код выше по поведению полностью идентичен варианту с yield*. При этом, конечно, переменные вложенного генератора не попадают во внешний, «делегирование» только выводит результаты yield во внешний поток.

Композиция – это естественное встраивание одного генератора в поток другого. При композиции значения из вложенного генератора выдаются «по мере готовности». Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
Что выведет alert?
function* gen() {
  let result = yield "2 + 2?";
  alert(result);
}
let generator = gen();
let question = generator.next().value;
setTimeout(() => generator.next(4), 2000);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
4
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
До этого генераторы наиболее напоминали «итераторы на стероидах». Но, как мы сейчас увидим, это не так, есть фундаментальное различие, генераторы гораздо мощнее и гибче.
Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор.
Вызов let result = yield value делает следующее:
Возвращает value во внешний код, приостанавливая выполнение генератора.
Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
Генератор продолжит выполнение, аргумент next будет возвращён как результат yield (и записан в result).
Продемонстрируем это на примере:
function* gen() {
  // Передать вопрос во внешний код и подождать ответа
  let result = yield "2 + 2?";
  alert(result);
}
let generator = gen();
let question = generator.next().value;
// "2 + 2?"
setTimeout(() => generator.next(4), 2000);
Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат первого yield («2+2?»). На этой точке генератор приостанавливает выполнение.
Результат yield переходит во внешний код (в question). Внешний код может выполнять любые асинхронные задачи, генератор стоит «на паузе».
Когда асинхронные задачи готовы, внешний код вызывает generator.next(4) с аргументом. Выполнение генератора возобновляется, а 4 выходит из присваивания как результат let result = yield ....
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
В какой строке возникнет исключение?
function* gen() {   // 1
  try { // 2
    let result = yield "Сколько будет 2 + 2?";  // 3
  } catch(e) {  // 4
    alert(e);   // 5
  } // 6
}   // 7
let generator = gen();  // 8
let question = generator.next().value;  // 9
generator.throw(new Error("ответ не найден в моей базе данных"));   // 10
QWESTION!@@

@@!ANSWERS

@@!CORRECT
3
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для того, чтобы передать в yield ошибку, используется вызов generator.throw(err). При этом на строке с yield возникает исключение.
Например, в коде ниже обращение к внешнему коду yield "Сколько будет 2 + 2" завершится с ошибкой:
function* gen() {
  try {
    // в этой строке возникнет ошибка
    let result = yield "Сколько будет 2 + 2?"; // (**)

    alert("выше будет исключение ^^^");
  } catch(e) {
    alert(e); // выведет ошибку
  }
}
let generator = gen();
let question = generator.next().value;
generator.throw(new Error("ответ не найден в моей базе данных")); // (*)
«Вброшенная» в строке (*) ошибка возникает в строке с yield (**). Далее она обрабатывается как обычно. В примере выше она перехватывается try..catch и выводится.
Если ошибку не перехватить, то она «выпадет» из генератора. По стеку ближайший вызов, который инициировал выполнение – это строка с .throw. Можно перехватить её там, как и продемонстрировано в примере ниже:
function* gen() {
  // В этой строке возникнет ошибка
  let result = yield "Сколько будет 2 + 2?";
}
let generator = gen();
let question = generator.next().value;
try {
  generator.throw(new Error("ответ не найден в моей базе данных"));
} catch(e) {
  alert(e); // выведет ошибку
}
Если же ошибка и там не перехвачена, то дальше – как обычно, либо try..catch снаружи, либо она «повалит» скрипт.
EXTENSION!@@



@@!BLOCK
Генераторы
BLOCK!@@

@@!QWESTION
yield'может возвращать промисы?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Да
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
Общий принцип такой:
- Генератор yield'ит не просто значения, а промисы.
- Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
- Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.

Напишем такой код для получения аватара пользователя с github и его вывода, аналогичный рассмотренному в статье про промисы.
Для AJAX-запросов будем использовать метод fetch, он как раз возвращает промисы.
// генератор для получения и показа аватара
// он yield'ит промисы
function* showUserAvatar() {

  let userFetch = yield fetch('/article/generator/user.json');
  let userInfo = yield userFetch.json();

  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`);
  let githubUserInfo = yield githubFetch.json();

  let img = new Image();
  img.src = githubUserInfo.avatar_url;
  img.className = "promise-avatar-example";
  document.body.appendChild(img);

  yield new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return img.src;
}

// вспомогательная функция-чернорабочий
// для выполнения промисов из generator
function execute(generator, yieldValue) {

  let next = generator.next(yieldValue);

  if (!next.done) {
    next.value.then(
      result => execute(generator, result),
      err => generator.throw(err)
    );
  } else {
    // обработаем результат return из генератора
    // обычно здесь вызов callback или что-то в этом духе
    alert(next.value);
  }

}
execute( showUserAvatar() );
Функция execute в примере выше – универсальная, она может работать с любым генератором, который yield'ит промисы.
EXTENSION!@@



@@!BLOCK
96--Модули
BLOCK!@@

@@!QWESTION
При помощи какого ключевого слова можно указать, что переменная one будет доступна снаружи (экспортирована) под именем once?
export {one *key-word* once};
QWESTION!@@

@@!ANSWERS

@@!CORRECT
as
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Модулем считается файл с кодом.
В этом файле ключевым словом export помечаются переменные и функции, которые могут быть использованы снаружи.
Другие модули могут подключать их через вызов import.

export
Ключевое слово export можно ставить:

перед объявлением переменных, функций и классов.
отдельно, при этом в фигурных скобках указывается, что именно экспортируется.
Например, так экспортируется переменная one:

// экспорт прямо перед объявлением
export let one = 1;
Можно написать export и отдельно от объявления:

let two = 2;

export {two};
При этом в фигурных скобках указываются одна или несколько экспортируемых переменных.

Для двух переменных будет так:

export {one, two};
При помощи ключевого слова as можно указать, что переменная one будет доступна снаружи (экспортирована) под именем once, а two – под именем twice:

export {one as once, two as twice};
Экспорт функций и классов выглядит так же:

export class User {
  constructor(name) {
    this.name = name;
  }
};

export function sayHi() {
  alert("Hello!");
};

// отдельно от объявлений было бы так:
// export {User, sayHi}
Для экспорта обязательно нужно имя
Заметим, что и у функции и у класса при таком экспорте должно быть имя.

Так будет ошибка:

// функция без имени
export function() { alert("Error"); };
В экспорте указываются именно имена, а не произвольные выражения.

import
Другие модули могут подключать экспортированные значения при помощи ключевого слова import.

Синтаксис:

import {one, two} from "./nums";
Здесь:

"./nums" – модуль, как правило это путь к файлу модуля.
one, two – импортируемые переменные, которые должны быть обозначены в nums словом export.
В результате импорта появятся локальные переменные one, two, которые будут содержать значения соответствующих экспортов.

Например, при таком файле nums.js:

export let one = 1;
export let two = 2;
Модуль ниже выведет «1 and 2»:

import {one, two} from "./nums";

alert( `${one} and ${two}` ); // 1 and 2
Импортировать можно и под другим именем, указав его в «as»:

// импорт one под именем item1, а two – под именем item2
import {one as item1, two as item2} from "./nums";

alert( `${item1} and ${item2}` ); // 1 and 2
Импорт всех значений в виде объекта
Можно импортировать все значения сразу в виде объекта вызовом import * as obj, например:


import * as numbers from "./nums";

// теперь экспортированные переменные - свойства numbers
alert( `${numbers.one} and ${numbers.two}` ); // 1 and 2
EXTENSION!@@



@@!BLOCK
Модули
BLOCK!@@

@@!QWESTION
Как понять, что User экспортируется по умолчанию?
import User from './user';
QWESTION!@@

@@!ANSWERS

@@!CORRECT
По отсутствию фигурных скобок
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Выше мы видели, что модуль может экспортировать выбранные переменные при помощи export.
Однако, как правило, код стараются организовать так, чтобы каждый модуль делал одну вещь. Иначе говоря, «один файл – одна сущность, которую он описывает». Например, файл user.js содержит class User, файл login.js – функцию login() для авторизации, и т.п.
При этом модули, разумеется, будут использовать друг друга. Например, login.js, скорее всего, будет импортировать класс User из модуля user.js.
Для такой ситуации, когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание export default.
Если поставить после export слово default, то значение станет «экспортом по умолчанию».
Такое значение можно импортировать без фигурных скобок.
Например, файл user.js:

              export default class User {
  constructor(name) {
    this.name = name;
  }
};
…А в файле login.js:

import User from './user';

new User("Вася");
«Экспорт по умолчанию» – своего рода «синтаксический сахар». Можно было бы и без него, импортировать значение обычным образом через фигурные скобки {…}. Если бы в user.js не было default, то в login.js необходимо было бы указать фигурные скобки:

// если бы user.js содержал
// export class User { ... }

// …то при импорте User понадобились бы фигурные скобки:
import {User} from './user';

new User("Вася");
На практике этот «сахар» весьма приятен, так как позволяет легко видеть, какое именно значение экспортирует модуль, а также обойтись без лишних символов при импорте.
EXTENSION!@@



@@!BLOCK
97--Proxy
BLOCK!@@

@@!QWESTION
Что вернёт alert?
'use strict';
let dictionary = {
  'Hello': 'Привет'
};
dictionary = new Proxy(dictionary, {
  has(target, phrase) {
    return true;
  }
});
alert("BlaBlaBla" in dictionary);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
true
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Прокси (proxy) – особый объект, смысл которого – перехватывать обращения к другому объекту и, при необходимости, модифицировать их.

Синтаксис:

let proxy = new Proxy(target, handler)
Здесь:

target – объект, обращения к которому надо перехватывать.
handler – объект с «ловушками»: функциями-перехватчиками для операций к target.
Почти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту target, например: чтение и запись свойств, получение списка свойств, вызов функции (если target – функция) и т.п.

Различных типов ловушек довольно много.

Сначала мы подробно рассмотрим самые важные «ловушки», а затем посмотрим и на их полный список.

Если ловушки нет – операция идёт над target
Если для операции нет ловушки, то она выполняется напрямую над target.

get/set
Самыми частыми являются ловушки для чтения и записи в объект:

get(target, property, receiver)
Срабатывает при чтении свойства из прокси. Аргументы:
target – целевой объект, тот же который был передан первым аргументом в new Proxy.
property – имя свойства.
receiver – объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него. Этот аргумент используется редко.
set(target, property, value, receiver)

Срабатывает при записи свойства в прокси.
Аргументы:
target – целевой объект, тот же который был передан первым аргументом в new Proxy.
property – имя свойства.
value – значение свойства.
receiver – объект, к которому было применено присваивание, обычно сам прокси, либо прототипно наследующий от него.
Метод set должен вернуть true, если присвоение успешно обработано и false в случае ошибки (приведёт к генерации TypeError).
Пример с выводом всех операций чтения и записи:
'use strict';
let user = {};

let proxy = new Proxy(user, {
  get(target, prop) {
    alert(`Чтение ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    alert(`Запись ${prop} ${value}`);
    target[prop] = value;
    return true;
  }
});
proxy.firstName = "Ilya"; // запись
proxy.firstName; // чтение
alert(user.firstName); // Ilya
При каждой операции чтения и записи свойств proxy в коде выше срабатывают методы get/set. Через них значение в конечном счёте попадает в объект (или считывается из него).
Можно сделать и позаковыристее.
Методы get/set позволяют реализовать доступ к произвольным свойствам, которых в объекте нет.
Например, в коде ниже словарь dictionary содержит различные фразы:
 'use strict';

let dictionary = {
  'Hello': 'Привет',
  'Bye': 'Пока'
};
alert( dictionary['Hello'] ); // Привет
А что, если фразы нет? В этом случае будем возвращать фразу без перевода и, на всякий случай, писать об этом в консоль:
'use strict';
let dictionary = {
  'Hello': 'Привет',
  'Bye': 'Пока'
};
dictionary = new Proxy(dictionary, {
  get(target, phrase) {
    if (phrase in target) {
      return target[phrase];
    } else {
      console.log(`No phrase: ${phrase}`);
      return phrase;
    }
  }
})
// Обращаемся к произвольным свойствам словаря!
alert( dictionary['Hello'] ); // Привет
alert( dictionary['Welcome']); // Welcome (без перевода)
Аналогично и перехватчик set может организовать работу с произвольными свойствами.

has
Ловушка has срабатывает в операторе in и некоторых других случаях, когда проверяется наличие свойства.
В примере выше, если проверить наличие свойства Welcome в dictionary, то оператор in вернёт false:
alert( 'Hello' in dictionary ); // true
alert( 'Welcome' in dictionary ); // false, нет такого свойства
Это потому, что для перехвата in используется ловушка has. При отсутствии ловушки операция производится напрямую над исходным объектом target, что и даёт такой результат.
Синтаксис has аналогичен get.
Вот так dictionary будет всегда возвращать true для любой in-проверки:
'use strict';
let dictionary = {
  'Hello': 'Привет'
};
dictionary = new Proxy(dictionary, {
  has(target, phrase) {
    return true;
  }
});
alert("BlaBlaBla" in dictionary); // true
deleteProperty
Ловушка deleteProperty по синтаксису аналогична get/has.

Срабатывает при операции delete, должна вернуть true, если удаление было успешным.

В примере ниже delete не повлияет на исходный объект, так как все операции перехватываются и «аннигилируются» прокси:
'use strict';

let dictionary = {
  'Hello': 'Привет'
};

let proxy = new Proxy(dictionary, {
  deleteProperty(target, phrase) {
    return true; // ничего не делаем, но возвращает true
  }
});

// не удалит свойство
delete proxy['Hello'];

alert("Hello" in dictionary); // true

// будет то же самое, что и выше
// так как нет ловушки has, операция in сработает на исходном объекте
alert("Hello" in proxy); // true

apply
Прокси умеет работать не только с обычными объектами, но и с функциями.

Если аргумент target прокси – функция, то становится доступна ловушка apply для её вызова.

Метод apply(target, thisArgument, argumentsList) получает:

target – исходный объект.
thisArgument – контекст this вызова.
argumentsList – аргументы вызова в виде массива.
Она может обработать вызов сама и/или передать его функции.

'use strict';

function sum(a, b) {
  return a + b;
}

let proxy = new Proxy(sum, {
  // передаст вызов в target, предварительно сообщив о нём
  apply: function(target, thisArg, argumentsList) {
    alert(`Буду вычислять сумму: ${argumentsList}`);
    return target.apply(thisArg, argumentsList);
  }
});

// Выведет сначала сообщение из прокси,
// а затем уже сумму
alert( proxy(1, 2) );
Нечто подобное можно сделать через замыкания. Но прокси может гораздо больше. В том числе и перехватывать вызовы через new.

construct
Ловушка construct(target, argumentsList) перехватывает вызовы при помощи new.

Она получает исходный объект target и список аргументов argumentsList.

Пример ниже передаёт операцию создания исходному классу или функции-конструктору, выводя сообщение об этом:
'use strict';

function User(name, surname) {
  this.name = name;
  this.surname = surname;
}

let UserProxy = new Proxy(User, {
  // передаст вызов new User, предварительно сообщив о нём
  construct: function(target, argumentsList) {
    alert(`Запуск new с аргументами: ${argumentsList}`);
    return new target(...argumentsList);
  }
});

let user = new UserProxy("Ilya", "Kantor");

alert( user.name ); // Ilya
Полный список
Полный список возможных функций-перехватчиков, которые может задавать handler:

getPrototypeOf – перехватывает обращение к методу getPrototypeOf.
setPrototypeOf – перехватывает обращение к методу setPrototypeOf.
isExtensible – перехватывает обращение к методу isExtensible.
preventExtensions – перехватывает обращение к методу preventExtensions.
getOwnPropertyDescriptor – перехватывает обращение к методу getOwnPropertyDescriptor.
defineProperty – перехватывает обращение к методу defineProperty.
has – перехватывает проверку существования свойства, которая используется в операторе in и в некоторых других методах встроенных объектов.
get – перехватывает чтение свойства.
set – перехватывает запись свойства.
deleteProperty – перехватывает удаление свойства оператором delete.
enumerate – срабатывает при вызове for..in или for..of, возвращает итератор для свойств объекта.
ownKeys – перехватывает обращения к методу getOwnPropertyNames.
apply – перехватывает вызовы target().
construct – перехватывает вызовы new target().
Каждый перехватчик запускается с handler в качестве this. Это означает, что handler кроме ловушек может содержать и другие полезные свойства и методы.

Каждый перехватчик получает в аргументах target и дополнительные параметры в зависимости от типа.

Если перехватчик в handler не указан, то операция совершается, как если бы была вызвана прямо на target.

Итого
Proxy позволяет модифицировать поведение объекта как угодно, перехватывать любые обращения к его свойствам и методам, включая вызовы для функций.
Особенно приятна возможность перехватывать обращения к отсутствующим свойствам, разработчики ожидали её уже давно.
Что касается поддержки, то возможности полифиллов здесь ограничены. «Переписать» прокси на старом JavaScript сложновато, учитывая низкоуровневые возможности, которые он даёт.
Поэтому нужна именно браузерная поддержка. Постепенно она реализуется.
EXTENSION!@@



@@!BLOCK
98--Основы XMLHttpRequest
BLOCK!@@

@@!QWESTION
Что означает третий параметр в данном коде?
xhr.open('GET', 'phones.json', false);
QWESTION!@@

@@!ANSWERS

@@!CORRECT
async – если установлено в false, то запрос производится синхронно, если true – асинхронно.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Основы XMLHttpRequest
Объект XMLHttpRequest (или, как его кратко называют, «XHR») дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.

Несмотря на слово «XML» в названии, XMLHttpRequest может работать с любыми данными, а не только с XML.

Использовать его очень просто.

Пример использования
Как правило, XMLHttpRequest используют для загрузки данных.

Для начала посмотрим на пример использования, который загружает файл phones.json из текущей директории и выдаёт его содержимое:
// 1. Создаём новый объект XMLHttpRequest
var xhr = new XMLHttpRequest();

// 2. Конфигурируем его: GET-запрос на URL 'phones.json'
xhr.open('GET', 'phones.json', false);

// 3. Отсылаем запрос
xhr.send();

// 4. Если код ответа сервера не 200, то это ошибка
if (xhr.status != 200) {
  // обработать ошибку
  alert( xhr.status + ': ' + xhr.statusText ); // пример вывода: 404: Not Found
} else {
  // вывести результат
  alert( xhr.responseText ); // responseText -- текст ответа.
}

Настроить: open
Синтаксис:

xhr.open(method, URL, async, user, password)
Этот метод – как правило, вызывается первым после создания объекта XMLHttpRequest.

Задаёт основные параметры запроса:

method – HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде TRACE/DELETE/PUT и т.п.

URL – адрес запроса. Можно использовать не только http/https, но и другие протоколы, например ftp:// и file://.

При этом есть ограничения безопасности, называемые «Same Origin Policy»: запрос со страницы можно отправлять только на тот же протокол://домен:порт, с которого она пришла. В следующих главах мы рассмотрим, как их можно обойти.

async – если установлено в false, то запрос производится синхронно, если true – асинхронно.

«Синхронный запрос» означает, что после вызова xhr.send() и до ответа сервера главный поток будет «заморожен»: посетитель не сможет взаимодействовать со страницей – прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.

«Асинхронный запрос» означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий, которые мы рассмотрим далее.

user, password – логин и пароль для HTTP-авторизации, если нужны.
Вызов open не открывает соединение
Заметим, что вызов open, в противоположность своему названию (open – англ. «открыть») не открывает соединение. Он лишь настраивает запрос, а коммуникация инициируется методом send.
EXTENSION!@@



@@!BLOCK
Основы XMLHttpRequest
BLOCK!@@

@@!QWESTION
Какой метод открывает соединение и отправляет запрос на сервер?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
xhr.send([body])
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Отослать данные: send
Синтаксис:

xhr.send([body])
Именно этод метод открывает соединение и отправляет запрос на сервер.

В body находится тело запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет, а у POST – основные данные как раз передаются через body.

Отмена: abort
Вызов xhr.abort() прерывает выполнение запроса.

Ответ: status, statusText, responseText
Основные свойства, содержащие ответ сервера:

status
HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен.
statusText
Текстовое описание статуса от сервера: OK, Not Found, Forbidden и так далее.
responseText
Текст ответа сервера.
Есть и ещё одно свойство, которое используется гораздо реже:

responseXML
Если сервер вернул XML, снабдив его правильным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы xhr.responseXml.querySelector("...") и другие.

Оно используется редко, так как обычно используют не XML, а JSON. То есть, сервер возвращает JSON в виде текста, который браузер превращает в объект вызовом JSON.parse(xhr.responseText).

Синхронные и асинхронные запросы
Если в методе open установить параметр async равным false, то запрос будет синхронным.

Синхронные вызовы используются чрезвычайно редко, так как блокируют взаимодействие со страницей до окончания загрузки. Посетитель не может даже прокручивать её. Никакой JavaScript не может быть выполнен, пока синхронный вызов не завершён – в общем, в точности те же ограничения как alert.
// Синхронный запрос
xhr.open('GET', 'phones.json', false);

// Отсылаем его
xhr.send();
// ...весь JavaScript "подвиснет", пока запрос не завершится
Если синхронный вызов занял слишком много времени, то браузер предложит закрыть «зависшую» страницу.

Из-за такой блокировки получается, что нельзя отослать два запроса одновременно. Кроме того, забегая вперёд, заметим, что ряд продвинутых возможностей, таких как возможность делать запросы на другой домен и указывать таймаут, в синхронном режиме не работают.

Из всего вышесказанного уже должно быть понятно, что синхронные запросы используются чрезвычайно редко, а асинхронные – почти всегда.

Для того, чтобы запрос стал асинхронным, укажем параметр async равным true.

Изменённый JS-код:
var xhr = new XMLHttpRequest();

xhr.open('GET', 'phones.json', true);

xhr.send(); // (1)

xhr.onreadystatechange = function() { // (3)
  if (xhr.readyState != 4) return;

  button.innerHTML = 'Готово!';

  if (xhr.status != 200) {
    alert(xhr.status + ': ' + xhr.statusText);
  } else {
    alert(xhr.responseText);
  }

}

button.innerHTML = 'Загружаю...'; // (2)
button.disabled = true;
Если в open указан третий аргумент true (или если третьего аргумента нет), то запрос выполняется асинхронно. Это означает, что после вызова xhr.send() в строке (1) код не «зависает», а преспокойно продолжает выполняться, выполняется строка (2), а результат приходит через событие (3), мы изучим его чуть позже.
EXTENSION!@@



@@!BLOCK
Основы XMLHttpRequest
BLOCK!@@

@@!QWESTION
Что означает статус xhr.status = 3?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Событие readystatechange происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть «текущее состояние запроса» в свойстве xhr.readyState.

В примере выше мы использовали только состояние 4 (запрос завершён), но есть и другие.

Все состояния, по спецификации:

const unsigned short UNSENT = 0; // начальное состояние
const unsigned short OPENED = 1; // вызван open
const unsigned short HEADERS_RECEIVED = 2; // получены заголовки
const unsigned short LOADING = 3; // загружается тело (получен очередной пакет данных)
const unsigned short DONE = 4; // запрос завершён
Запрос проходит их в порядке 0 → 1 → 2 → 3 → … → 3 → 4, состояние 3 повторяется при каждом получении очередного пакета данных по сети.

Пример ниже демонстрирует переключение между состояниями. В нём сервер отвечает на запрос digits, пересылая по строке из 1000 цифр раз в секунду.

Результатserver.jsindex.html

Точка разрыва пакетов не гарантирована
При состоянии readyState=3 (получен очередной пакет) мы можем посмотреть текущие данные в responseText и, казалось бы, могли бы работать с этими данными как с «ответом на текущий момент».

Однако, технически мы не управляем разрывами между сетевыми пакетами. Если протестировать пример выше в локальной сети, то в большинстве браузеров разрывы будут каждые 1000 символов, но в реальности пакет может прерваться на любом байте.

Чем это опасно? Хотя бы тем, что символы русского языка в кодировке UTF-8 кодируются двумя байтами каждый – и разрыв может возникнуть между ними.

Получится, что при очередном readyState в конце responseText будет байт-полсимвола, то есть он не будет корректной строкой – частью ответа! Если в скрипте как-то по-особому это не обработать, то неизбежны проблемы.

HTTP-заголовки
XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.

Для работы с HTTP-заголовками есть 3 метода:

setRequestHeader(name, value)
Устанавливает заголовок name запроса со значением value.

Например:

xhr.setRequestHeader('Content-Type', 'application/json');
Ограничения на заголовки
Нельзя установить заголовки, которые контролирует браузер, например Referer или Host и ряд других (полный список тут).

Это ограничение существует в целях безопасности и для контроля корректности запроса.

Поставленный заголовок нельзя снять
Особенностью XMLHttpRequest является то, что отменить setRequestHeader невозможно.

Повторные вызовы лишь добавляют информацию к заголовку, например:

xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// в результате будет заголовок:
// X-Auth: 123, 456
getResponseHeader(name)
Возвращает значение заголовка ответа name, кроме Set-Cookie и Set-Cookie2.

Например:

xhr.getResponseHeader('Content-Type')
getAllResponseHeaders()
Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.

Заголовки возвращаются в виде единой строки, например:

Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
Между заголовками стоит перевод строки в два символа "\r\n" (не зависит от ОС), значение заголовка отделено двоеточием с пробелом ": ". Этот формат задан стандартом.

Таким образом, если хочется получить объект с парами заголовок-значение, то эту строку необходимо разбить и обработать.
EXTENSION!@@



@@!BLOCK
Основы XMLHttpRequest
BLOCK!@@

@@!QWESTION
Какое событие будет сгенерировано при превышении запроса xhr.timeout?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
ontimeout
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При превышении этого времени запрос будет оборван и сгенерировано событие ontimeout:

xhr.ontimeout = function() {
  alert( 'Извините, запрос превысил максимальное время' );
}

Полный список событий
Современная спецификация предусматривает следующие события по ходу обработки запроса:

loadstart – запрос начат.
progress – браузер получил очередной пакет данных, можно прочитать текущие полученные данные в responseText.
abort – запрос был отменён вызовом xhr.abort().
error – произошла ошибка.
load – запрос был успешно (без ошибок) завершён.
timeout – запрос был прекращён по таймауту.
loadend – запрос был завершён (успешно или неуспешно)
Используя эти события можно более удобно отслеживать загрузку (onload) и ошибку (onerror), а также количество загруженных данных (onprogress).

Ранее мы видели ещё одно событие – readystatechange. Оно появилось гораздо раньше, ещё до появления текущего стандарта.

В современных браузерах от него можно отказаться в пользу других, необходимо лишь, как мы увидим далее, учесть особенности IE8-9.
EXTENSION!@@



@@!BLOCK
Основы XMLHttpRequest
BLOCK!@@

@@!QWESTION
Какие события поддерживает XMLHttpRequest IE8 и IE9?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Только onreadystatechange
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В IE8 и IE9 поддержка XMLHttpRequest ограничена:

Не поддерживаются события, кроме onreadystatechange.
Некорректно поддерживается состояние readyState = 3: браузер может сгенерировать его только один раз во время запроса, а не при каждом пакете данных. Кроме того, он не даёт доступ к ответу responseText до того, как он будет до конца получен.
Дело в том, что, когда создавались эти браузеры, спецификации были не до конца проработаны. Поэтому разработчики браузера решили добавить свой объект XDomainRequest, который реализовывал часть возможностей современного стандарта.

А обычный XMLHttpRequest решили не трогать, чтобы ненароком не сломать существующий код.

Мы подробнее поговорим про XDomainRequest в главе XMLHttpRequest: кросс-доменные запросы. Пока лишь заметим, что для того, чтобы получить некоторые из современных возможностей в IE8,9 – вместо new XMLHttpRequest() нужно использовать new XDomainRequest.

Кросс-браузерно:

var XHR = ("onload" in new XMLHttpRequest()) ? XMLHttpRequest : XDomainRequest;
var xhr = new XHR();
Теперь в IE8,9 поддерживаются события onload, onerror и onprogress. Это именно для IE8,9. Для IE10 обычный XMLHttpRequest уже является полноценным.

IE9- и кеширование
Обычно ответы на запросы XMLHttpRequest кешируются, как и обычные страницы.

Но IE9- по умолчанию кеширует все ответы, не снабжённые антикеш-заголовком. Другие браузеры этого не делают. Чтобы этого избежать, сервер должен добавить в ответ соответствующие антикеш-заголовки, например Cache-Control: no-cache.

Впрочем, использовать заголовки типа Expires, Last-Modified и Cache-Control рекомендуется в любом случае, чтобы дать понять браузеру (не обязательно IE), что ему следует делать.

Альтернативный вариант – добавить в URL запроса случайный параметр, предотвращающий кеширование.

Например, вместо xhr.open('GET', 'service', false) написать:
xhr.open('GET', 'service?r=' + Math.random(), false);

По историческим причинам такой способ предотвращения кеширования можно увидеть много где, так как старые браузеры плохо обрабатывали кеширующие заголовки. Сейчас серверные заголовки поддерживаются хорошо.
EXTENSION!@@



@@!BLOCK
99--XMLHttpRequest POST, формы и кодировка
BLOCK!@@

@@!QWESTION
Как кодируются русские буквы в urlencoded?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Двумя байтами в UTF-8
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Основной способ кодировки запросов – это urlencoded, то есть – стандартное кодирование URL.

Например, форма:
<form action="/submit" method="GET">
  <input name="name" value="Ivan">
  <input name="surname" value="Ivanov">
</form>
Здесь есть два поля: name=Ivan и surname=Ivanov.

Браузер перечисляет такие пары «имя=значение» через символ амперсанда & и, так как метод GET, итоговый запрос выглядит как /submit?name=Ivan&surname=Ivanov.

Все символы, кроме английских букв, цифр и - _ . ! ~ * ' ( ) заменяются на их цифровой код в UTF-8 со знаком %.

Например, пробел заменяется на %20, символ / на %2F, русские буквы кодируются двумя байтами в UTF-8, поэтому, к примеру, Ц заменится на %D0%A6.

Например, форма:
<form action="/submit" method="GET">
  <input name="name" value="Виктор">
  <input name="surname" value="Цой">
</form>
Будет отправлена так: /submit?name=%D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80&surname=%D0%A6%D0%BE%D0%B9.

в JavaScript есть функция encodeURIComponent для получения такой кодировки «вручную»:

 alert( encodeURIComponent(' ') ); // %20
alert( encodeURIComponent('/') ); // %2F
alert( encodeURIComponent('В') ); // %D0%92
alert( encodeURIComponent('Виктор') ); // %D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80
Эта кодировка используется в основном для метода GET, то есть для передачи параметра в строке запроса. По стандарту строка запроса не может содержать произвольные Unicode-символы, поэтому они кодируются как показано выше.

GET-запрос
Формируя XMLHttpRequest, мы должны формировать запрос «руками», кодируя поля функцией encodeURIComponent.

Например, для посылки GET-запроса с параметрами name и surname, аналогично форме выше, их необходимо закодировать так:

// Передаём name и surname в параметрах запроса

var xhr = new XMLHttpRequest();

var params = 'name=' + encodeURIComponent(name) +
  '&surname=' + encodeURIComponent(surname);

xhr.open("GET", '/submit?' + params, true);

xhr.onreadystatechange = ...;

xhr.send();
Прочие заголовки
Браузер автоматически добавит к запросу важнейшие HTTP-заголовки, такие как Content-Length и Connection.

По спецификации браузер запрещает их явную установку, как и некоторых других низкоуровневых HTTP-заголовков, которые могли бы ввести в заблуждение сервер относительно того, кто и сколько данных ему прислал, например Referer. Это сделано в целях контроля правильности запроса и для безопасности.

Сообщаем про AJAX
Запрос, отправленный кодом выше через XMLHttpRequest, никак не отличается от обычной отправки формы. Сервер не в состоянии их отличить.

Поэтому в некоторых фреймворках, чтобы сказать серверу, что это AJAX, добавляют специальный заголовок, например такой:

xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
POST с urlencoded
В методе POST параметры передаются не в URL, а в теле запроса. Оно указывается в вызове send(body).

В стандартных HTTP-формах для метода POST доступны три кодировки, задаваемые через атрибут enctype:

application/x-www-form-urlencoded
multipart/form-data
text-plain
В зависимости от enctype браузер кодирует данные соответствующим способом перед отправкой на сервер.

В случае с XMLHttpRequest мы, вообще говоря, не обязаны использовать ни один из этих способов. Главное, чтобы сервер наш запрос понял. Но обычно проще всего выбрать какой-то из стандартных.

В частности, при POST обязателен заголовок Content-Type, содержащий кодировку. Это указание для сервера – как обрабатывать (раскодировать) пришедший запрос.

Для примера отправим запрос в кодировке application/x-www-form-urlencoded:

var xhr = new XMLHttpRequest();

var body = 'name=' + encodeURIComponent(name) +
  '&surname=' + encodeURIComponent(surname);

xhr.open("POST", '/submit', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

xhr.onreadystatechange = ...;

xhr.send(body);
Только UTF-8
Всегда используется только кодировка UTF-8, независимо от языка и кодировки страницы.

Если сервер вдруг ожидает данные в другой кодировке, к примеру windows-1251, то их нужно будет перекодировать.
EXTENSION!@@



@@!BLOCK
XMLHttpRequest POST, формы и кодировка
BLOCK!@@

@@!QWESTION
Можно ли использовать заголовок Content-Type: multipart/form-data в GET-запросах?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Кодировка urlencoded за счёт замены символов на %код может сильно «раздуть» общий объём пересылаемых данных. Поэтому для пересылки файлов используется другая кодировка: multipart/form-data.

В этой кодировке поля пересылаются одно за другим, через строку-разделитель.

Чтобы использовать этот способ, нужно указать его в атрибуте enctype и метод должен быть POST:
<form action="/submit" method="POST" enctype="multipart/form-data">
  <input name="name" value="Виктор">
  <input name="surname" value="Цой">
</form>
Форма при такой кодировке будет выглядеть примерно так:
...Заголовки...
Content-Type: multipart/form-data; boundary=RaNdOmDeLiMiTeR

--RaNdOmDeLiMiTeR
Content-Disposition: form-data; name="name"

Виктор
--RaNdOmDeLiMiTeR
Content-Disposition: form-data; name="surname"

Цой
--RaNdOmDeLiMiTeR--
…То есть, поля передаются одно за другим, значения не кодируются, а чтобы было чётко понятно, какое значение где – поля разделены случайно сгенерированной строкой, которую называют «boundary» (англ. граница), в примере выше это RaNdOmDeLiMiTeR:

Сервер видит заголовок Content-Type: multipart/form-data, читает из него границу и раскодирует поля формы.

Такой способ используется в первую очередь при пересылке файлов, так перекодировка мегабайтов через urlencoded существенно загрузила бы браузер. Да и объём данных после неё сильно вырос бы.

Однако, никто не мешает использовать эту кодировку всегда для POST запросов. Для GET доступна только urlencoded.

POST с multipart/form-data
Сделать POST-запрос в кодировке multipart/form-data можно и через XMLHttpRequest.

Достаточно указать в заголовке Content-Type кодировку и границу, и далее сформировать тело запроса, удовлетворяющее требованиям кодировки.

Пример кода для того же запроса, что и раньше, теперь в кодировке multipart/form-data:

var data = {
  name: 'Виктор',
  surname: 'Цой'
};

var boundary = String(Math.random()).slice(2);
var boundaryMiddle = '--' + boundary + '\r\n';
var boundaryLast = '--' + boundary + '--\r\n'

var body = ['\r\n'];
for (var key in data) {
  // добавление поля
  body.push('Content-Disposition: form-data; name="' + key + '"\r\n\r\n' + data[key] + '\r\n');
}

body = body.join(boundaryMiddle) + boundaryLast;

// Тело запроса готово, отправляем

var xhr = new XMLHttpRequest();
xhr.open('POST', '/submit', true);

xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);

xhr.onreadystatechange = function() {
  if (this.readyState != 4) return;

  alert( this.responseText );
}

xhr.send(body);
Тело запроса будет иметь вид, описанный выше, то есть поля через разделитель.

Отправка файла
Можно создать запрос, который сервер воспримет как загрузку файла.

Для добавления файла нужно использовать тот же код, что выше, модифицировав заголовки перед полем, которое является файлом, так:

Content-Disposition: form-data; name="myfile"; filename="pic.jpg"
Content-Type: image/jpeg
(пустая строка)
содержимое файла
EXTENSION!@@



@@!BLOCK
XMLHttpRequest POST, формы и кодировка
BLOCK!@@

@@!QWESTION
Какую кодировку использует FormData по умолчанию?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
multipart/form-data
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Современные браузеры, исключая IE9- (впрочем, есть полифилл), поддерживают встроенный объект FormData, который кодирует формы для отправки на сервер.

Это очень удобно. Например:
<form name="person">
  <input name="name" value="Виктор">
  <input name="surname" value="Цой">
</form>

<script>
  // создать объект для формы
  var formData = new FormData(document.forms.person);

  // добавить к пересылке ещё пару ключ - значение
  formData.append("patronym", "Робертович");

  // отослать
  var xhr = new XMLHttpRequest();
  xhr.open("POST", "/url");
  xhr.send(formData);
</script>
Этот код отправит на сервер форму с полями name, surname и patronym.

Интерфейс:

Конструктор new FormData([form]) вызывается либо без аргументов, либо с DOM-элементом формы.
Метод formData.append(name, value) добавляет данные к форме.
Объект formData можно сразу отсылать, интеграция FormData с XMLHttpRequest встроена в браузер. Кодировка при этом будет multipart/form-data.

Другие кодировки
XMLHttpRequest сам по себе не ограничивает кодировку и формат пересылаемых данных.

Поэтому для обмена данными часто используется формат JSON:
var xhr = new XMLHttpRequest();

var json = JSON.stringify({
  name: "Виктор",
  surname: "Цой"
});

xhr.open("POST", '/submit', true)
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.onreadystatechange = ...;

// Отсылаем объект в формате JSON и с Content-Type application/json
// Сервер должен уметь такой Content-Type принимать и раскодировать
xhr.send(json);
EXTENSION!@@



@@!BLOCK
100--XMLHttpRequest: кросс-доменные запросы
BLOCK!@@

@@!QWESTION
Это простой запрос?
xhr.open('COPY', 'http://site.com/~ilya', true);
xhr.setRequestHeader('Destination', 'http://site.com/~ilya.bak');
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Запросы в ней делятся на два вида.

Простыми считаются запросы, если они удовлетворяют следующим двум условиям:

Простой метод: GET, POST или HEAD
Простые заголовки – только из списка:
Accept
Accept-Language
Content-Language
Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.
«Непростыми» считаются все остальные, например, запрос с методом PUT или с заголовком Authorization не подходит под ограничения выше.

Принципиальная разница между ними заключается в том, что «простой» запрос можно сформировать и отправить на сервер и без XMLHttpRequest, например при помощи HTML-формы.

То есть, злой хакер на странице http://evilhacker.com и до появления CORS мог отправить произвольный GET-запрос куда угодно. Например, если создать и добавить в документ элемент <script src="любой url">, то браузер сделает GET-запрос на этот URL.

Аналогично, злой хакер и ранее мог на своей странице объявить и, при помощи JavaScript, отправить HTML-форму с методом GET/POST и кодировкой multipart/form-data. А значит, даже старый сервер наверняка предусматривает возможность таких атак и умеет от них защищаться.

А вот запросы с нестандартными заголовками или с методом DELETE таким образом не создать. Поэтому старый сервер может быть к ним не готов. Или, к примеру, он может полагать, что такие запросы веб-страница в принципе не умеет присылать, значит они пришли из привилегированного приложения, и дать им слишком много прав.

Поэтому при посылке «непростых» запросов нужно специальным образом спросить у сервера, согласен ли он в принципе на подобные кросс-доменные запросы или нет? И, если сервер не ответит, что согласен – значит, нет.

В спецификации CORS, как мы увидим далее, есть много деталей, но все они объединены единым принципом: новые возможности доступны только с явного согласия сервера (по умолчанию – нет).
EXTENSION!@@



@@!BLOCK
XMLHttpRequest: кросс-доменные запросы
BLOCK!@@

@@!QWESTION
Какой заголовок браузер автоматически добавляет в кросс-доменный запрос?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Origin
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В кросс-доменный запрос браузер автоматически добавляет заголовок Origin, содержащий домен, с которого осуществлён запрос.

В случае запроса на http://anywhere.com/request с http://javascript.ru/page заголовки будут примерно такие:
GET /request
Host:anywhere.com
Origin:http://javascript.ru
...
Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе.

Если сервер разрешает кросс-доменный запрос с этого домена – он должен добавить к ответу заголовок Access-Control-Allow-Origin, содержащий домен запроса (в данном случае «javascript.ru») или звёздочку *.

Только при наличии такого заголовка в ответе – браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку.

То есть, ответ сервера может быть примерно таким:
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: http://javascript.ru
Если Access-Control-Allow-Origin нет, то браузер считает, что разрешение не получено, и завершает запрос с ошибкой.

При таких запросах не передаются куки и заголовки HTTP-авторизации. Параметры user и password в методе open игнорируются. Мы рассмотрим, как разрешить их передачу, чуть далее.

Что может сделать хакер, используя такие запросы?
Описанные выше ограничения приводят к тому, что запрос полностью безопасен.

Действительно, злая страница может сформировать любой GET/POST-запрос и отправить его, но без разрешения сервера ответа она не получит.

А без ответа такой запрос, по сути, эквивалентен отправке формы GET/POST, причём без авторизации.

Ограничения IE9-
В IE9- используется XDomainRequest, который представляет собой урезанный XMLHttpRequest.

На него действуют ограничения:

Протокол нужно сохранять: запросы допустимы с HTTP на HTTP, с HTTPS на HTTPS. Другие протоколы запрещены.
Метод open(method, url) имеет только два параметра. Он всегда асинхронный.
Ряд возможностей современного стандарта недоступны, в частности:
Недоступны методы, кроме GET или POST.
Нельзя добавлять свои заголовки, даже нельзя указать свой Content-Type для запроса, он всегда text/plain.
Нельзя включить передачу кук и данных HTTP-авторизации.
В IE8 в режиме просмотра InPrivate кросс-доменные запросы не работают.
Современный стандарт XMLHttpRequest предусматривает средства для преодоления этих ограничений, но на момент выхода IE8 они ещё не были проработаны, поэтому их не реализовали. А IE9 исправил некоторые ошибки, но в общем не добавил ничего нового.

Поэтому на сайтах, которые хотят поддерживать IE9-, то на практике кросс-доменные запросы редко используют, предпочитая другие способы кросс-доменной коммуникации. Например, динамически создаваемый тег SCRIPT или вспомогательный IFRAME с другого домена. Мы разберём эти подходы в последующих главах.

Как разрешить кросс-доменные запросы от доверенного сайта в IE9-?
Разрешить кросс-доменные запросы для «доверенных» сайтов можно в настройках IE, во вкладке «Безопасность», включив пункт «Доступ к источникам данных за пределами домена».

Обычно это делается для зоны «Надёжные узлы», после чего в неё вносится доверенный сайт. Теперь он может делать кросс-доменные запросы XMLHttpRequest.

Этот способ можно применить для корпоративных сайтов, а также в тех случаях, когда посетитель заведомо вам доверяет, но почему-то (компьютер на работе, админ запрещает ставить другой браузер?) хочет использовать именно IE. Например, он может предлагаться в качестве дополнительной инструкции «как заставить этот сервис работать под IE».

В IE разрешён другой порт
В кросс-доменные ограничения IE не включён порт.

То есть, можно сделать запрос с http://javascript.ru на http://javascript.ru:8080, и в IE он не будет считаться кросс-доменным.

Это позволяет решить некоторые задачи, связанные с взаимодействием различных сервисов в рамках одного сайта. Но только для IE.

Расширенные возможности, описанные далее, поддерживаются всеми современными браузерами, кроме IE9-.
EXTENSION!@@



@@!BLOCK
XMLHttpRequest: кросс-доменные запросы
BLOCK!@@

@@!QWESTION
В каком заголовке сервер должен указать названия нестандартных заголовков ответа, если хочет, чтобы клиент мог их прочитать?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Access-Control-Expose-Headers
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
По умолчанию скрипт может прочитать из ответа только «простые» заголовки:
Cache-Control
Content-Language
Content-Type
Expires
Last-Modified
Pragma
EXTENSION!@@



@@!BLOCK
XMLHttpRequest: кросс-доменные запросы
BLOCK!@@

@@!QWESTION
Найдите ошибку в данных заголовках:
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Использование звёздочки * в Access-Control-Allow-Origin при запросе с withCredentials запрещено. Нужно Access-Control-Allow-Origin: http://javascript.ru
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
По умолчанию браузер не передаёт с запросом куки и авторизующие заголовки.

Чтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу xhr.withCredentials = true:

var xhr = new XMLHttpRequest();
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request', true)
  ...
Далее – всё как обычно, дополнительных действий со стороны клиента не требуется.

Такой XMLHttpRequest с куками, естественно, требует от сервера больше разрешений, чем «анонимный».

Поэтому для запросов с withCredentials предусмотрено дополнительное подтверждение со стороны сервера.

При запросе с withCredentials сервер должен вернуть уже не один, а два заголовка:

Access-Control-Allow-Origin: домен
Access-Control-Allow-Credentials: true
Пример заголовков:
HTTP/1.1 200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: http://javascript.ru
Access-Control-Allow-Credentials: true
Использование звёздочки * в Access-Control-Allow-Origin при этом запрещено.

Если этих заголовков не будет, то браузер не даст JavaScript’у доступ к ответу сервера.
EXTENSION!@@



@@!BLOCK
XMLHttpRequest: кросс-доменные запросы
BLOCK!@@

@@!QWESTION
"Предзапрос" (preflight request) имеет тело?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
В кросс-доменном XMLHttpRequest можно указать не только GET/POST, но и любой другой метод, например PUT, DELETE.

Когда-то никто и не думал, что страница сможет сделать такие запросы. Поэтому ряд веб-сервисов написаны в предположении, что «если метод – нестандартный, то это не браузер». Некоторые веб-сервисы даже учитывают это при проверке прав доступа.

Чтобы пресечь любые недопонимания, браузер использует предзапрос в случаях, когда:

Если метод – не GET / POST / HEAD.
Если заголовок Content-Type имеет значение отличное от application/x-www-form-urlencoded, multipart/form-data или text/plain, например application/xml.
Если устанавливаются другие HTTP-заголовки, кроме Accept, Accept-Language, Content-Language.
…Любое из условий выше ведёт к тому, что браузер сделает два HTTP-запроса.

Первый запрос называется «предзапрос» (английский термин «preflight»). Браузер делает его целиком по своей инициативе, из JavaScript мы о нём ничего не знаем, хотя можем увидеть в инструментах разработчика.

Этот запрос использует метод OPTIONS. Он не содержит тела и содержит название желаемого метода в заголовке Access-Control-Request-Method, а если добавлены особые заголовки, то и их тоже – в Access-Control-Request-Headers.

Его задача – спросить сервер, разрешает ли он использовать выбранный метод и заголовки.

На этот запрос сервер должен ответить статусом 200, без тела ответа, указав заголовки Access-Control-Allow-Method: метод и, при необходимости, Access-Control-Allow-Headers: разрешённые заголовки.
Если разрешены многие методы и заголовки, имеет смысл сразу перечислить их в ответе:
Access-Control-Allow-Methods: PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK, PUT, GETLIB, VERSION-CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, REPORT, UPDATE, CANCELUPLOAD, HEAD, OPTIONS, GET, POST
Access-Control-Allow-Headers: Overwrite, Destination, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, If-Modified-Since, X-File-Name, Cache-Control
Access-Control-Max-Age: 86400

Дополнительно он может указать Access-Control-Max-Age: sec, где sec – количество секунд, на которые нужно закэшировать разрешение. Тогда при последующих вызовах метода браузер уже не будет делать предзапрос.
EXTENSION!@@



@@!BLOCK
101--XMLHttpRequest: индикация прогресса
BLOCK!@@

@@!QWESTION
Чему равен total если сервер генерирует данные динамически и не знает их конченого размера?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
total будет равно 0
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При обработке события onprogress есть ряд важных тонкостей.

Можно, конечно, их игнорировать, но лучше бы знать.

Заметим, что событие, возникающее при onprogress, имеет одинаковый вид на стадии закачки (в обработчике xhr.upload.onprogress) и при получении ответа (в обработчике xhr.onprogress).

Оно представляет собой объект типа ProgressEvent со свойствами:

loaded
Сколько байт уже переслано.

Имеется в виду только тело запроса, заголовки не учитываются.

lengthComputable
Если true, то известно полное количество байт для пересылки, и оно хранится в свойстве total.

total
Общее количество байт для пересылки, если известно.

А может ли оно быть неизвестно?

При закачке на сервер браузер всегда знает полный размер пересылаемых данных, так что total всегда содержит конкретное количество байт, а значение lengthComputable всегда будет true.
При скачивании данных – обычно сервер в начале сообщает их общее количество в HTTP-заголовке Content-Length. Но он может и не делать этого, например если сам не знает, сколько данных будет или если генерирует их динамически. Тогда total будет равно 0. А чтобы отличить нулевой размер данных от неизвестного – как раз служит lengthComputable, которое в данном случае равно false.
Ещё особенности, которые необходимо учитывать при использовании onprogress:

Событие происходит при каждом полученном/отправленном байте, но не чаще чем раз в 50 мс.

Это обозначено в спецификации progress notifications.

В процессе получения данных, ещё до их полной передачи, доступен xhr.responseText, но он не обязательно содержит корректную строку.

Можно до окончания запроса заглянуть в него и прочитать текущие полученные данные. Важно, что при пересылке строки в кодировке UTF-8 кириллические символы, как, впрочем, и многие другие, кодируются 2 байтами. Возможно, что в конце одного пакета данных окажется первая половинка символа, а в начале следующего – вторая. Поэтому полагаться на то, что до окончания запроса в responseText находится корректная строка нельзя. Она может быть обрезана посередине символа.

Исключение – заведомо однобайтные символы, например цифры или латиница.

Сработавшее событие xhr.upload.onprogress не гарантирует, что данные дошли.

Событие xhr.upload.onprogress срабатывает, когда данные отправлены браузером. Но оно не гарантирует, что сервер получил, обработал и записал данные на диск. Он говорит лишь о самом факте отправки.

Поэтому прогресс-индикатор, получаемый при его помощи, носит приблизительный и оптимистичный характер.
EXTENSION!@@



@@!BLOCK
XMLHttpRequest: индикация прогресса
BLOCK!@@

@@!QWESTION
На какой фазе применяется событие xhr.onprogress?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
На стадии скачивания
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Запрос XMLHttpRequest состоит из двух фаз:

Стадия закачки (upload). На ней данные загружаются на сервер. Эта фаза может быть долгой для POST-запросов. Для отслеживания прогресса на стадии закачки существует объект типа XMLHttpRequestUpload, доступный как xhr.upload и события на нём.
Стадия скачивания (download). После того, как данные загружены, браузер скачивает ответ с сервера. Если он большой, то это может занять существенное время. На этой стадии используется обработчик xhr.onprogress.
Далее – обо всём по порядку.

Стадия закачки
На стадии закачки для получения информации используем объект xhr.upload. У этого объекта нет методов, он только генерирует события в процессе закачки. А они-то как раз и нужны.

Вот полный список событий:

loadstart
progress
abort
error
load
timeout
loadend
Пример установки обработчиков на стадию закачки:

xhr.upload.onprogress = function(event) {
  alert( 'Загружено на сервер ' + event.loaded + ' байт из ' + event.total );
}

xhr.upload.onload = function() {
  alert( 'Данные полностью загружены на сервер!' );
}

xhr.upload.onerror = function() {
  alert( 'Произошла ошибка при загрузке данных на сервер!' );
}
Стадия скачивания
После того, как загрузка завершена, и сервер соизволит ответить на запрос, XMLHttpRequest начнёт скачивание ответа сервера.

На этой фазе xhr.upload уже не нужен, а в дело вступают обработчики событий на самом объекте xhr. В частности, событие xhr.onprogress содержит информацию о количестве принятых байт ответа.

Пример обработчика:

xhr.onprogress = function(event) {
  alert( 'Получено с сервера ' + event.loaded + ' байт из ' + event.total );
}
Все события, возникающие в этих обработчиках, имеют тип ProgressEvent, то есть имеют свойства loaded – количество уже пересланных данных в байтах и total – общее количество данных.
EXTENSION!@@



@@!BLOCK
102--Протокол JSONP
BLOCK!@@

@@!QWESTION
Как модифицировать src, чтобы воспользоваться протоколом JSONP?
addScript('user?id=123');
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Передать в заранее оговоренном параметре название функции, в вызов которой сервер передаст данные. Например "&callback=onUserData"
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Если создать тег <script src>, то при добавлении в документ запустится процесс загрузки src. В ответ сервер может прислать скрипт, содержащий нужные данные.
Таким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок.
Протокол JSONP – это «надстройка» над таким способом коммуникации. Здесь мы рассмотрим его использование в деталях.

Обработка ответа, JSONP
В примере выше рассмотрено создание запроса, но как получить ответ? Допустим, сервер хочет прислать объект с данными.

Конечно, он может присвоить её в переменную, например так:

// ответ сервера
var user = {name: "Вася", age: 25 };
…А браузер по script.onload отловит окончание загрузки и прочитает значение user.

Но что, если одновременно делается несколько запросов? Получается, нужно присваивать в разные переменные.

Протокол JSONP как раз и призван облегчить эту задачу.

Он очень простой:

Вместе с запросом клиент в специальном, заранее оговорённом, параметре передаёт название функции.

Обычно такой параметр называется callback. Например :
addScript('user?id=123&callback=onUserData');
Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра callback:

// ответ сервера
onUserData({
  name: "Вася",
  age: 25
});
Это и называется JSONP («JSON with Padding»).

Аспект безопасности
Клиентский код должен доверять серверу при таком запросе. Ведь серверу ничего не стоит добавить в скрипт любые команды.

Реестр CallbackRegistry
В примере выше функция onUserData должна быть глобальной, ведь <script src> выполняется в глобальной области видимости.

Хотелось бы не загрязнять глобальное пространство имён, или по крайней мере свести загрязнение к минимуму.

Как правило, для этого создают один глобальный объект «реестр», который мы назовём CallbackRegistry. Далее для каждого запроса в нём генерируется временная функция.

Тег будет выглядеть так:
<script src="user?id=123&callback=CallbackRegistry.func12345"></script>
Сервер обернёт ответ в функцию CallbackRegistry.func12345, она вызывает нужный обработчик и очищает память, удаляя себя.

Далее мы посмотрим более полный код всего этого, но перед этим – важный момент! Нужно предусмотреть обработку ошибок.

Обнаружение ошибок
При запросе данных при помощи SCRIPT возможны различные ошибки:

Скрипт может не загрузиться: отказ в соединении, разрыв связи…
Ошибка HTTP, например 500.
Скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан её текст, а вовсе не данные.
Чтобы отловить их все «одним махом», используем следующий алгоритм:

Создаётся <script>.
На <script> ставятся обработчики onreadystatechange (для старых IE) и onload/onerror (для остальных браузеров).
При загрузке скрипт выполняет функцию-коллбэк CallbackRegistry.... Пусть она при запуске ставит флажок «все ок». А мы в обработчиках проверим – если флага нет, то функция не вызывалась – стало быть, ошибка при загрузке или содержимое скрипта некорректно.
Полный пример
Итак, код функции, которая вызывается с url и коллбэками.

Он совсем небольшой, а без комментариев был бы ещё меньше:

var CallbackRegistry = {}; // реестр

// при успехе вызовет onSuccess, при ошибке onError
function scriptRequest(url, onSuccess, onError) {

  var scriptOk = false; // флаг, что вызов прошел успешно

  // сгенерировать имя JSONP-функции для запроса
  var callbackName = 'cb' + String(Math.random()).slice(-6);

  // укажем это имя в URL запроса
  url += ~url.indexOf('?') ? '&' : '?';
  url += 'callback=CallbackRegistry.' + callbackName;

  // ..и создадим саму функцию в реестре
  CallbackRegistry[callbackName] = function(data) {
    scriptOk = true; // обработчик вызвался, указать что всё ок
    delete CallbackRegistry[callbackName]; // можно очистить реестр
    onSuccess(data); // и вызвать onSuccess
  };

  // эта функция сработает при любом результате запроса
  // важно: при успешном результате - всегда после JSONP-обработчика
  function checkCallback() {
    if (scriptOk) return; // сработал обработчик?
    delete CallbackRegistry[callbackName];
    onError(url); // нет - вызвать onError
  }

  var script = document.createElement('script');

  // в старых IE поддерживается только событие, а не onload/onerror
  // в теории 'readyState=loaded' означает "скрипт загрузился",
  // а 'readyState=complete' -- "скрипт выполнился", но иногда
  // почему-то случается только одно из них, поэтому проверяем оба
  script.onreadystatechange = function() {
    if (this.readyState == 'complete' || this.readyState == 'loaded') {
      this.onreadystatechange = null;
      setTimeout(checkCallback, 0); // Вызвать checkCallback - после скрипта
    }
  }

  // события script.onload/onerror срабатывают всегда после выполнения скрипта
  script.onload = script.onerror = checkCallback;
  script.src = url;

  document.body.appendChild(script);
}
Пример использования:

function ok(data) {
  alert( "Загружен пользователь " + data.name );
}

function fail(url) {
  alert( 'Ошибка при запросе ' + url );
}

// Внимание! Ответы могут приходить в любой последовательности!
scriptRequest("user?id=123", ok, fail); // Загружен
scriptRequest("/badurl.js", ok, fail); // fail, 404
scriptRequest("/", ok, fail); // fail, 200 но некорректный скрипт
EXTENSION!@@



@@!BLOCK
103--Server Side Events -- события с сервера
BLOCK!@@

@@!QWESTION
Каким заголовком должен ответить сервер, чтобы соединение успешно открылось?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Content-Type: text/event-stream
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Современный стандарт Server-Sent Events позволяет браузеру создавать специальный объект EventSource, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.

Он, по дизайну, может меньше, чем WebSocket’ы.

С другой стороны, Server Side Events проще в реализации, работают по обычному протоколу HTTP и сразу поддерживают ряд возможностей, которые для WebSocket ещё надо реализовать.

Поэтому в тех случаях, когда нужна преимущественно односторонняя передача данных от сервера к браузеру, они могут быть удачным выбором.

Получение сообщений
При создании объекта new EventSource(src) браузер автоматически подключается к адресу src и начинает получать с него события:

var eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = function(e) {
  console.log("Пришло сообщение: " + e.data);
};
Чтобы соединение успешно открылось, сервер должен ответить с заголовком Content-Type: text/event-stream, а затем оставить соединение висящим и писать в него сообщения в специальном формате:

data: Сообщение 1

data: Сообщение 2

data: Сообщение 3
data: из двух строк
Каждое сообщение пишется после data:. Если после двоеточия есть пробел, то он игнорируется.

Сообщения разделяются двумя строками \n\n.

Если нужно переслать перевод строки, то сообщение разделяется. Каждая следующая строка пересылается отдельным data:.

В частности, две последние строки в примере выше составляют одно сообщение: "Сообщение 3\nиз двух строк".

Здесь все очень просто и удобно, кроме разделения сообщения при переводе строки. Но, если подумать – это не так уж страшно: на практике сложные сообщения обычно передаются в формате JSON. А перевод строки в нём кодируется как \n.

Соответственно, многострочные данные будут пересылаться так:

data: {"user":"Вася","message":"Сообщение 3\n из двух строк"}
…То есть, строка data: будет одна, и никаких проблем с разделением сообщения нет.
EXTENSION!@@



@@!BLOCK
Server Side Events -- события с сервера
BLOCK!@@

@@!QWESTION
Как серверу полностью закрыть соединение?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
- Ответить со статусом не 200
- Ответить с Content-Type, не совпадающим с text/event-stream.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
При создании объекта браузер автоматически подключается к серверу, а при обрыве – пытается его возобновить.

Это очень удобно, никакой другой транспорт не обладает такой встроенной способностью.

Как серверу полностью закрыть соединение?
При любом закрытии соединения, в том числе если сервер ответит на запрос и закроет соединение сам – браузер через короткое время повторит свой запрос.

Есть лишь два способа, которыми сервер может «отшить» надоедливый EventSource:

Ответить со статусом не 200.
Ответить с Content-Type, не совпадающим с text/event-stream.
Между попытками возобновить соединение будет пауза, начальное значение которой зависит от браузера (1-3 секунды) и может быть изменено сервером через указание retry: в ответе:

retry: 15000
data: Поставлена задержка 15 секунд
Браузер, со своей стороны, может закрыть соединение вызовом close():

var eventSource = new EventSource(...);

eventSource.close();
При этом дальнейших попыток соединения не будет. Открыть обратно этот объект тоже нельзя, можно создать новый EventSource.
EXTENSION!@@



@@!BLOCK
Server Side Events -- события с сервера
BLOCK!@@

@@!QWESTION
Как продолжить получение событий с места разрыва?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
С помощью идентификатора событий id
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Для того, чтобы продолжить получение событий с места разрыва, стандарт предусматривает идентификацию событий через id.

Сервер может указать его в ответе:

data: Сообщение 1
id: 1

data: Сообщение 2
id: 2

data: Сообщение 3
data: из двух строк
id: 3
При получении id: браузер:

Устанавливает свойство eventSource.lastEventId в его значение.
При пересоединении пошлёт заголовок Last-Event-ID с этим id, так что сервер сможет переслать последующие, пропущенные, сообщения.
Обратим внимание: id шлётся не перед сообщением, а после него, чтобы обновление lastEventId произошло, когда браузер всё уже точно получил.
EXTENSION!@@



@@!BLOCK
Server Side Events -- события с сервера
BLOCK!@@

@@!QWESTION
В каком состоянии находится соединение про EventSource.readyState = 1?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Соединение установлено
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Статус соединения readyState
У объекта EventSource есть свойство readyState, которое содержит одно из значений (выдержка из стандарта):

const unsigned short CONNECTING = 0; // в процессе (пере-)соединения
const unsigned short OPEN = 1;       // соединение установлено
const unsigned short CLOSED = 2;     // соединение закрыто
При создании объекта и при разрыве оно автоматически равно CONNECTING.

События
Событий всего три:

onmessage – пришло сообщение, доступно как event.data
onopen – при успешном установлении соединения
onerror – при ошибке соединения.
Например:

var eventSource = new EventSource('digits');

eventSource.onopen = function(e) {
  console.log("Соединение открыто");
};

eventSource.onerror = function(e) {
  if (this.readyState == EventSource.CONNECTING) {
    console.log("Соединение порвалось, пересоединяемся...");
  } else {
    console.log("Ошибка, состояние: " + this.readyState);
  }
};

eventSource.onmessage = function(e) {
  console.log("Пришли данные: " + e.data);
};
Своё имя события: event
По умолчанию на события срабатывает обработчик onmessage, но можно сделать и свои события. Для этого сервер должен указать перед событием его имя после event:.

Например:

event: join
data: Вася

data: Привет

event: leave
data: Вася
Сообщение по умолчанию имеет имя message.

Для обработки своих имён событий необходимо ставить обработчик при помощи addEventListener.

Пример кода для обработки:

eventSource.addEventListener('join', function(e) {
  alert( 'Пришёл ' + e.data );
});

eventSource.addEventListener('message', function(e) {
  alert( 'Сообщение ' + e.data );
});

eventSource.addEventListener('leave', function(e) {
  alert( 'Ушёл ' + e.data );
});
EXTENSION!@@



@@!BLOCK
Server Side Events -- события с сервера
BLOCK!@@

@@!QWESTION
Как обеспечить кросс-доменность в EventSource?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Передать второым аргументов объект сединственным свойством withCredentials: true
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EventSource поддерживает кросс-доменные запросы, аналогично XMLHttpRequest. Для этого у конструктора есть второй аргумент – объект, который нужно передать так:

var source = new EventSource("http://pupkin.ru/stream", {
  withCredentials: true
});
Второй аргумент сделан объектом с расчётом на будущее. Пока что никаких других свойств там не поддерживается, только withCredentials.

Сервер при этом получит заголовок Origin с доменом запроса и должен ответить с заголовком Access-Control-Allow-Origin (и Access-Control-Allow-Credentials, если стоит withCredentials), в точности как в главе XMLHttpRequest: кросс-доменные запросы.

При кросс-доменных запросах у событий event также появится дополнительное свойство origin, содержащее адрес источника, откуда пришли данные. Его можно использовать для дополнительной проверки со стороны браузера:

eventSource.addEventListener('message', function(e) {
  if (e.origin != 'http://javascript.ru') return;
  alert( 'Сообщение ' + e.data );
});
Итого
Объект EventSource предназначен для передачи текстовых сообщений с сервера, используя обычный протокол HTTP.

Он предлагает не только передачу сообщений, но и встроенную поддержку важных вспомогательных функций:

События event.
Автоматическое пересоединение, с настраиваемой задержкой retry.
Проверка текущего состояния подключения по readyState.
Идентификаторы сообщений id для точного возобновления потока данных, последний полученный идентификатор передаётся в заголовке Last-Event-ID.
Кросс-доменность CORS.
Этот набор функций делает EventSource достойной альтернативой WebSocket, которые хоть и потенциально мощнее, но требуют реализации всех этих функций на клиенте и сервере, поверх протокола.

Поддержка – все браузеры, кроме IE.

Синтаксис:

var source = new EventSource(src[, credentials]); // src - адрес с любого домена
Второй необязательный аргумент, если указан в виде { withCredentials: true }, инициирует отправку Cookie и данных авторизации при кросс-доменных запросах.

Безопасность при кросс-доменных запросах обеспечивается аналогично XMLHttpRequest.

Свойства объекта:

readyState
Текущее состояние соединения, одно из EventSource.CONNECTING (=0), EventSource.OPEN (=1) или EventSource.CLOSED (=2).
lastEventId
Последнее полученное id, если есть. При возобновлении соединения браузер указывает это значение в заголовке Last-Event-ID.
url, withCredentials
Параметры, переданные при создании объекта. Менять их нельзя.
Методы:

close()
Закрывает соединение.
События:

onmessage
При сообщении, данные – в event.data.
onopen
При установлении соединения.
onerror
При ошибке, в том числе – закрытии соединения по инициативе сервера.
Эти события можно ставить напрямую через свойство: source.onmessage = ....

Если сервер присылает имя события в event:, то такие события нужно обрабатывать через addEventListener.

Формат ответа сервера:

Сервер присылает пустые строки, либо строки, начинающиеся с:

data: – сообщение, несколько таких строк подряд склеиваются и образуют одно сообщение.
id: – обновляет lastEventId.
retry: – указывает паузу между пересоединениями, в миллисекундах. JavaScript не может указать это значение, только сервер.
event: – имя события, должен быть перед data:.
EXTENSION!@@



@@!BLOCK
104--Атака CSRF
BLOCK!@@

@@!QWESTION
Что такое CSRF?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
CSRF-атака – это когда «злая страница» отправляет форму или запрос на сервер сайта, где посетитель, предположительно, залогинен.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
EXTENSION!@@



@@!BLOCK
Метод fetch: замена XMLHttpRequest
BLOCK!@@

@@!QWESTION
Что возвращает метод fetch?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Промис
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синтаксис метода fetch:

let promise = fetch(url[, options]);
url – URL, на который сделать запрос,
options – необязательный объект с настройками запроса.
Свойства options:

method – метод запроса,
headers – заголовки запроса (объект),
body – тело запроса: FormData, Blob, строка и т.п.
mode – одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос.
credentials – одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом.
cache – одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос.
redirect – можно поставить «follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации редиректа как ошибки.
Как видно, всевозможных настроек здесь больше, чем в XMLHttpRequest. Вместе с тем, надо понимать, что если мы используем полифилл, то ничего более гибкого, чем оригинальный XMLHttpRequest мы из этого не получим.

Разве что, fetch, возможно, будет удобнее пользоваться.

Использование
При вызове fetch возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался.
EXTENSION!@@



@@!BLOCK
105--Открытие окон и методы window
BLOCK!@@

@@!QWESTION
Как "заставить" браузер открыть новое окно, а не вкладку
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Задать размеры и позицию окна
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION

В этой статье мы рассмотрим открытие окон и ряд тонких моментов, которые с этим связаны.
Простейший пример:
window.open("http://ya.ru");
Большинство браузеров по умолчанию создают новую вкладку вместо отдельного окна, но чуть далее мы увидим, что можно и «заказать» именно окно.
Если координаты и размеры не указаны, то обычно браузер открывает не окно, а новую вкладку.
Полный синтаксис:

win = window.open(url, name, params)
Функция возвращает ссылку на объект window нового окна, либо null, если окно было заблокировано браузером.

Параметры:

url
URL для загрузки в новое окно.
name
Имя нового окна. Может быть использовано в параметре target в формах. Если позднее вызвать window.open() с тем же именем, то браузеры (кроме IE) заменяют существующее окно на новое.
params
Строка с конфигурацией для нового окна. Состоит из параметров, перечисленных через запятую. Пробелов в ней быть не должно.
Значения параметров params.

Настройки расположения окна:
left/top (число)
Координаты верхнего левого угла относительно экрана. Ограничение: новое окно не может быть позиционированно за пределами экрана.

width/height (число)
Ширина/высота нового окна. Минимальные значения ограничены, так что невозможно создать невидимое окно с нулевыми размерами.

Если координаты и размеры не указаны, то обычно браузер открывает не окно, а новую вкладку.

Свойства окна:
menubar (yes/no)
Скрыть или показать строку меню браузера.
toolbar (yes/no)
Показать или скрыть панель навигации браузера (кнопки назад, вперед, обновить страницу и остальные) в новом окне.
location (yes/no)
Показать/скрыть поле URL-адреса в новом окне. По умолчанию Firefox и IE не позволяют скрывать строку адреса.
status (yes/no)
Показать или скрыть строку состояния. С другой стороны, браузер может в принудительном порядке показать строку состояния.
resizable (yes/no)
Позволяет отключить возможность изменять размеры нового окна. Значение no обычно неудобно посетителям.
scrollbars (yes/no)
Разрешает убрать полосы прокрутки для нового окна. Значение no обычно неудобно посетителям.
Еще есть небольшое количество не кросс-браузерных свойств, которые обычно не используются. Вы можете узнать о них в документации, например MDN: window.open.
Важно:
Браузер подходит к этим параметрам интеллектуально. Он может проигнорировать их часть или даже все, они скорее являются «пожеланиями», нежели «требованиями».

Важные моменты:

Если при вызове open указан только первый параметр, параметр отсутствует, то используются параметры по умолчанию. Обычно при этом будет открыто не окно, а вкладка, что зачастую более удобно.
Если указана строка с параметрами, но некоторые yes/no параметры отсутствуют, то браузер выставляет их в no. Поэтому убедитесь, что все нужные вам параметры выставлены в yes.
Когда не указан top/left, то браузер откроет окно с небольшим смещением относительно левого верхнего угла последнего открытого окна.
Если не указаны width/height, новое окно будет такого же размера, как последнее открытое.
EXTENSION!@@



@@!BLOCK
Открытие окон и методы window
BLOCK!@@

@@!QWESTION
Как из дочернего окна обратиться к родительскому?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Вызов window.open возвращает ссылку на новое окно. Она может быть использована для манипуляции свойствами окна, изменения URL, доступа к его переменным и т.п.

В примере ниже мы заполняем новое окно содержимым целиком из JavaScript:

 var newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write("Привет, мир!");
А здесь модифицируем содержимое после загрузки:
var newWin = window.open('/', 'example', 'width=600,height=400');
alert(newWin.location.href); // (*) about:blank, загрузка ещё не началась
newWin.onload = function() {
  // создать div в документе нового окна
  var div = newWin.document.createElement('div'),
      body = newWin.document.body;
  div.innerHTML = 'Добро пожаловать!'
  div.style.fontSize = '30px'

  // вставить первым элементом в body нового окна
  body.insertBefore(div, body.firstChild);
}
Обратим внимание: сразу после window.open новое окно ещё не загружено. Это демонстрирует alert в строке (*). Поэтому в примере выше окно модифицируется при onload. Можно было и поставить обработчик на DOMContentLoaded для newWin.document.

Связь между окнами – двухсторонняя.

Родительское окно получает ссылку на новое через window.open, а дочернее – ссылку на родителя window.opener.

Оно тоже может его модифицировать.

Если запустить пример ниже, то новое окно заменит содержимое текущего на 'Test':
var newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write(
  "<script>window.opener.document.body.innerHTML = 'Test'</scr" + "ipt>"
);
Same Origin Policy – защита проверкой протокол-сайт-порт
Большинство действий, особенно получение содержимого окна и его переменных, возможны лишь в том случае, если URL нового окна происходит из того же источника (англ. – «Same Origin»), т.е. совпадают домен, протокол и порт.

Иначе говоря, если новое окно содержит документ с того же сайта.

Больше информации об этом будет позже, в главе Кросс-доменные ограничения и их обход.

События
Наиболее важные события при работе с окном браузера:

onresize – событие изменения размера окна.
onscroll – событие при прокрутке окна.
onload – полностью загрузилась страница со всеми ресурсами.
onfocus/onblur – получение/потеря фокуса.
Методы и свойства
window.closed
Свойство window.closed равно true, если окно закрыто. Может быть использовано, чтобы проверить, закрыл ли посетитель попап.
window.close()
Закрывает попап без предупреждений и уведомлений. Вообще, метод close() можно вызвать для любого окна, в том числе, текущего. Но если окно открыто не с помощью window.open(), то браузер может проигнорировать вызов close или запросить подтверждение.
Перемещение и изменение размеров окна
Существует несколько методов для перемещения/изменения размеров окна.

win.moveBy(x,y)
Перемещает окно относительно текущего положения на x пикселей вправо и y пикселей вниз. Допускаются отрицательные значения.
win.moveTo(x,y)
Передвигает окно в заданную координатами x и y точку экрана монитора.
win.resizeBy(width,height)
Изменяет размер окна на заданную величину width/height (ширина/высота). Допускаются отрицательные значения.
win.resizeTo(width,height)
Изменяет размер окна на заданное значение.
Важно:
Чтобы предотвратить использование этих методов с плохими целями, браузеры часто блокируют их выполнение. Как правило, они работают, если окно win открыто вызовом window.open из JavaScript текущей страницы и в нём нет дополнительных вкладок.

Ни свернуть ни развернуть
Заметим, что JavaScript не может ни свернуть ни развернуть ни «максимизировать» (Windows) окно.

Эти функции операционной системы от Frontend-разработчиков скрыты. Вызовы, описанные выше, в случае свёрнутого или максимизированного окна не работают.
EXTENSION!@@



@@!BLOCK
106--Общение между окнами и фреймами
BLOCK!@@

@@!QWESTION
Как обратиться к body внутри iframe?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
iframe.contentWindow.document.body
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Элемент iframe является обычным узлом DOM, как и любой другой. Существенное отличие – в том, что с ним связан объект window внутреннего окна. Он доступен по ссылке iframe.contentWindow.
Таким образом, iframe.contentWindow.document будет внутренним документом, iframe.contentWindow.document.body – его <body> и так далее.

В примере ниже JavaScript получает документ внутри ифрейма и модифицирует его:

 <iframe src="javascript:'тест'" style="height:60px"></iframe>

<script>
  var iframe = document.getElementsByTagName('iframe')[0];

  var iframeDoc = iframe.contentWindow.document;

  if (iframeDoc.readyState == 'complete') {
    iframeDoc.body.style.backgroundColor = 'green';
  }
  iframe.onload = function() {
    var iframeDoc2 = iframe.contentWindow.document;
    iframeDoc2.body.style.backgroundColor = 'orange';
  }
</script>

src=„javascript:«текст»“
Атрибут src может использовать протокол javascript, как указано выше: src="javascript:код". При этом код выполняется и его результат будет содержимым ифрейма. Этот способ описан в стандарте и поддерживается всеми браузерами.

Атрибут src является обязательным, и его отсутствие может привести к проблемам, вплоть до игнорирования ифрейма браузером. Чтобы ничего не загружать в ифрейм, можно указать пустую строку: src="javascript:''" или специальную страницу: src="about:blank".

В некоторых браузерах (Chrome) пример выше покажет iframe зелёным. А в некоторых (Firefox) – оранжевым.

Дело в том, что, когда iframe только создан, документ в нём обычно ещё не загружен.

При обычных значениях iframe src="...", которые указывают на HTML-страницу (даже если она уже в кеше), это всегда так. Документ, который в iframe на момент срабатывания скрипта iframeDoc – временный, он будет заменён на новый очень скоро. И работать надо уже с новым документом iframeDoc2 – например, по событию iframe.onload.

В случае с javascript-протоколом, по идее, ифрейм уже загружен, и тогда onload у него уже не будет. Но здесь мнения браузеров расходятся, некоторые (Firefox) всё равно «подгрузят» документ позже. Поэтому факт «готовности» документа в скрипте проверяется через iframeDoc.readyState.

Ещё раз заметим, что при обычных URL в качестве src нужно работать не с начальным документом, а с тем, который появится позже.
EXTENSION!@@



@@!BLOCK
Общение между окнами и фреймами
BLOCK!@@

@@!QWESTION
Вы находитесь на сайте site.com. Что выведет alert?
<iframe src="https://example.com" style="height:100px"></iframe>
<script>
  var iframe = document.getElementsByTagName('iframe')[0];
  iframe.contentWindow.onload = function() {
    alert( "contentWindow onload" );
  };
</script>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Ничего, событие не сработает
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Элемент <iframe> является «двуличным». С одной стороны, это обычный узел DOM, с другой – внутри находится окно, которое может иметь совершенно другой URL, содержать независимый документ из другого источника.

Внешний документ имеет полный доступ к <iframe> как к DOM-узлу. А вот к окну – если они с одного источника.

Это приводит к забавным последствиям. Например, чтобы узнать об окончании загрузки <iframe>, мы можем повесить обработчик iframe.onload. По сути, это то же самое что iframe.contentWindow.onload, но его мы можем поставить лишь в случае, если окно с того же источника.

 <iframe src="https://example.com" style="height:100px"></iframe>

<script>
  var iframe = document.getElementsByTagName('iframe')[0];

  // сработает
  iframe.onload = function() {
    alert( "iframe onload" );
  };

  // не сработает
  iframe.contentWindow.onload = function() {
    alert( "contentWindow onload" );
  };
</script>

Если бы в примере выше <iframe src> был с текущего сайта, то оба обработчика сработали бы.

Иерархия window.frames
Альтернативный способ доступа к окну ифрейма – это получить его из коллекции window.frames.

Есть два способа доступа:

window.frames[0] – доступ по номеру.
window.frames.iframeName – доступ по name ифрейма.
Обратим внимание: в коллекции хранится именно окно (contentWindow), а не DOM-элемент.

Демонстрация всех способов доступа к окну:

 <iframe src="javascript:''" style="height:80px" name="i"></iframe>

<script>
  var iframeTag = document.body.children[0];

  var iframeWindow = iframeTag.contentWindow; // окно из тега

  alert( frames[0] === iframeWindow ); // true, окно из коллекции frames
  alert( frames.i == iframeWindow ); // true, окно из frames по имени
</script>
Внутри ифрейма могут быть свои вложенные ифреймы. Всё это вместе образует иерархию.

Ссылки для навигации по ней:

window.frames – коллекция «детей» (вложенных ифреймов)

window.parent – содержит ссылку на родительское окно, позволяет обратиться к нему из ифрейма.

Всегда верно:

// (из окна со фреймом)
window.frames[0].parent === window; // true
window.top – содержит ссылку на самое верхнее окно (вершину иерархии).

Всегда верно (в предположении, что вложенные фреймы существуют):

window.frames[0].frames[0].frames[0].top === window
Свойство top позволяет легко проверить, во фрейме ли находится текущий документ:

 if (window == top) {
  alert( 'Этот скрипт является окном верхнего уровня в браузере' );
} else {
  alert( 'Этот скрипт исполняется во фрейме!' );
}
EXTENSION!@@



@@!BLOCK
Общение между окнами и фреймами
BLOCK!@@

@@!QWESTION
Содержание файла sandboxed.html:
  <form action="http://google.ru">
    <input type="text">
    <input type="submit" value="Отправить форму на http://google.ru">
  </form>
---------------
Отравится ли фора из iframe?
<iframe sandbox src="sandboxed.html"></iframe>
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Атрибут sandbox позволяет построить «песочницу» вокруг ифрейма, запретив ему выполнять ряд действий.

Наличие атрибута sandbox:

Заставляет браузер считать ифрейм загруженным с другого источника, так что он и внешнее окно больше не могут обращаться к переменным друг друга.
Отключает формы и скрипты в ифрейме.
Запрещает менять parent.location из ифрейма.
Если у атрибута sandbox нет значения, то браузер применяет максимум ограничений.

Атрибут sandbox может содержать через пробел список ограничений, которые не нужны:

allow-same-origin
Браузер будет считать документ в ифрейме пришедшим с другого домена и накладывать соответствующие ограничения на работу с ним. Если ифрейм и так с другого домена, то ничего не меняется.
allow-top-navigation
Разрешает ифрейму менять parent.location.
allow-forms
Разрешает отправлять формы из iframe.
allow-scripts
Разрешает выполнение скриптов из ифрейма. Но скриптам, всё же, будет запрещено открывать попапы.
На заметку:
Цель атрибута sandbox – наложить дополнительные ограничения. Он не может снять уже существующие, в частности, убрать ограничения безопасности, если ифрейм с другого источника.
EXTENSION!@@



@@!BLOCK
Кросс-доменные ограничения и их обход
BLOCK!@@

@@!QWESTION
Сайты http://www.site.com и http://site.com имеют один источник («same origin»)?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Ограничение «Same Origin» («тот же источник») ограничивает доступ окон и фреймов друг к другу, а также влияет на AJAX-запросы к серверу.
Два URL считаются имеющим один источник («same origin»), если у них одинаковый протокол, домен и порт.

Эти URL имеют один источник:

http://site.com
http://site.com/
http://site.com/my/page.html
А вот эти – все из других источников:

http://www.site.com (другой домен)
http://site.org (другой домен)
https://site.com (другой протокол)
http://site.com:8080 (другой порт)
Существует ряд исключений, позволяющих-таки окнам с разных доменов обмениваться информацией, но прямой вызов методов друг друга и чтение свойств запрещены.

<iframe src="https://example.com"></iframe>
<script>
  var iframe = document.body.children[0];

  iframe.onload = function() {
    try {
      alert( iframe.contentWindow.document );
    } catch (e) {
      alert( "Ошибка: " + e.message );
    }
  }
</script>
EXTENSION!@@



@@!BLOCK
Кросс-доменные ограничения и их обход
BLOCK!@@

@@!QWESTION
Могут ли окна читать location.href друг друга если она из разных источников?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Окна могут менять location друг друга, даже если они из разных источников.

Причём читать свойства location нельзя, одно окно не имеет право знать, на каком URL пользователь в другом. А вот запись браузеры считают безопасной.

Например, открыв на javascript.ru iframe с http://example.com, из этого ифрейма нельзя будет прочитать URL, а вот поменять его – запросто:

 <iframe src="https://example.com"></iframe>

<script>
  var iframe = document.body.children[0];

  iframe.onload = function() {
    try {
      // не сработает (чтение)
      alert( iframe.contentWindow.location.href );
    } catch (e) {
      alert( "Ошибка при чтении: " + e.message );
    }

    // сработает (запись)
    iframe.contentWindow.location.href = 'https://wikipedia.org';

    iframe.onload = null;
  }
</script>
EXTENSION!@@



@@!BLOCK
Кросс-доменные ограничения и их обход
BLOCK!@@

@@!QWESTION
Как снять ограничения с этих доменов?
john.site.com, peter.site.com, site.com
QWESTION!@@

@@!ANSWERS

@@!CORRECT
document.domain = 'site.com';
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Ещё одно важное исключение касается доменов третьего уровня.

Если несколько окон имеют общий домен второго уровня, к примеру john.site.com, peter.site.com, site.com, и присваивают в document.domain свой общий поддомен 2-го уровня site.com, то все ограничения снимаются.

То есть, на всех этих сайтах должен быть код:

document.domain = 'site.com';
Тогда между ними не будет кросс-доменных ограничений.

Обратим внимание: свойство document.domain должно быть присвоено на всех окнах, участвующих в коммуникации. Выглядит абсурдно, но даже на документе с site.com нужно вызвать: document.domain="site.com". Иначе не будет работать.

Таким образом разные подсайты в рамках одного общего проекта могут взаимодействовать без ограничений.

Исключения в IE
В браузере Internet Explorer есть два своих, дополнительных исключения из Same Origin Policy.

Порт не входит в понятие «источник» (origin).

Это означает, что окно с http://site.com может свободно общаться с http://site.com:8080.

Это иногда используют для общения серверов, использующих один IP-адрес. Но допустимо такое только в IE.

Если сайт находится в зоне «Надёжные узлы», то в Internet Explorer ограничения к нему не применяются.

При этом подразумевается, что для этой зоны в параметрах «Безопасность» включена опция «Доступ к источникам данных за пределами домена».

Итого
Ограничение «одного источника» запрещает окнам и фреймам с разных источников вызывать методы друг друга и читать данные друг из друга.

При этом «из одного источника» означает «совпадают протокол, домен и порт».

У этого подхода ряд существенных исключений:

Свойства window.location.* нельзя читать, но можно менять.
Домены третьего уровня с общим наддоменом могут поменять document.domain на их общий домен второго уровня, и тогда они смогут взаимодействовать без ограничений.
IE не включает порт в понятие источника. Кроме того, он позволяет снять ограничения для конкретного сайта включением в доверенную зону.
EXTENSION!@@



@@!BLOCK
Общение окон с разных доменов: postMessage
BLOCK!@@

@@!QWESTION
Как разрешить получение сообщений postMessage только из определённого источника?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Указать targetOrigin
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Интерфейс postMessage позволяет общаться друг с другом окнам и ифреймам с разных доменов.

Он очень удобен, например, для взаимодействия внешних виджетов и сервисов, подключённых через ифрейм с основной страницей.

Отправитель: метод postMessage
Первая часть интерфейса состоит из метода postMessage. Его вызывает окно, которое хочет отправить сообщение, в контексте окна-получателя.

Проще говоря, если мы хотим отправить сообщение в окно win, то нужно вызвать win.postMessage(data, targetOrigin).

Аргументы:

data
Данные. По спецификации, это может быть любой объект, который будет клонирован с сохранением структуры при передаче.

Но IE поддерживает только строки, поэтому обычно данные JSON-сериализуют.

targetOrigin
Разрешить получение сообщения только окнам с данного источника.

Мы ведь не можем из JavaScript узнать, на каком именно URL находится другое окно. Но иногда хочется быть уверенным, что данные передаются в доверенный документ. Для этого и нужен этот параметр. Проверку осуществляет браузер. При указании '*' ограничений нет.

Например:

<iframe src="http://target.com" name="target">

<script>
  var win = window.frames.target;
  win.postMessage("сообщение", "http://javascript.ru");
</script>
В IE11- можно использовать postMessage только для ифреймов
В браузере IE, интерфейс postMessage работает только с ифреймами. Он не работает между табами и окнами.

Это ошибка в данном конкретном браузере, в других – всё в порядке. Детали по этой и связанным с ней ошибкам: HTML5 Implementation Issues in IE8 and later.

Получатель: событие onmessage
Чтобы получить сообщение, окно должно поставить обработчик на событие onmessage.

Свойства объекта события:

data
Присланные данные
origin
Источник, из которого пришло сообщение, например http://javascript.ru.
source
Ссылка на окно, с которого пришло сообщение. Можно тут же ответить.
Назначать обработчик нужно обязательно через методы addEventListener/attachEvent, например:

function listener(event) {
  if (event.origin != 'http://javascript.ru') {
    // что-то прислали с неизвестного домена - проигнорируем..
    return;
  }

  alert( "получено: " + event.data );
}

if (window.addEventListener) {
  window.addEventListener("message", listener);
} else {
  // IE8
  window.attachEvent("onmessage", listener);
}
Задержка отсутствуют
Задержки между отправкой и получением нет, совсем.

Если для setTimeout стандарт предусматривает минимальную задержку 4 мс, то для postMessage она равна 0 мс. Поэтому postMessage можно, в том числе, использовать как мгновенную альтернативу setTimeout.

Итого
Интерфейс postMessage позволяет общаться окнам и ифреймам с разных доменов (в IE8 – только ифреймы), при этом обеспечивая проверки безопасности.

Отправитель вызывает targetWin.postMessage(data, targetOrigin).
Если targetOrigin не '*', то браузер проверяет, совпадает ли источник с targetWin.
Если совпадает, то на targetWin генерируется событие onmessage, в котором передаются:
origin – источник, с которого пришло сообщение.
source – ссылка на окно-отправитель.
data – данные. Везде, кроме IE, допустимы объекты, которые клонируются, а в IE – только строка.
Обработчик на onmessage необходимо вешать при помощи специализированных методов addEventListener/attachEvent.
EXTENSION!@@



@@!BLOCK
Привлечение внимания к окну
BLOCK!@@

@@!QWESTION
Всегда ли срабатывает метод window.focus?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Метод window.focus позволяет сфокусироваться на окне. Он работает по-разному в разных ОС и браузерах.

Проверьте, например:

setInterval(function() { window.focus() }, 1000);
Что будет, если запустить этот код, и затем переключиться в другое окно или вкладку?

Можно подумать, что окно будет оказываться в фокусе раз в секунду. Но это не так.

Произойдет одно из трех:

Вообще никакого эффекта. Самый распространённый случай, если в окне много вкладок.
Окно развернется (при необходимости) и выйдет на передний план. Обычно это происходит, когда метод window.focus() вызывается для попапа, а активно сейчас – главное окно. То есть, в этом случае вызов сработает.
Заголовок окна начнет мигать. Чтобы увидеть это в действии – откройте данную страницу в IE, запустите код и переключитесь на другое окно. Браузер попытается привлечь Ваше внимание миганием/мерцанием заголовка окна.

В дополнение к window.focus() используют мерцание заголовка окна, как показано в примере ниже:

 <script>
  var win = open('/', 'test', 'width=300,height=300')

  function getAttention(win) {
    if (win.closed) {
      alert( "Окно закрыто, привлечь внимание к нему нельзя" );
      return;
    }

    win.focus();
    var i = 0;
    var show = ['************', win.document.title];

    var focusTimer = setInterval(function() {
      if (win.closed) {
        clearInterval(focusTimer);
        return;
      }
      win.document.title = show[i++ % 2];
    }, 1000);

    win.document.onmousemove = function() {
      clearInterval(focusTimer);
      win.document.title = show[1];
      win.document.onmousemove = null;
    }
  }
</script>

<input type="button" onclick="getAttention(win)" value="getAttention(win)">

Запустите код и сверните всплывающее окно. А затем – нажмите кнопку с надписью «getAttention(win)». Браузер будет привлекать ваше внимание, как умеет ;)

Обратите внимание: в коде есть проверка на win.closed. Попытка манипулирования закрытым окном вызовет исключение.

Как только посетитель сфокусировался на окне индикация прекращается. Для определения момента фокусировки в примере выше используется событие document.onmousemove.

Можно было использовать событие window.onfocus, но, оказывается, оно ненадежно.

Когда событие onfocus не работает?
Возможно такое, что посетитель переключается на окно, а window.onfocus не происходит.

Это потому, что переключение между окнами и фокусировка – это разные вещи. Например, если курсор находится в поле для ввода URL браузера, то считается, что окно не в фокусе, хотя посетитель переключился на это окно.

Попробуйте проделать следующее:

Запустите пример с getAttention в Chrome или IE (кстати, в них нельзя отключить адресную панель).
Поместите курсор в панель адреса всплывающего окна.
Перейдите обратно к главному окну и нажмите кнопку getAttention(win)
Вы увидите, что несмотря на то, что вы переключились на окно, и оно сейчас на переднем плане, событие onfocus не срабатывает.

Есть и другие случаи, когда переключение между окнами не вызывает window.onfocus. Скажем, если окно сфокусировать щелчком в поле ввода формы, то в IE события window.onfocus (а также window.onfocusin) – не сработают!

Можно попробовать поймать момент фокусировки и по-другому, повесив дополнительные обработчики событий на document. В главе Фокусировка: focus/blur описана техника делегирования для focus/blur.

Но этот способ получает фокус только если посетитель сфокусируется где-то в документе: щелкнет или сделает еще какое-то действие в документе, а не просто посмотрит на него и проведет над ним мышкой.

Впрочем, никто не мешает использовать сочетание всех описанных методов.
EXTENSION!@@



@@!BLOCK
107--Атака Clickjacking и защита от неё
BLOCK!@@

@@!QWESTION
Какие документы можно рендерить во фрейме, если установлен такой заголовок
X-Frame-Options: SAMEORIGIN
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Документы, верхний документ (top) которых с того же домена
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
<p>Все современные браузеры поддерживают заголовок X-Frame-Options.</p> 
<p>Он разрешает или запрещает отображение страницы, если она открыта во фрейме.</p>
<p>Браузеры игнорируют заголовок, если он определен в МЕТА теге. Таким образом, <meta http-equiv="X-Frame-Options"...> будет проигнорирован.</p>
<p>У заголовка может быть три значения:</p>
<ul>
<li>
<p><strong>SAMEORIGIN</strong></p>
<p>Атаку «Clickjacking» легко осуществить, если на сайте есть действие, активируемое с помощью одного клика.</p>
<p>Злоумышленник может осуществить атаку целенаправленно на посетителей ресурса – опубликовав ссылку на форуме, или «счастливой рассылкой». Существует масса вариантов.</p>
<p>С первого взгляда, она «неглубокая»: всё, что можно сделать – это один клик. С другой стороны, если хакер знает, что после клика появляется какой-то другой управляющий элемент, то он, хитрыми сообщениями, может заставить посетителя кликнуть и по нему. А это уже не один, а два клика.</p>
<p>Атака особенно опасна, поскольку, проектируя интерфейс сайта, обычно никто и не задумывается о том, что клик от имени юзера может сделать хакер. Точки уязвимости могут быть в совершенно непредсказуемых местах.</p>
</li>
<li>
<p><strong>X-Frame-Options</strong></p>
<p>Рекомендуется использовать X-Frame-Options на страницах, заведомо не предназначеных для запуска во фрейме и на важнейших страницах (финансовые транзакции).</p>
<p>Используйте перекрывающий <div>, если это допустимо вашим проектом и вы хотите разрешить безопасный показ документа во фреймах с любых доменов.</p>
<p>Рендеринг документа, при открытии во фрейме, производится только в том случае, когда верхний (top) документ – с того же домена.</p>
</li>
<li>
<p><strong>DENY</strong></p>
<p>Рендеринг документа внутри фрейма запрещён.</p>
</li>
<li>
<p><strong>ALLOW-FROM domain</strong></p>
<p>Разрешает рендеринг, если внешний документ с данного домена (не поддерживается в Safari, Firefox).</p>
EXTENSION!@@



@@!BLOCK
Other
BLOCK!@@

@@!QWESTION
Будут ли получены данные value кнопки submit, если форма отправлена через form.submit?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Нет
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У каждого радио батона есть свойство value и на сервер будет отправлен value выбранного радиобатона. Если же мы не тронем ни одно радиобатона, то и на сервер ничего не придет связанного с радиобатонами.
Собственно та же ситуация и с кнопками submit, они работают примерно так же как и радиобатоны, но еще и отправляют форму.
Поэтому если вы отправляете форму напрямую через тег form то и параметров этих кнопок submit вы не увидите на сервере.
EXTENSION!@@



@@!BLOCK
Other
BLOCK!@@

@@!QWESTION
Что делает URL-псевдопротокол «javascript:» ?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
выполняет JavaScript код, указанный после данного псевдопротокола.
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
Синтаксис
javascript:[*(аргумент/выражение javascript;)]
URL-псевдопротокол «javascript:» выполняет JavaScript код, указанный после данного псевдопротокола.
EXTENSION!@@



@@!BLOCK
Other
BLOCK!@@

@@!QWESTION
Что выведет консоль?
const arr = [10, 12, 15, 21];
for (var i = 0; i < arr.length; i++) {
  setTimeout(function() {
    console.log('Index: ' + i + ', element: ' + arr[i]);
  }, 3000);
}
QWESTION!@@

@@!ANSWERS

@@!CORRECT
Index: 4, element: undefined
Index: 4, element: undefined
Index: 4, element: undefined
Index: 4, element: undefined
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
На самом деле, я уже писал о возможных подходах к ответу на этот вопрос в некоторых моих предыдущих материалах. В частности, в этом и этом. Позволю себе процитировать кое-что из этих публикаций:
Причина подобного заключается в том, что функция setTimeout создаёт функцию (замыкание), у которой есть доступ к внешней по отношению к ней области видимости, представленной в данном случае циклом, в котором объявляется и используется переменная i. После того, как пройдут 3 секунды, функция выполняется и выводит значение i, которое, после окончания работы цикла, остаётся доступным и равняется 4-м. Переменная, в ходе работы цикла, последовательно принимает значения 0, 1, 2, 3, 4, причём, последнее значение оказывается сохранённым в ней и после выхода из цикла. В массиве имеется четыре элемента, с индексами от 0 до 3, поэтому, попытавшись обратиться к arr[4], мы и получаем undefined. Как избавиться от undefined и сделать так, чтобы код выводил то, чего от него и ждут, то есть — значения элементов массива?

Вот пара распространённых подходов к решению подобной задачи, а конкретно — к тому, чтобы организовать доступ к нужному значению переменной цикла внутри функции, вызываемой setTimeout.

Первый предусматривает передачу необходимого параметра во внутреннюю функцию, второй основан на использовании возможностей ES6.

Итак, вот первый вариант:

const arr = [10, 12, 15, 21];
for (var i = 0; i < arr.length; i++) {
  // передадим функции переменную i, в результате
  // у каждой функции будет доступ к правильному значению индекса
  setTimeout(function(i_local) {
    return function() {
      console.log('The index of this number is: ' + i_local);
    }
  }(i), 3000);
}

Вот второй вариант:

const arr = [10, 12, 15, 21];
for (let i = 0; i < arr.length; i++) {
  // использование ключевого слова let, которое появилось в ES6,
  // позволяет создавать новую привязку при каждом вызове функции
  // подробности смотрите здесь: http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads
  setTimeout(function() {
    console.log('The index of this number is: ' + i);
  }, 3000);
}

На Reddit мне удалось найти похожий ответ на этот вопрос. Вот — хорошее разъяснение особенностей замыканий на StackOverflow.
EXTENSION!@@



@@!BLOCK
Other
BLOCK!@@

@@!QWESTION
Prevent redrawing image while page scroll for fixed elements (Chrome)
Каким набором css-свойств можно запретить браузеру Хром перерисовывать лэйаут во время скроллинга
для фиксированных (position: fixed) элементов?
QWESTION!@@

@@!ANSWERS

@@!CORRECT
-webkit-transform: translate3d(0, 0, 0);
-webkit-backface-visibility: hidden;
-webkit-perspective: 1000;
CORRECT!@@

@@!WRONG
WRONG!@@

ANSWERS!@@

@@!EXTENSION
У меня была такая же проблема с Chrome, кажется, это ошибка, которая возникает, когда внутри страницы слишком много происходит, я смог ее исправить, добавив следующий код преобразования в элемент фиксированной позиции (transform: translateZ (0); - webkit-transform: translateZ (0);), что заставляет браузер использовать аппаратное ускорение для доступа к графическому процессору устройства (GPU), чтобы заставить пикселы летать. С другой стороны, веб-приложения запускаются в контексте браузера, что позволяет программному обеспечению выполнять большинство (если не все) рендеринга, что приводит к меньшей мощности для переходов. Но Интернет догоняет, и большинство поставщиков браузеров теперь предоставляют графическое аппаратное ускорение с помощью определенных правил CSS. Использование -webkit-transform: translate3d (0,0,0); выведет GPU в действие для переходов CSS, делая их более плавными (более высокий FPS). Примечание: translate3d (0,0,0) ничего не делает с точки зрения того, что вы видите. он перемещает объект на 0px по оси x, y и z. Это всего лишь метод принудительного аппаратного ускорения.
EXTENSION!@@




















---
REGEXP: 
@@!NAME((.||\r||\n||\r\n)*?)NAME!@@